<?xml version="1.0"  encoding="UTF-8"?>
<rss version="2.0">  <channel>
    <title>pokerG</title>
    <link>http://pokerg.github.io</link>
    <pubDate>23 Oct 14 16:33 CST</pubDate>
    <item>
      <title>HITOSExperiment3-进程运行轨迹的跟踪与统计</title>
      <link>http://pokerg.github.io/OS/HITOSExperiment3-%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C%E8%BD%A8%E8%BF%B9%E7%9A%84%E8%B7%9F%E8%B8%AA%E4%B8%8E%E7%BB%9F%E8%AE%A1/</link>
      <pubDate>2014-10-23 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;实验内容&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;进程从创建（Linux下调用fork()）到结束的整个过程就是进程的生命期，进程在其生命期中的运行轨迹实际上就表现为进程状态的多次切换，如进程创建以后会成为就绪态；当该进程被调度以后会切换到运行态；在运行的过程中如果启动了一个文件读写操作，操作系统会将该进程切换到阻塞态（等待态）从而让出CPU；当文件读写完毕以后，操作系统会在将其切换成就绪态，等待进程调度算法来调度该进程执行……&lt;/p&gt;&#xA;&#xA;&lt;p&gt;本次实验包括如下内容：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;基于模板“process.c”编写多进程的样本程序，实现如下功能：&#xA;所有子进程都并行运行，每个子进程的实际运行时间一般不超过30秒；&#xA;父进程向标准输出打印所有子进程的id，并在所有子进程都退出后才退出；&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;在Linux 0.11上实现进程运行轨迹的跟踪。基本任务是在内核中维护一个日志文件/var/process.log，把从操作系统启动到系统关机过程中所有进程的运行轨迹都记录在这一log文件中。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;在修改过的0.11上运行样本程序，通过分析log文件，统计该程序建立的所有进程的等待时间、完成时间（周转时间）和运行时间，然后计算平均等待时间，平均完成时间和吞吐量。可以自己编写统计程序，也可以使用python脚本程序—— stat_log.py ——进行统计。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;修改0.11进程调度的时间片，然后再运行同样的样本程序，统计同样的时间数据，和原有的情况对比，体会不同时间片带来的差异。&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h2&gt;1&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;这个很简单,cpuio_bound这个函数指导书上已经给你了,只需要在main中创建几个进程去调用它就行,看看fork和wait函数,这个程序就差不多了&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&#xA;int main(int argc, char * argv[])&#xA;{&#xA;    pid_t pid1;&#xA;    pid_t pid2;&#xA;    pid_t pid3;&#xA;    pid_t pid4;&#xA;&#xA;    if(0 == (pid1 = fork())){&#xA;        printf(&#34;In the frist process!\n&#34;);&#xA;        cpuio_bound(10,1,0);&#xA;    }else if(0 == (pid2 = fork())){&#xA;        printf(&#34;In the second process!\n&#34;);&#xA;        cpuio_bound(10,0,1);&#xA;    }else if(0 == (pid3 = fork())){&#xA;        printf(&#34;In the third process\n&#34;);&#xA;        cpuio_bound(10,3,7);&#xA;    }else if(0 == (pid4 = fork())){&#xA;        printf(&#34;In the forth process\n&#34;);&#xA;        cpuio_bound(10,5,5);&#xA;    }else if(pid1 &lt; 0 &amp;&amp; pid2 &lt; 0 &amp;&amp; pid3 &lt; 0 &amp;&amp; pid4 &lt; 0){&#xA;        fprintf(stderr, &#34;Fork error!\n&#34;);&#xA;    }else{&#xA;        wait(NULL);&#xA;        printf(&#34;the frist process&#39;s is :%d\n&#34;, pid1);&#xA;        printf(&#34;the second process&#39;s is :%d\n&#34;, pid2);&#xA;        printf(&#34;the third process&#39;s is :%d\n&#34;, pid3);&#xA;        printf(&#34;the forth process&#39;s is :%d\n&#34;, pid4);&#xA;    }&#xA;&#xA;    &#xA;    return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;2&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;这个任务是这次实验的核心,如何打开log文件,写log文件,指导书上写的很明白,修改&lt;em&gt;init/main.c&lt;/em&gt; 和 &lt;em&gt;kernel/printk.c&lt;/em&gt; 即可&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;接下来的问题就是去记录进程运行跪进,也就是进程的切换点,详细的东西参考指导书就好,  这里就说明几个关键点.&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;进程的状态有 N(创建),J(就绪),R(运行),W(堵塞),E(退出)五种&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;如何知道哪里发生了进程状态的变化,很简单找到所有发生进程state变化的地方&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&#xA;p-&gt;state = TASK_XXX;&#xA;//我们的工作只需在不同的地方修改下面语句第一个参数和第二个参数&#xA;fprintk(3, &#34;%ld\t%c\t%ld\n&#34;, p-&gt;pid, &#39;R&#39;, jiffies); //向log文件输出&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;如何判断进程状态发生了何种变化? 新建在fork.c的copy_process&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&#xA;fprintk(3, &#34;%ld\t%c\t%ld\n&#34;, p-&gt;pid, &#39;N&#39;, jiffies); //向log文件输出&#xA;p-&gt;state = TASK_RUNNING;    /* do this last, just in case */&#xA;fprintk(3, &#34;%ld\t%c\t%ld\n&#34;, p-&gt;pid, &#39;J&#39;, jiffies); //向log文件输出&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;就绪与运行间的状态转移是通过schedule()（它亦是调度算法所在）完成的；运行到睡眠依靠的是sleep_on()和interruptible_sleep_on()，还有进程主动睡觉的系统调用sys_pause()和sys_waitpid()；睡眠到就绪的转移依靠的是wake_up()。&lt;br /&gt;&#xA;退出在exit.c state变为TASK_ZOMBIE的时候&lt;/p&gt;&#xA;&lt;/blockquote&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;blockquote&gt;&#xA;&lt;p&gt;为了让生成的log文件更精准，以下几点请注意：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;进程退出的最后一步是通知父进程自己的退出，目的是唤醒正在等待此事件的父进程。从时序上来说，应该是子进程先退出，父进程才醒来。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;schedule()找到的next进程是接下来要运行的进程（注意，一定要分析清楚next是什么）。如果next恰好是当前正处于运行态的进程，swith_to(next)也会被调用。这种情况下相当于当前进程的状态没变。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;系统无事可做的时候，进程0会不停地调用sys_pause()，以激活调度算法。此时它的状态可以是等待态，等待有其它可运行的进程；也可以叫运行态，因为它是唯一一个在CPU上运行的进程，只不过运行的效果是等待。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;第一点没啥说的,第二点用代码说明比较简单&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&#xA;//这段代码在sched.c的schedule()&#xA;if(current-&gt;state == TASK_RUNNING &amp;&amp; current != task[next]){&#xA;    fprintk(3, &#34;%ld\t%c\t%ld\n&#34;, current-&gt;pid, &#39;J&#39;, jiffies); //向log文件输出&#xA;}&#xA;if(current != task[next]){&#xA;    fprintk(3, &#34;%ld\t%c\t%ld\n&#34;, task[next]-&gt;pid, &#39;R&#39;, jiffies); //向log文件输出&#xA;}&#xA;switch_to(next);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;第三点&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&#xA;int sys_pause(void)&#xA;{&#xA;current-&gt;state = TASK_INTERRUPTIBLE;&#xA;if(current-&gt;pid != 0){&#xA;    fprintk(3, &#34;%ld\t%c\t%ld\n&#34;, current-&gt;pid, &#39;W&#39;, jiffies); //向log文件输出&#xA;}&#xA;schedule();&#xA;return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h2&gt;3&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;运行python stat_log.py hdc/var/process.log&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;4&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;修改include/sched.h的INIT_TASK的第三个值&lt;/p&gt;&#xA;&#xA;&lt;p&gt;具体代码请戳&lt;a href=&#34;https://github.com/pokerG/HIT-OS-Experiment/tree/ThreadTracker&#34;&gt;https://github.com/pokerG/HIT-OS-Experiment/tree/ThreadTracker&lt;/a&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>K近邻算法之局部敏感哈希</title>
      <link>http://pokerg.github.io/MachineLearning/K%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95%E4%B9%8B%E5%B1%80%E9%83%A8%E6%95%8F%E6%84%9F%E5%93%88%E5%B8%8C/</link>
      <pubDate>2014-10-08 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;问题背景&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;KNN 算法,即 K 最近邻算法,是模式识别中一种最基本的用于分类与回归的非参方法。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;KNN 算法的核心思想是如果一个样本在特征空间中的 K 个最相邻的样本中的大多数属于某一个类别,则该样本也属于这个类别,并具有这个类别上样本的特性。该方法在确定分类决策上只依据最邻近的一个或者几个样本的类别来决定待分样本所属的类别。 KNN 方法在类别决策时,只与极少量的相邻样本有关。由于 KNN 方法主要靠周围有限的邻近的样本,而不是靠判别类域的方法来确定所属类别的,因此对于类域的交叉或重叠较多的待分样本集&#xA;来说,KNN 方法较其他方法更为适合。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;KNN 问题最主要的难点在于,在输入数据规模较大(N 较大)的情况下,朴素的线性查找算法变得难以接受。为此,学界主要提出两种不同的改进思路:空间划分和哈希。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;这里我们重点了解下局部敏感哈希。&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;局部敏感哈希&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;Indyk(1998) 最早提出了局部敏感哈希算法,为了解决所谓的“高维诅咒”给空间划分方法带来的优化难题。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&amp;emsp;&amp;emsp;1.基本原理&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;我们知道,通过建立 hash table 的方式我们能够得到 O(1)的查找时间性能,其中关键在于选取一个 hash function,将原始数据映射到相对应的桶内(bucket, hash bin),例如对数据求模:h = x mod w,w 通常为一个素数。在对数据集进行 hash 的过程中,会发生不同的数据被映射到了同一个桶中(即发生了冲突 collision),这一般通过再次哈希将数据映射到其他空桶内来解决。这是普通 hash 方法或者叫传统 hash 方法,其与 LSH 有些不同之处。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;我们的目的是相近的向量对几乎相同的输入内容，产生相同或者相近的hashcode。也就是说，hashcode本身的相近程度就可以反应输入的相似程度。换句话说，如果两个向量相似，则它们的哈希值有较高的概率是相同的。因此，我们的hash fuctions应该反映空间的相对关系。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;那具有怎样特点的hash functions才能够使得原本相邻的两个数据点经过hash变换后会落入相同的桶内？这些hash function需要满足以下两个条件：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;1）如果d(x,y) ≤ d1， 则h(x) = h(y)的概率至少为p1；&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;2）如果d(x,y) ≥ d2， 则h(x) = h(y)的概率至多为p2；&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;其中d(x,y)表示x和y之间的距离，d1 &amp;lt; d2， h(x)和h(y)分别表示对x和y进行hash变换。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;满足以上两个条件的hash functions称为(d1,d2,p1,p2)-sensitive。而通过一个或多个(d1,d2,p1,p2)-sensitive的hash function对原始数据集合进行hashing生成一个或多个hash table的过程称为Locality-sensitive Hashing。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&amp;emsp;&amp;emsp;2.哈希函数&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;LSH的实现主要依赖于局部敏感哈希函数族。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;设计针对不同距离度量的局部敏感哈希函数族是设计局部敏感哈希算法的关键，下面介绍几种常用的距离度量。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;*余弦距离：两个点之间的余弦距离被视为由这两个点形成的向量之间的角度。不管这个空间是几维的，这个角度在 0 度于 180 度之间。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;LSH hash function为：H(V) = sign(V·R)，R是一个随机向量。V·R可以看做是V向R上进行投影操作。其是(d1,d2,(180-d1)180,(180-d2)/180)-sensitive的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;*Jaccard距离：又叫Jaccard系数或Jaccard相似性系数，用来比较样本集中的相似性和分散性的一个概率。Jaccard系数等于样本集交集与样本集合集的比值，即J=|A∩B|/|A∪B|J(V1, V2)=| V1∩V2 | / | V1∪V2 |&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;LSH hash function为：minhash，其是(d1,d2,1-d1,1-d2)-sensitive的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;*汉明距离：给定一个向量空间，汉明距离被定义为两个向量之间它们坐标不同的数目。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;LSH hash function为：H(V) = 向量V的第i位上的值，其(d1,d2,1-d1/d,1-d2/d)-sensitive的。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&amp;emsp;&amp;emsp;3.LSH 应用于 KNN&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;我们只需在候选的table中逐个比较就可以了。LSH解决KNN给出的结果是非准确的。但是有较高的概率保证。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&amp;emsp;&amp;emsp;4.伪代码&lt;/h2&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&#xA;function preprocessin(Es)&#xA;{&#xA;    for each i in [1..l] do&#xA;        generate a random hash function Hi;&#xA;    done;&#xA;    for each i in [1..l] do&#xA;        for each j in [1..|E|] do&#xA;            store pj on bucket Hi(pj) of hash table Ti;&#xA;        done;&#xA;    done;&#xA;    return All hash table T;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;哈希表建立好之后就可以进行查询。对于某个待查询的点q：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&#xA;function approximate_knn_query(q)&#xA;{&#xA;    S &lt;- null;&#xA;    for each i in [1..l] do&#xA;        S &lt;- S add {points found in Hi(q) bucket of talbe Ti};&#xA;    done;&#xA;    return the K nearest neighbors of q in S;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h1&gt;总结&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;本文简单介绍了LSH算法的原理和实现，对于高维下的近似查找，LSH有很高的准确性，而且空间复杂度和时间复杂度都相对较低，适用于数据规模很大而对不准确性有着较好容忍的情况。在图像检索，音乐检索，分类聚类等方面有着广泛应用。&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;参考文献&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;*[局部敏感哈希(Locality-Sensitive Hashing, LSH)方法介绍](&amp;ldquo;http://blog.csdn.net/icvpr/article/details/12342159&amp;rdquo;)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;*史世泽，局部敏感哈希的研究，西安电子科技大学，2013年3月&lt;/p&gt;&#xA;&#xA;&lt;p&gt;*Gionis, A., Indyk, P., &amp;amp; Motwani, R. (1999, September). Similarity search in high dimensions via hashing. In VLDB (Vol. 99, pp. 518-529).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;*[LSH算法原理](&amp;ldquo;http://blog.csdn.net/fuyangchang/article/details/5631547&amp;rdquo;)&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>HITOSExperiment2-系统调用</title>
      <link>http://pokerg.github.io/OS/HITOSExperiment2-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</link>
      <pubDate>2014-09-28 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;##实验内容##&lt;/p&gt;&#xA;&#xA;&lt;p&gt;此次实验的基本内容是：在Linux 0.11上添加两个系统调用，并编写两个简单的应用程序测试它们。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;####iam()####&lt;/p&gt;&#xA;&#xA;&lt;p&gt;第一个系统调用是iam()，其原型为：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;int iam(const char * name);&#xA;完成的功能是将字符串参数name的内容拷贝到内核中保存下来。要求name的长度不能超过23个字符。返回值是拷贝的字符数。如果name的字符个数超过了23，则返回“-1”，并置errno为EINVAL。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在kernal/who.c中实现此系统调用。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;####whoami()####&lt;/p&gt;&#xA;&#xA;&lt;p&gt;第二个系统调用是whoami()，其原型为：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;int whoami(char* name, unsigned int size);&#xA;它将内核中由iam()保存的名字拷贝到name指向的用户地址空间中，同时确保不会对name越界访存（name的大小由size说明）。返回值是拷贝的字符数。如果size小于需要的空间，则返回“-1”，并置errno为EINVAL。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;也是在kernal/who.c中实现。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;测试程序&lt;/p&gt;&#xA;&#xA;&lt;p&gt;运行添加过新系统调用的Linux 0.11，在其环境下编写两个测试程序iam.c和whoami.c。最终的运行结果是：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$ ./iam lizhijun&#xA;$ ./whoami&#xA;lizhijun&lt;/p&gt;&#xA;&#xA;&lt;p&gt;##原理分析##&lt;/p&gt;&#xA;&#xA;&lt;p&gt;关于&lt;em&gt;_syscalln&lt;/em&gt; ， &lt;em&gt;int 0x80&lt;/em&gt; 以及 &lt;em&gt;用户态和内核态之间的数据传递&lt;/em&gt; 指导书上已经写的很清楚了，我只说说我们需要做的工作.&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;在&lt;em&gt;include/unistd.h&lt;/em&gt; 定义iam 和 whoami 的功能号&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&#xA;#define __NR_ssetmask   69&#xA;#define __NR_setreuid   70&#xA;#define __NR_setregid   71&#xA;#define __NR_iam        72 //我们增加的功能&#xA;#define __NR_whoami     73&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这里需要注意在0.11环境下编译C程序，包含的头文件都在/usr/include目录下。该目录下的unistd.h是标准头文件。我们可以使用*sudo ./mount-hdc*挂载虚拟硬盘，具体请看 实验指导书-实验环境的搭建与使用-ubuntu与linux0.11之间的文件交换。&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;在&lt;em&gt;include/linux/sys.h&lt;/em&gt; 声明函数并加入到*sys_call_table[]*中&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&#xA;extern int sys_setregid();&#xA;extern int sys_iam();&#xA;extern int sys_whoami();&#xA;&#xA;fn_ptr sys_call_table[] = { sys_setup, sys_exit, sys_fork, sys_read,&#xA;sys_write, sys_open, sys_close, sys_waitpid, sys_creat, sys_link,&#xA;sys_unlink, sys_execve, sys_chdir, sys_time, sys_mknod, sys_chmod,&#xA;sys_chown, sys_break, sys_stat, sys_lseek, sys_getpid, sys_mount,&#xA;sys_umount, sys_setuid, sys_getuid, sys_stime, sys_ptrace, sys_alarm,&#xA;sys_fstat, sys_pause, sys_utime, sys_stty, sys_gtty, sys_access,&#xA;sys_nice, sys_ftime, sys_sync, sys_kill, sys_rename, sys_mkdir,&#xA;sys_rmdir, sys_dup, sys_pipe, sys_times, sys_prof, sys_brk, sys_setgid,&#xA;sys_getgid, sys_signal, sys_geteuid, sys_getegid, sys_acct, sys_phys,&#xA;sys_lock, sys_ioctl, sys_fcntl, sys_mpx, sys_setpgid, sys_ulimit,&#xA;sys_uname, sys_umask, sys_chroot, sys_ustat, sys_dup2, sys_getppid,&#xA;sys_getpgrp, sys_setsid, sys_sigaction, sys_sgetmask, sys_ssetmask,&#xA;sys_setreuid,sys_setregid,sys_iam,sys_whoami };&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;修改&lt;em&gt;kernel/sys_call.s*中的*nr_system_calls&lt;/em&gt; 之前为72，改为74&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&#xA;# offsets within sigaction&#xA;sa_handler = 0&#xA;sa_mask = 4&#xA;sa_flags = 8&#xA;sa_restorer = 12&#xA;&#xA;nr_system_calls = 74&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;编写&lt;em&gt;kernel/who.c&lt;/em&gt;,其中用两个系统调用iam()和whoami(), 这个按着要求来就行了，注意   #include &lt;strong&gt;LIBRARY&lt;/strong&gt;  和 使用 get_fs_byte() put_fs_byte() 读取写入数据&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;修改makefile，使得who.c 会被编入内核&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;编写应用程序 iam.c whoami.c,这个也通过虚拟硬盘传到linux0.11&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&#xA;#define __LIBRARY__&#xA;#include &lt;unistd.h&gt;&#xA;#include &lt;errno.h&gt;&#xA;#include &lt;stdio.h&gt;&#xA;&#xA;_syscall1(int,iam,const char*,name)&#xA;&#xA;int main(int argc,char * args[]){&#xA;    if(argc &gt; 1){&#xA;        if(iam(args[1]) &lt; 0){&#xA;            printf(&#34;SystemCall Exception!\n&#34;);&#xA;            return -1;&#xA;        }&#xA;    }else{&#xA;        printf(&#34;Input Exception!\n&#34;);&#xA;        return -1;&#xA;    }&#xA;    return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&#xA;#define __LIBRARY__&#xA;#include &lt;unistd.h&gt;&#xA;#include &lt;string.h&gt;&#xA;#include &lt;errno.h&gt;&#xA;#include &lt;stdio.h&gt;&#xA;&#xA;_syscall2(int,whoami,char*,name,unsigned int,size)&#xA;&#xA;int main(){&#xA;    int count;&#xA;    char name[30] = {0};&#xA;    count = whoami(name,30);&#xA;    if(count &lt; 0){&#xA;        printf(&#34;SystemCall Exception!\n&#34;);&#xA;        return -1;&#xA;    }else{&#xA;        printf(&#34;%s\n&#34;,name);&#xA;    }&#xA;    return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;使用提供的测试脚本进行测试&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;##总结##&lt;/p&gt;&#xA;&#xA;&lt;p&gt;好好看看实验指导书，只要理解了原理，做起来还是很简单的&lt;/p&gt;&#xA;&#xA;&lt;p&gt;具体代码请戳&lt;a href=&#34;https://github.com/pokerG/HIT-OS-Experiment/tree/syscall&#34;&gt;https://github.com/pokerG/HIT-OS-Experiment/tree/syscall&lt;/a&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>HITOSExperiment1-操作系统的引导</title>
      <link>http://pokerg.github.io/OS/HITOSExperiment1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%95%E5%AF%BC/</link>
      <pubDate>2014-09-27 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;##实验内容##&lt;/p&gt;&#xA;&#xA;&lt;p&gt;改写bootsect.s主要完成如下功能：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;bootsect.s能在屏幕上打印一段提示信息“XXX is booting&amp;hellip;”，其中XXX是你给自己的操作系统起的名字，例如LZJos、Sunix等（可以上论坛上秀秀谁的OS名字最帅，也可以显示一个特色logo，以表示自己操作系统的与众不同。）&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;改写setup.s主要完成如下功能：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;bootsect.s能完成setup.s的载入，并跳转到setup.s开始地址执行。而setup.s向屏幕输出一行&amp;rdquo;Now we are in SETUP&amp;rdquo;。&lt;/li&gt;&#xA;&lt;li&gt;setup.s能获取至少一个基本的硬件参数（如内存参数、显卡参数、硬盘参数等），将其存放在内存的特定地址，并输出到屏幕上。&lt;/li&gt;&#xA;&lt;li&gt;setup.s不再加载Linux内核，保持上述信息显示在屏幕上即可。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;####第一个非常简单，而且在实验指导书里写的很清楚了####&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&#xA;    ! 首先读入光标位置&#xA;    mov ah,#0x03        &#xA;    xor bh,bh&#xA;    int 0x10&#xA;&#xA;    ! 显示字符串“LZJos is running...”&#xA;    mov cx,#25          ! 要显示的字符串长度&#xA;    mov bx,#0x0007      ! page 0, attribute 7 (normal)&#xA;    mov bp,#msg1&#xA;    mov ax,#0x1301      ! write string, move cursor&#xA;    int 0x10&#xA;&#xA;inf_loop:&#xA;    jmp inf_loop        ! 后面都不是正经代码了，得往回跳呀&#xA;    ! msg1处放置字符串&#xA;&#xA;msg1:&#xA;    .byte 13,10         ! 换行+回车&#xA;    .ascii &#34;LZJos is running...&#34;&#xA;    .byte 13,10,13,10           ! 两对换行+回车&#xA;    !设置引导扇区标记0xAA55&#xA;    .org 510&#xA;boot_flag:&#xA;    .word 0xAA55            ! 必须有它，才能引导&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;我们需要改的只有两个地方&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&#xA;    98 mov cx,#24 !改成msg1的长度&#xA;    &#xA;    244 msg1:&#xA;       .byte 13,10&#xA;       .ascii &#34;Loading system ...&#34;&#xA;       .byte 13,10,13,10&#xA;       ！改成你希望显示的，但是不能太长&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;       &#xA;&#xA;&lt;p&gt;这是我的结果&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&#xA;    mov cx,#108&#xA;    msg1:&#xA;    .byte 13,10&#xA;    .ascii &#34;     ___ ___     __   __&#34;&#xA;    .byte 13,10&#xA;    .ascii &#34;|__|  |   | ___ |  | |__&#34;&#xA;    .byte 13,10&#xA;    .ascii &#34;|  | _|_  |     |__|  __|&#34;&#xA;    .byte 13,10&#xA;    .ascii &#34;pokerface is booting ...&#34;&#xA;    .byte 13,10,13,10&#xA;&lt;/code&gt;&lt;/pre&gt;   &#xA;输出 *HIT-OS pokerface is booting ...*&#xA;&#xA;####第二个其实也非常简单，只不过实验指导书上写的有些歧义。就是在*setup.s*的开头加上一段输出的代码&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&#xA;entry start&#xA;start:&#xA;!print some message&#xA;    mov ax,#SETUPSEG&#xA;    mov es,ax&#xA;    mov ah,#0x03        ! read cursor pos&#xA;    xor bh,bh&#xA;    int 0x10&#xA;    &#xA;    mov cx,#25&#xA;    mov bx,#0x0007      ! page 0, attribute 7 (normal)&#xA;    mov bp,#msg_setup&#xA;    mov ax,#0x1301      ! write string, move cursor&#xA;    int 0x10&#xA;&#xA;! ok, the read went well so we get current cursor position and save it for&#xA;! posterity.&#xA;msg_setup:&#xA;    .byte 13,10&#xA;    .ascii &#34;Now we are in SETUP&#34;&#xA;    .byte 13,10,13,10&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;注意一点， 这里ES不是&lt;em&gt;bootsect.s*中的&lt;/em&gt;#INITSEG&lt;em&gt;而是*SETUPSEG&lt;/em&gt;,如果没有更改将会导致乱码&lt;/p&gt;&#xA;&#xA;&lt;p&gt;####关于第三个如何获取硬件参数，指导书上写的很详细了，这里直接上代码&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&#xA;    mov ax,#SETUPSEG&#xA;    mov es,ax   ! if not  will be unreadable codes  &#xA;!print the cursor position&#xA;    mov ah,#0x03        ! read cursor pos&#xA;    xor bh,bh&#xA;    int 0x10&#xA;    &#xA;    mov cx,#13&#xA;    mov bx,#0x0007      ! page 0, attribute 7 (normal)&#xA;    mov bp,#msg_cursor&#xA;    mov ax,#0x1301      ! write string, move cursor&#xA;    int 0x10&#xA;&#xA;    mov ax,#INITSEG&#xA;    mov ds,ax&#xA;    mov bp,#0&#xA;&#xA;    call print_hex  &#xA;&#xA;!print the size of memory&#xA;    mov ah,#0x03        ! read cursor pos&#xA;    xor bh,bh&#xA;    int 0x10&#xA;    &#xA;    mov cx,#14&#xA;    mov bx,#0x0007      ! page 0, attribute 7 (normal)&#xA;    mov bp,#msg_mem&#xA;    mov ax,#0x1301      ! write string, move cursor&#xA;    int 0x10&#xA;&#xA;    mov ax,#INITSEG&#xA;    mov ds,ax&#xA;    mov bp,#2&#xA;&#xA;    call print_hex      &#xA;&#xA;!print the hd0 data:&#xA;    mov ah,#0x03        ! read cursor pos&#xA;    xor bh,bh&#xA;    int 0x10&#xA;    &#xA;    mov cx,#11&#xA;    mov bx,#0x0007      ! page 0, attribute 7 (normal)&#xA;    mov bp,#msg_hd0&#xA;    mov ax,#0x1301      ! write string, move cursor&#xA;    int 0x10&#xA;&#xA;    mov ax,#INITSEG&#xA;    mov ds,ax&#xA;    mov bp,#0x80&#xA;    mov bx,#16&#xA;    mov bp,#0x80&#xA;loop_hd:&#xA;    call print_hex&#xA;    add bp,#2&#xA;    sub bx,#2&#xA;    cmp bx,#0&#xA;    ja loop_hd&#xA;&#xA;    jmp print_nl&#xA;&#xA;print_hex:&#xA;    mov cx,#4       ! 4个十六进制数字&#xA;    mov dx,(bp)     ! 将(bp)所指的值放入dx中，如果bp是指向栈顶的话&#xA;print_digit:&#xA;    rol dx,#4       ! 循环以使低4比特用上 !! 取dx的高4比特移到低4比特处。&#xA;    mov ax,#0xe0f   ! ah = 请求的功能值，al = 半字节(4个比特)掩码。&#xA;    and al,dl       ! 取dl的低4比特值。&#xA;    add al,#0x30    ! 给al数字加上十六进制0x30&#xA;    cmp al,#0x3a&#xA;    jl  outp        !是一个不大于十的数字&#xA;    add al,#0x07    !是a～f，要多加7&#xA;outp: &#xA;    int 0x10&#xA;    loop    print_digit&#xA;    ret &#xA;&#xA;print_nl:&#xA;    mov ax,#0xe0d   ! CR&#xA;    int 0x10&#xA;    mov al,#0xa     ! LF&#xA;    int 0x10&#xA;msg_setup:&#xA;    .byte 13,10&#xA;    .ascii &#34;Now we are in SETUP&#34;&#xA;    .byte 13,10,13,10&#xA;&#xA;msg_cursor:&#xA;    .byte 13,10&#xA;    .ascii &#34;Cursor Pos:&#34;&#xA;msg_mem:&#xA;    .byte 13,10&#xA;    .ascii &#34;Memory Size:&#34;&#xA;msg_hd0:&#xA;    .byte 13,10&#xA;    .ascii &#34;HD0 data:&#34;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;有几点需要注意：&#xA;&#xA;1. 要先把ES设为*#SETUPSEG* 否则会乱码&#xA;2. 在*call print_hex* 之前要设置bp，即读取的数据的初始偏移量&#xA;3. 因为*print_hex*一次读取2个字节，所以对于多于2个字节的数据要循环读取，如hd0&#xA;&#xA;####还有关于编译的问题&#xA;&#xA;根据指导书所说，我们修改tools/build.c&#xA;&#xA;#####linux 0.11&#xA;&lt;pre&gt;&lt;code&gt;&#xA;    if ((id=open(argv[3],O_RDONLY,0))&lt;0)&#xA;        die(&#34;Unable to open &#39;system&#39;&#34;);&#xA;//  if (read(id,buf,GCC_HEADER) != GCC_HEADER)&#xA;//      die(&#34;Unable to read header of &#39;system&#39;&#34;);&#xA;//  if (((long *) buf)[5] != 0)&#xA;//      die(&#34;Non-GCC header of &#39;system&#39;&#34;);&#xA;    for (i=0 ; (c=read(id,buf,sizeof buf))&gt;0 ; i+=c )&#xA;        if (write(1,buf,c)!=c)&#xA;            die(&#34;Write call failed&#34;);&#xA;    close(id);&#xA;    fprintf(stderr,&#34;System is %d bytes.\n&#34;,i);&#xA;    if (i &gt; SYS_SIZE*16)&#xA;        die(&#34;System is too big&#34;);&#xA;    return(0);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;#####修改后&#xA;&lt;pre&gt;&lt;code&gt;&#xA;    if ((id=open(argv[3],O_RDONLY,0))&gt;=0){      &#xA;//  if (read(id,buf,GCC_HEADER) != GCC_HEADER)&#xA;//      die(&#34;Unable to read header of &#39;system&#39;&#34;);&#xA;//  if (((long *) buf)[5] != 0)&#xA;//      die(&#34;Non-GCC header of &#39;system&#39;&#34;);&#xA;        for (i=0 ; (c=read(id,buf,sizeof buf))&gt;0 ; i+=c )&#xA;            if (write(1,buf,c)!=c)&#xA;                die(&#34;Write call failed&#34;);&#xA;        close(id);&#xA;        fprintf(stderr,&#34;System is %d bytes.\n&#34;,i);&#xA;        if (i &gt; SYS_SIZE*16)&#xA;            die(&#34;System is too big&#34;);&#xA;    }&#xA;    return(0);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;总体来说，这个实验还是很简单的，很适合新手刚上来熟悉操作系统的修改，编译，调试&lt;/p&gt;&#xA;&#xA;&lt;p&gt;整个修改代码请戳 &lt;a href=&#34;https://github.com/pokerG/HIT-OS-Experiment/tree/boot&#34;&gt;https://github.com/pokerG/HIT-OS-Experiment/tree/boot&lt;/a&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>抵巇--鬼谷子第四篇</title>
      <link>http://pokerg.github.io/鬼谷子/%E6%8A%B5%E5%B7%87--%E9%AC%BC%E8%B0%B7%E5%AD%90%E7%AC%AC%E5%9B%9B%E7%AF%87/</link>
      <pubDate>2013-11-28 12:00:00 +0800</pubDate>
      <description>&#xA; &lt;p&gt;&amp;emsp;&amp;emsp;本篇不像其他各篇，从一些微观和具体操作入手，这篇作者是站在一个宏观的角度，来对问题进行阐述和应对方法。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;巇，就是裂缝，抵巇就是通过抵御来使其得以恢复秩序，一种办法是弥补，另一种就是破而后立。这在古代确实是惊天之语。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;&amp;ldquo;经起秋毫之末，挥之于太山之本。“千里之堤，溃于蚁穴就是这个道理。“自天地之合离终始，必有巇隙，不可不察也”，切记切记，“察之以捭阖”，我们既要放宽心态，又要注意小心谨慎。&lt;/p&gt;</description>
    </item>
    <item>
      <title>阴符经全文</title>
      <link>http://pokerg.github.io/阴符经/%E9%98%B4%E7%AC%A6%E7%BB%8F%E5%85%A8%E6%96%87/</link>
      <pubDate>2013-11-24 12:00:00 +0800</pubDate>
      <description>&#xA; &lt;p&gt;&amp;emsp;&amp;emsp;第一次看到《阴符经》是在《大秦帝国-国命纵横》，当时觉得读起来特别有感觉，所以就摘录了下来，早读的时候没事干就背了下来，其实当时只是隐隐约约明白一点，然后想彻底的了解，但是到图书馆找没有相关的书籍，而且当时是寄宿在学校，上网也不是很方便，久而久之也就忘了这回事，后来无一中在南怀瑾的《老子他说》中又看到了，就到网上搜了下，发现以前在《大秦帝国》上竟然引用的是全文！！（我一直以为是片段），顿时觉得这本书不可不读，就买了本《阴符经集释》，因为前一段时间比较忙，也没有怎么看，前几天中午的时候闲来没事，随手翻了翻，就被其吸引了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;这里我就先默写一遍，以表对其的尊重。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;观天之道，执天之行，尽矣。天有五贼，见之者昌。五贼在心，施行于天，宇宙在乎手，万化生乎身。&lt;br/&gt;&#xA;&amp;emsp;&amp;emsp;天性，人也；人心，机也。立天之道，以定人也。&lt;br/&gt;&#xA;&amp;emsp;&amp;emsp;天发杀机，移星易宿；地发杀机，龙蛇起路；人发杀机，天地反覆；天人合发，万化定基。&lt;br/&gt;&#xA;&amp;emsp;&amp;emsp;性有巧拙，可以伏藏。九窍之邪，在乎三要，可以动静。火生于木，祸发必克；奸生于国，时动必溃。知之修炼，谓之圣人。&lt;br/&gt;&#xA;&amp;emsp;&amp;emsp;天生天杀，道之理也。天地，万物之盗；万物，人之盗。三盗既宜，三才既安。故曰：食其时，百骸理；动其机，万化安。人知其神之神，不知不神之所以神也。日月有数，大小有定，圣功生焉，神明出焉。其盗机也，天下莫能见，莫能知。君子得之固躬，小人得之轻命。&lt;br/&gt;&#xA;&amp;emsp;&amp;emsp;瞽者善听，聋者善视。绝利一源，用师十倍；三反昼夜，用师万倍。心生于物，死于物，机在目。天之无恩而大恩生，雷厉风行，莫不蠢然。&lt;br/&gt;&#xA;&amp;emsp;&amp;emsp;至乐性馀，至静则廉。天之至私，用之至公。禽之制在炁。死者生之根，生者死之根。恩生于害，害生于恩。愚人以天地文理圣，我义时物文理哲。&lt;br/&gt;&#xA;&amp;emsp;&amp;emsp;人以愚虞圣，我以不愚虞圣。人以奇期圣，我以不奇期圣。故曰：沉水入火，自取灭亡。自然之道静，故天地万物生。天地之道浸，故阴阳胜。阴阳相推，而变化顺矣。&lt;br/&gt;&#xA;&amp;emsp;&amp;emsp;是故圣人知自然之道不可违，因而制之。至静之道，律历所不能契。爰有奇器，是生万象，八卦甲子，神机鬼藏。阴阳相胜之术，昭昭乎进乎象矣。&lt;/p&gt;</description>
    </item>
    <item>
      <title>内楗--鬼谷子第三篇</title>
      <link>http://pokerg.github.io/鬼谷子/%E5%86%85%E6%A5%97--%E9%AC%BC%E8%B0%B7%E5%AD%90%E7%AC%AC%E4%B8%89%E7%AF%87/</link>
      <pubDate>2013-11-23 12:00:00 +0800</pubDate>
      <description>&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;“内”即使让人采取自己的计策,&amp;ldquo;楗“就是设法坚持自己的计策，”内楗“连在一起，就是内心思想相合。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;人们之间可能距离很近，但是关系却很疏远，而距离很远，关系却可能很亲密，这是应为内心相知程度的不同所致。这都源于平时的结交。把握住对方的心理，就可以”若蚨母之从子也，出无间，入无朕“。所以说内楗术的核心就是把握对方的心理。内楗术是关于献策的方法，虽然文中大多数都是向君主，我们现在可能不存在这个问题，但是让人心悦诚服的接受我们的意见这点来说，内楗术还是非常有用的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;“欲说者务隐度，计事者务循顺”，想要游说的话，务必要先揣度对方的心理；准备献策的，务必因势利导，顺其自然。“事有不合者，圣人不为谋也”这点一定要切记。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;&amp;ldquo;得其情乃制其术“一定要在了解情况后再确定方法。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;最后讲的是进退之道，关键还是要“莫知所为”，才行。&lt;/p&gt;</description>
    </item>
    <item>
      <title>通道队列</title>
      <link>http://pokerg.github.io/Programming Language/%E9%80%9A%E9%81%93%E9%98%9F%E5%88%97/</link>
      <pubDate>2013-11-16 12:00:00 +0800</pubDate>
      <description>&#xA;    &lt;p&gt;&amp;emsp;&amp;emsp;这是《代码的未来》中的一个例子。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import &amp;quot;fmt&amp;quot;&#xA;&#xA;const ngoroutine = 10000&#xA;&#xA;func f(left, right chan int) {&#xA;    left &amp;lt;- 1 + &amp;lt;-right&#xA;}&#xA;func main() {&#xA;    leftmost := make(chan int)&#xA;    var left, right chan int = nil, leftmost&#xA;    for i := 0; i &amp;lt; ngoroutine; i++ {&#xA;        left, right = right, make(chan int)&#xA;        go f(left, right)&#xA;    }&#xA;    right &amp;lt;- 0&#xA;    fmt.Println(&amp;lt;-leftmost)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;说来惭愧，第一眼竟没有看出这个程序的逻辑所在。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;经过好长时间的仔细阅读才发现，这个其实是一个累加过程。因为前面的channel一直是堵塞的，当main()中把 0 传递给 最后一个 right时，f()中&lt;code&gt;left&amp;lt;-1+&amp;lt;-right&lt;/code&gt;将后一个channel中的值传给前一个，依次向前一个channel中传，最后传到leftmost中，所以最后输出的是 &lt;strong&gt;1000&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;这个程序有点像队列，也有点像堆栈，挺有意思的一段小代码，所以就记录下来了。&lt;/p&gt;</description>
    </item>
    <item>
      <title>表达式求值顺序</title>
      <link>http://pokerg.github.io/Programming Language/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E9%A1%BA%E5%BA%8F/</link>
      <pubDate>2013-11-15 12:00:00 +0800</pubDate>
      <description>&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;原文来自于&lt;a href=&#34;http://dave.cheney.net/2013/11/15/evaluation-order-oddity&#34;&gt;http://dave.cheney.net/&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;11&lt;/sub&gt;/15/evaluation-order-oddity&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;先来看这段代码&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import &amp;quot;fmt&amp;quot;&#xA;&#xA;type T struct {&#xA;        i int&#xA;}&#xA;&#xA;func (t *T) readInt() int {&#xA;        t.i += 4&#xA;        return 42&#xA;}&#xA;&#xA;func main() {&#xA;        var d = T{i: 200}&#xA;        end := d.i - 4 + d.readInt()&#xA;        fmt.Println(end)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;根据Go&lt;a href=&#34;http://golang.org/ref/spec#Order_of_evaluation&#34;&gt;spec&lt;/a&gt;我们可知表达式的求值过程是自左向右的。所以我们可以想想这段代码打印出来的应该是&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;200-4 + 42 = 238&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;但是238是正确答案么？&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;% go run odd.go &#xA;242&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;啊，太奇怪了，然后让我们来看看gccgo的结果&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;% go run -compiler gccgo odd.go &#xA;238&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;esmp;看来它得到了正确答案，那么是gc有问题了或者这个表达式的求值方式确实是相反的？&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;事实上这两个编译器都是正确的，因为这个表达式的求值顺序是不确定的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;如果想要得到你想要的答案，应该把这个表达式分成两行，消除加d.i时的二义性。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func main() {&#xA;        var d = T{i:200}&#xA;        v := int(d.readInt32())&#xA;        end := v + d.i - 4&#xA;        fmt.Println(end)    // prints         242&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>反应--鬼谷子第二篇</title>
      <link>http://pokerg.github.io/鬼谷子/%E5%8F%8D%E5%BA%94--%E9%AC%BC%E8%B0%B7%E5%AD%90%E7%AC%AC%E4%BA%8C%E7%AF%87/</link>
      <pubDate>2013-11-10 12:00:00 +0800</pubDate>
      <description>&#xA;    &lt;p&gt;&amp;emsp;&amp;emsp;&amp;ldquo;反应&amp;rdquo; 字典的解释是：事情所引起得意见，态度或行动。鬼谷子所论的反应与此略有不同。这里的反应是两种不同的对策。反，通”返“，反过来，反听之，反审之。这里的”反“更多的是指反复了解，反复观察。”应“对别人的态度所做的对策。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;开篇鬼谷子数次强调“反覆”的重要。许多事情往往需要反复探索才能把握。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;如何探索呢？一是抓住对方的话外音，“言有象，事有比”，正因为有形象和比喻，所以要观察隐藏在言辞下面的含义。二是诱导，就像捕猎一样，多张一些网，等待野兽出没，伺机捕获之。与人的对话也一样。“以象动之，以报其心，见其情，随而牧之”&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;第三段着重讲解了第二种方法。想要通过反听对方的言论，来获取信息。必须有一定方法。“变象比，必有反辞，以还听之”，我们要用相反的言论来激发对手。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;要使用这种方法的关键是使自己平静下来，不能乱了分寸，忘了自己的目的。虽然有时对方所谈不是我们急于知道的，但是“见微知类”。就像刺探敌情而深居敌境一般，要首先估计敌人的能力，其次摸清敌人的意图，“如腾蛇之所指”一样精准。“若羿之引失”百发百中。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;所以要想掌握情况，要从了解自己开始，然后才能了解别人（未看出前后逻辑在哪）。了解了别人才能像比目鱼一样亲近。就可以透过对方的外形探知内心。“未见形，圆以道之；既见形，方以事之”在情况不明朗的时候，用智慧诱惑对方，在情况明朗后，用谋略战胜对方。“己不先定，牧人不正”，自己不先定下策略，就无法正确领导别人。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;《反应》一篇的反应包括两方面一方面用自己的行为引发对方的反应，二是根据对方的反应作出对策。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;说实话，对于这篇没有看得太懂，尤其是最后一段的逻辑关系没太理清。古人的智慧果然需要我们细心揣摩啊。&lt;/p&gt;</description>
    </item>
    <item>
      <title>捭阖--鬼谷子开篇</title>
      <link>http://pokerg.github.io/鬼谷子/%E6%8D%AD%E9%98%96--%E9%AC%BC%E8%B0%B7%E5%AD%90%E5%BC%80%E7%AF%87/</link>
      <pubDate>2013-11-08 12:00:00 +0800</pubDate>
      <description>&#xA;    &lt;p&gt;&amp;emsp;&amp;emsp;《捭阖》作为《鬼谷子》的首篇，它的地位是无需多言的。它不仅是种纵横术，更是《鬼谷子》的提纲和思想的核心。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;开篇“观阴阳之开阖以命物，知存亡之门户”，便把捭阖提到至高无上的地位。捭，开也，阳也；阖，闭也，阴也。它与中国最古老的哲学易经是相符的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;&amp;ldquo;离合有守，先从其志&amp;rdquo;这句可以算是全文的一个核心。进行任何纵横术的根本点是要守住，即首先抓住对方的思想。这也是”存亡之门户“之所在。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;”即欲捭之，贵周；即欲阖之，贵密“这点出了进行捭阖的前提。周详考虑，藏而不露，巧妙运用，合乎道矣。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;&amp;ldquo;口者，心之门户也，心者，神之主也”。人的种种情感，思维谋略等等皆由此两者表现。“故关之以捭阖，制之以出入。”&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;关于捭阖，鬼谷子强调了几点：1.物分阴阳。阳即开始，阴即终结。用有利来开启谈话，用不利来制止其谋略。2.”与阳言者，依崇高。与阴言者，依卑小“，通俗来讲就是见人说人话，见鬼说鬼话。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;捭阖的关键在于隐藏自己的观点，诱出对方的观点，从而对症下药。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;《鬼谷子》这本书可以说思想极为深邃，《捭阖》这篇变化无穷，正如其所言。字字千钧，读完回味无穷。本人浅陋，只能理解到这里。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go简单的下载器实现</title>
      <link>http://pokerg.github.io/Programming Language/Go%E7%AE%80%E5%8D%95%E7%9A%84%E4%B8%8B%E8%BD%BD%E5%99%A8%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>2013-10-30 12:00:00 +0800</pubDate>
      <description>&#xA; &lt;p&gt;&amp;emsp;&amp;emsp;用Go来实现下载功能还是很简单的。直接看代码吧&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func download(url string){&#xA;    resp,err := http.Get(url)&#xA;    handleErr(err)&#xA;    defer resp.Body.Close()&#xA;    body,err := ioutil.ReadAll(resp.Body)&#xA;    handleErr(err)&#xA;    err := ioutil.WriteFile(&amp;quot;./test&amp;quot;,body,0666)&#xA;    handleErr(err)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;核心部分就如此简单，剩下的就自己发挥啦。 比如断点续传什么的。&lt;/p&gt;</description>
    </item>
    <item>
      <title>将json文件导入mongodb--goruntine</title>
      <link>http://pokerg.github.io/Programming Language/%E5%B0%86json%E6%96%87%E4%BB%B6%E5%AF%BC%E5%85%A5mongodb--goruntine/</link>
      <pubDate>2013-10-21 12:00:00 +0800</pubDate>
      <description>&#xA; &lt;p&gt;&amp;emsp;&amp;emsp;接着上次的，因为数据比较大，单线程的话，速度实在不能忍，所以就要使用goruntine。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;我们首先要看是哪里的速度过慢，从程序我们就可以看出主要是三个点：1.文件读取；2.正则表达式的处理；3.写入mongodb。所以就测试了一下，文件读取大约是几百毫秒，正则表达式的处理大约在2秒到4秒，而写入mongodb随文件的大小以及系统的情况，大约也是3到5秒，最慢能到10多秒。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;文件读取速度对整体影响不大，所以没必要再优化，而正则表达式使用的Go自带的引擎，所以，只有第三项可以做些什么，而且也就是它耗时最多。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp; 因为我们是要处理一系列文件，所以这里就有了两种思路，第一种是每个文件的处理用一个goruntine，第二种是在写入mongodb时，每条记录使用一个goruntine。（当然更好是设计两层模型,还没有尝试，就不说了。）。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;首先，我们来看看第二种，&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;chs = make([]chan int, len(sdata))&#xA;&#xA;for i, s := range chs {&#xA;    chs[i] = make(chan int)&#xA;    go func(s string, i int) {&#xA;        var inter interface{}&#xA;            err := json.Unmarshal([]byte(s), &amp;amp;inter)&#xA;            handleError(err)&#xA;            err = c.Insert(inter)&#xA;            handleError(err)&#xA;        chs[i] &amp;lt;- 1&#xA;    }(s, i)&#xA;}&#xA;for i, ch := range chs {&#xA;    &amp;lt;-ch&#xA;    fmt.Print(i, &amp;quot;,&amp;quot;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;这种方式，对于小一些的文件挺管用，但是当数据达到9000以上的时候，就会出现问题。我刚开始以为是以因为goruntine过多造成死锁了。所以我在for循环中加了一句&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;if i % 5000 == 0 ｛&#xA;    time.Sleep(time.Second)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;又进行了测试，刚开始进行的挺好，但是处理一段时间后，使用 top 检测已经不占用cpu，但是程序却仍然卡在那里。然后我改成一个goruntine处理数条数据，   &lt;code&gt;chs = make([]chan int, len(sdata)/1000+1)&lt;/code&gt;  仍然存在相同的问题。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;然后我觉得就算这个文件不执行了，把其他先处理了吧。。然后就加入了超时机制（利用的就是我上次说道的channel的close特性）。测试后我才发现问题所在，超时后是从等待中跳出了。但是它竟然卡在了函数的结尾(后面无论加多少东西都能执行，但是它返回不到调用它的函数！！），然后我就崩溃了。我想着问题可能是mgo这个驱动的问题或者是Go本身垃圾回收机制的问题。暂时解决不了，所以先放下了（这里先mark下，我觉得这种思路没有问题，等过几天闲了再想办法）&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;我就去尝试了另一种思路，刚开始没考虑太多，直接每个文件一个goruntine就这么写了。然后在本地测试了大约18个文件，速度一下子从2分6秒降到了26秒。然后我就放到服务器上去测试，问题就来了。由于文件太多（测试用的已经700，而且平均几十M),几秒之内内存就被占满，直接被内核kill掉了。。（囧）没办法，只能想办法分批处理了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;首先，我用的是&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;if runtime.NumGoroutine() &amp;gt; XX {&#xA;    time.Sleep()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;这种方法会出现错误，我想NumGoroutine是总的协程数，mgo也大量使用了并发，所以我就使用了一个变量，来记录我申请的数量，使用原子操作&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;atomic.AddInt32(&amp;amp;currentNum, 1)&#xA;&#xA;for atomic.LoadInt32(&amp;amp;currentNum) &amp;gt; 1 {&#xA;    time.Sleep(time.Second * 30)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;但是还是出现了问题。最后我想到了一种方法。只开辟一个具体数量的channel 切片 &lt;code&gt;chs = make([]chan int, CHANNUM)&lt;/code&gt;，然后同步所有的goruntine，然后再次分配。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;if cnum == CHANNUM {&#xA;    for _, ch := range chs {&#xA;        &amp;lt;-ch&#xA;    }&#xA;    cnum = 0&#xA;}&#xA;chs[cnum] = make(chan int)&#xA;go UZip(filepath.Join(dirAbs, fileInfo.Name()), chs[cnum])          &#xA;cnum += 1&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;但是还要注意一点，因为文件数量不一定是倍数关系，所以还要加以处理在调用Uzip()的后面加上&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;if i == len(fileInfos)-1 {&#xA;    for i := 0; i &amp;lt;= cnum; i++ {&#xA;        &amp;lt;-chs[i]&#xA;    }&#xA;    for _, ch := range chs {&#xA;        close(ch)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;我把CHANNUM设为48，经过测试，仅用19分钟就处理完成，将近原来的五分之一。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;从这里就可以看出goruntine的强大，但是如果对原理理解的不透彻的话，使用中还是会有很多问题。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;我用go实现并发已经如此麻烦（当然跟我水平有关系），其他语言我已是无法想像。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;再说一个要注意的地方。使用channel必须用make为其分配空间。而且就算channel slice已经分配，你还需要为每个单独分配。否则无法正常工作。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;chs := make([]chan int,10)&#xA;for i,_ := range chs{&#xA;    chs[i] = make([]chan int)&#xA;    ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;这两个版本的程序源码都在&lt;a href=&#34;https://githubc.com/pokerG/GitArchiveUtils&#34;&gt;https://githubc.com/pokerG/GitArchiveUtils&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>将json文件导入mongodb--Golang实现</title>
      <link>http://pokerg.github.io/Programming Language/%E5%B0%86json%E6%96%87%E4%BB%B6%E5%AF%BC%E5%85%A5mongodb--Golang%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>2013-10-20 12:00:00 +0800</pubDate>
      <description>&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;使用go语言将json文件导入mongodb中相对还是比较方便的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;首先 我用的是 mgo 这个 驱动。 其次因为文件是gz压缩 的。所以我们得先解压。使用 go自带的pkg &lt;code&gt;compress/gzip&lt;/code&gt; 就行。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;fr, err := os.Open(fpath)&#xA;handleError(err)&#xA;defer fr.Close()&#xA;&#xA;fmt.Println(fr.Name())&#xA;&#xA;gr, err := gzip.NewReader(fr)&#xA;handleError(err)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;正常来说，这里直接 调用 &lt;code&gt;gr.Read()&lt;/code&gt;就可以了。。但是由于我的文件比较大，而且 &lt;code&gt;ioutil.ReadAll()&lt;/code&gt; 也不行 ，所以这里我使用了循环读入&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// 因为 gr一次读入 读满的话是3800 - 4000个字符，&#xA;// 所以BUFSIZE = 4000&#xA;buf := make([]byte, BUFSIZE)&#xA;var data []byte&#xA;var num int = 0&#xA;for {&#xA;    n, err := gr.Read(buf)&#xA;    data = append(data, buf[:n]...)&#xA;    if err == io.EOF {&#xA;        break&#xA;    }&#xA;    num += n&#xA;    handleError(err)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp; 如果只有 一个 类似&lt;code&gt;｛&amp;quot;id&amp;quot;:12434,&amp;quot;name&amp;quot;:foo}&lt;/code&gt; 这样的数据话 直接&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;var inter interface{}&#xA;err = json.Unmarshal([]byte(s), &amp;amp;inter)&#xA;handleError(err)&#xA;c := session.DB(&amp;quot;test&amp;quot;).C(&amp;quot;user&amp;quot;)&#xA;err = c.Insert(inter)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;注意不能直接将数据写入DB，没有经过解码的话，存进去的将是ASCII码值&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;但是 如果是&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;｛&amp;quot;id&amp;quot;:12434,&amp;quot;name&amp;quot;:&amp;quot;foo&amp;quot;}&#xA;｛&amp;quot;id&amp;quot;:12435,&amp;quot;name&amp;quot;:&amp;quot;foo1&amp;quot;}&#xA;｛&amp;quot;id&amp;quot;:12436,&amp;quot;name&amp;quot;:&amp;quot;foo2&amp;quot;}  &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;使用 &lt;code&gt;json.Unmarshal()&lt;/code&gt; 会发生错误，对于这种情况，我暂时还没想到其他办法，所以就使用了正则表达式，将其分割成[]string,然后再处理&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;reg, err := regexp.Compile(`[{].*[}][\n]`)&#xA;handleError(err)&#xA;&#xA;sdata := reg.FindAllString(string(data), -1)&#xA;fmt.Println(len(sdata))&#xA;&#xA;for _, s := range sdata {&#xA;    var inter interface{}&#xA;&#xA;    err = json.Unmarshal([]byte(s), &amp;amp;inter)&#xA;    handleError(err)&#xA;    c := session.DB(&amp;quot;testGoBig&amp;quot;).C(&amp;quot;Event&amp;quot;)&#xA;    err = c.Insert(inter)&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;这样就成功的将json文件导入了mongodb中。因为测试的数据比较大，（大约 2G) 所以 串行的话 大约要1个半小时，所以我又用了goruntine，下次说说其中遇到的坑和经验。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go1.2 Release</title>
      <link>http://pokerg.github.io/Programming Language/Go1.2-Release/</link>
      <pubDate>2013-09-22 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&amp;emsp;&amp;emsp;Go1.2发布了，做了一些调整和改进，这里我就只谈谈几个跟我目前关系比较大的，其他的请去查看[release notes](&amp;ldquo;http://tip.golang.org/doc/go1.2&amp;rdquo;)&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;nil 的使用&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;在Go1.0中 例如：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type T struct {&#xA;    X [1&amp;lt;&amp;lt;24]byte&#xA;    Field int32&#xA;}&#xA;&#xA;func main() {&#xA;    var x *T&#xA;    ...&#xA;} &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;这个nil 指针 x 可以访问非法内存， x.Field 可以访问 1&amp;lt;&amp;lt;24的内存.在Go1.2中 编译器会确保不会错误的使用nil 指针。&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;切片有三个index&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;在Go1.2中 使用切片操作一个存在的数组或切片时可以指定容量（capacity）。必须小于原数组或切片的容量。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;var array [10]int&#xA;slice = array[2:4:6]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;第三个index是用来指定容量的。当操作 这个 slice时 ，不能访问 原 array 中 的后两个元素&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;Test coverage&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;关于 go test -cover  目前还不是很清楚，所以先空下了， 可以通过 &lt;code&gt;go help testflag&lt;/code&gt;&#xA;或 &lt;code&gt;go tool cover -help&lt;/code&gt;  来查看具体用法和作用&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;go doc 被删掉&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;现在没有 &amp;ldquo;go doc&amp;rdquo; 这个命令了， 只有 &amp;ldquo;godoc&amp;rdquo;&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;go get -t&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;-t 参数 可以下载package的依赖项的测试程序&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>文明的翅膀</title>
      <link>http://pokerg.github.io/History/%E6%96%87%E6%98%8E%E7%9A%84%E7%BF%85%E8%86%80/</link>
      <pubDate>2013-09-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&amp;emsp;&amp;emsp;历史的进程是残酷的。上了“文明毁灭黑名单”的有古埃及，巴比伦，哈拉巴，克里特，奥尔梅克，赫梯，波斯，玛雅等等，不下二三十中。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;绵延不绝的是中华文明起死回生的则是希腊-罗马文明。何以如此？这是一个“斯芬克斯之谜”。易中天在《易中天中华史-奠基人》中揭示了这个谜底。这篇文章虽然观点并不是很新颖，但是从角度上来说，让我读起来感觉很有趣。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;斯芬克斯，是希腊人对狮身人面像的称呼。不过在希腊的斯芬克斯却又两只翅膀。这就比古埃及的那个家伙，显得轻盈娟修。翅膀，是重要的。没有翅膀就不能飞。文明没有翅膀，就只能原地踏步，最终只得陨落。但是怎样飞翔，却要看是什么样的翅膀。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;中华的翅膀，是忧患心理和乐观态度。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;忧患是我们民族文化的底色。从《诗·小雅·小旻》“战战兢兢，如临深渊，如履薄冰“，到孟子的“生于忧患，死于安乐”，再到《义勇军进行曲》，忧患意识贯穿来整个中华史。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;但是我们民族优势乐观的。我们相信“天遂人愿”，相信“善恶有报”，相信“事在人为”。因此，我们“不改其乐”，哪怕“自得其乐”,也总归”乐在其中“。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;一忧一乐，从制度上来说就是有礼有乐。礼就是“理”，伦理，秩序，体现忧患；乐（le）就是“乐”（yue），讲快乐，讲和谐，造就乐观。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;希腊的翅膀，是科学精神和艺术气质。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;希腊人的科学不是实用主义的。他们“为思想而思想，为科学而科学”。所以他们能把埃及人用于测量土地和修建金字塔的技术，变成几何学；也能把巴比伦的占星术，变成天文学。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;与此同时，希腊人又极具艺术气质。正如马克思所说，希腊人是”正常的儿童“，所以”为艺术而艺术，为审美而审美“。这种纯粹，使他们即使在纵欲和淫乐，也毫无负罪感。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;科学与艺术，在希腊人那里是对立的，也是统一的。统一于单纯，统一于天然，统一于率真。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;希腊精神是互补的。同样中华精神也是互补结构。对立统一，相辅相成，共同塑造着一个伟大的民族。&#xA;这也许就是秘密所在&amp;ndash;那些毁灭的文明，很可能都只有一只翅膀。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>jekyllTogor</title>
      <link>http://pokerg.github.io/Programming Language/jekyllTogor/</link>
      <pubDate>2013-09-03 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&amp;emsp;&amp;emsp;前几天在Github上看到gor——Go编写的静态博客引擎,顿时有了不小的兴趣，就试了一下&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;先说说我的感受吧（帮gor做做广告了），首先它的安装真的很简单，作为静态语言，只需要编译成可执行文件就可使用，go的工具链很方便的就能实现，（具体安装方法可以参考它的&lt;a href=&#34;https://github.com/wendal/gor&#34;&gt;主页&lt;/a&gt;.如果你想全局使用的话，将它路径加到$PATH里就行了，这个就不用多说了。当时装jekyll时真是崩溃死了，没学过ruby，先得装ruby，刚开始装的是2.0,然后装jekyll，反正也看不懂，就跟着别人的来，一直出问题，最后用尽各种方法都不行，花了有两个多小时吧，最后灵光一闪，是不是ruby的版本有问题。。然后换成了1.9.3.最后终于成功了。。！！真是崩溃的要死。gor的第二个优点就是速度快，系统级语言确实是不能比的，而且它和jekyll的工作原理不同。这两点我认为是的对新手来说很重要的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;当然上述其实不是本文的重点（汗。。）。gor 的 元数据 和 jekyll的有点区别。我的Blog虽然不多。但要是一个个手动改的话，也是很麻烦的。作为coder，目的是实现自动化，这种事当然不能这么干，同时也是为了练习Golang，所以就写了个&lt;a href=&#34;https://github.com/pokerG/jekyllTogor&#34;&gt;脚本&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;通过写这个脚本，发现了一些问题和情况。好久没有写程序了，手速下降的不行行了。。关键是对Go的不熟练，这个脚本其实是很简单的，但是我写了3个小时把。理论掌握的多，实践少。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;接下来为了改善这种情况，一方面是接着分析Go的标准库，看看Go的创始者的code是怎么写的,这是提高能力的一个关键方法。还有就是练习练习再练习。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;接下来主要先分析这几部分：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;string&lt;/li&gt;&#xA;&lt;li&gt;file&lt;/li&gt;&#xA;&lt;li&gt;regexp&lt;/li&gt;&#xA;&lt;li&gt;refelect&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;</description>
    </item>
    <item>
      <title>Go标准库-bufio</title>
      <link>http://pokerg.github.io/Programming Language/Go%E6%A0%87%E5%87%86%E5%BA%93-bufio/</link>
      <pubDate>2013-08-28 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&amp;emsp;&amp;emsp;bufio包实现了带缓存的I/O操作。封装了一个io.Reader或io.Writer对象，返回一个具有缓存和文本读写的对象。&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;bufio.go&lt;/h1&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;//实现了带缓存的&#xA;type Reader struct{&#xA;        buf          []byte&#xA;        rd           io.Reader&#xA;        r, w         int&#xA;        err          error&#xA;        lastByte     int&#xA;        lastRuneSize int&#xA;}&#xA;&#xA;//NewReaderSize将rd封装成一个具有size大小的bufio.Reader对象&#xA;//如果rd的类型就是bufio.Reader且size &amp;gt; minReadBufferSize = 16 直接返回&#xA;//size的大小要大于 minReadBufferSize 否则 返回大小为minReadBufferSize的bufio.Reader&#xA;func NewReaderSize(rd io.Reader, size int) *Reader&#xA;&#xA;//NewReader 返回 大小为defaultBufSize = 4096的Reader&#xA;func NewReader(rd io.Reader) *Reader&#xA;&#xA;//Peek返回&#xA;func (b *Reader) Peek(n int) ([]byte, error)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Go标准库-io-pipe</title>
      <link>http://pokerg.github.io/Programming Language/Go%E6%A0%87%E5%87%86%E5%BA%93-io-pipe/</link>
      <pubDate>2013-08-28 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&amp;emsp;&amp;emsp;pipe中基本的struct是 pipe&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;//pipe 是 PipeReader 和 PipeWriter 的底层实现&#xA;type pipe struct {&#xA;    //sync.Mutex 是 一个并发时用的锁，这个以后在sync包中会讲到&#xA;    //rl/wl 控制同时只有一个读取器或写入器&#xA;    rl    sync.Mutex &#xA;    wl    sync.Mutex &#xA;    l     sync.Mutex //用于保护其他字段&#xA;    data  []byte     //管道中的数据&#xA;    // r/wwait 控制读取器或写入器等待  &#xA;    rwait sync.Cond  &#xA;    wwait sync.Cond  &#xA;    // r/werr 如果读取器（写入器）关闭，该错误会被Write（Read）方法返回&#xA;    rerr  error      &#xA;    werr  error     &#xA;}&#xA;&#xA;//ErrClosePipe 用于返回对于关闭的管道的操作错误&#xA;var ErrClosedPipe = errors.New(&amp;quot;io: read/write on closed pipe&amp;quot;)&#xA;&#xA;func (p *pipe) read(b []byte) (n int, err error) {&#xA;// One reader at a time.（控制一次只能一个读取器）&#xA;    p.rl.Lock()&#xA;    defer p.rl.Unlock()&#xA;&#xA;    // 保护其他字段的读写&#xA;    p.l.Lock()&#xA;    defer p.l.Unlock()&#xA;    for {&#xA;        // Reader端关闭后，再Read，则返回ErrClosedPipe&#xA;        if p.rerr != nil {&#xA;            return 0, ErrClosedPipe&#xA;        }&#xA;        // 管道中有数据，退出循环&#xA;        if p.data != nil {&#xA;            break&#xA;        }&#xA;        // Writer端关闭，返回p.werr&#xA;        if p.werr != nil {&#xA;            return 0, p.werr&#xA;        }&#xA;        // 没有数据或管道没有关闭，读取端等待&#xA;        p.rwait.Wait()&#xA;    }&#xA;    // 管道中有数据，将其copy一份到b中&#xA;    n = copy(b, p.data)&#xA;    p.data = p.data[n:]&#xA;    // 如果管道数据被读光，需要唤醒在等待的Writer&#xA;    if len(p.data) == 0 {&#xA;        p.data = nil&#xA;        p.wwait.Signal()&#xA;    }&#xA;    return&#xA;}&#xA;&#xA;func (p *pipe) write(b []byte) (n int, err error) {&#xA;// pipe uses nil to mean not available&#xA;    if b == nil {&#xA;        // zero的定义为：var zero [0]byte&#xA;        b = zero[:]&#xA;    }&#xA;&#xA;    // One writer at a time.&#xA;    p.wl.Lock()&#xA;    defer p.wl.Unlock()&#xA;&#xA;    p.l.Lock()&#xA;    defer p.l.Unlock()&#xA;&#xA;    p.data = b&#xA;    // 唤醒在等待的Reader&#xA;    p.rwait.Signal()&#xA;    for {&#xA;        // 数据被读走，退出循环&#xA;        if p.data == nil {&#xA;            break&#xA;        }&#xA;        // Reader端关闭，设置err = p.rerr，退出循环&#xA;        if p.rerr != nil {&#xA;            err = p.rerr&#xA;            break&#xA;        }&#xA;        // Writer端关闭后，再Writer，设置err =   、ErrClosedPipe&#xA;        if p.werr != nil {&#xA;            err = ErrClosedPipe&#xA;        }&#xA;        // 数据没被读走（全部）或管道读取端没关闭，则等待&#xA;        p.wwait.Wait()&#xA;    }&#xA;    // 计算写入的字节数&#xA;    n = len(b) - len(p.data)&#xA;    p.data = nil // in case of rerr or werr&#xA;    return&#xA;}&#xA;&#xA;//关闭读取器&#xA;func (p *pipe) rclose(err error) {&#xA;    if err == nil {&#xA;        err = ErrClosedPipe&#xA;    }&#xA;    p.l.Lock()&#xA;    defer p.l.Unlock()&#xA;    p.rerr = err&#xA;    p.rwait.Signal()&#xA;    p.wwait.Signal()&#xA;}&#xA;&#xA;//关闭写入端&#xA;func (p *pipe) wclose(err error) {&#xA;    if err == nil {&#xA;        err = EOF&#xA;    }&#xA;    p.l.Lock()&#xA;    defer p.l.Unlock()&#xA;    p.werr = err&#xA;    p.rwait.Signal()&#xA;    p.wwait.Signal()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;pipe中对外的两个结构是PipeReader 和 PipeWriter。&lt;br/&gt;&#xA;&amp;emsp;&amp;emsp;PipeReader 实现了io.Reader 和 io.Closer&lt;br/&gt;&#xA;&amp;emsp;&amp;emsp;PipeWriter 实现了io.Wrter 和 io.Closer&lt;br/&gt;&#xA;&amp;emsp;&amp;emsp;这两个结构的Read/Write 事实上是调用了pipe的实现。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;关于 Read 方法的说明：从管道中读取数据。该方法会堵塞，直到管道写入端开始写入数据或写入端关闭了。如果写入端关闭时带上了error（即调用CloseWithError关闭），该方法返回的err就是写入端传递的error；否则err为EOF。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;关于 Write 方法的说明：写数据到管道中。该方法会堵塞，直到管道读取端读完所有数据或读取端关闭了。如果读取端关闭时带上了error（即调用CloseWithError关闭），该方法返回的err就是读取端&#xA;传递的error；否则err为 ErrClosedPipe。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;//返回一组对应的管道输入输出&#xA;func Pipe() (*PipeReader, *PipeWriter) {&#xA;    p := new(pipe)&#xA;    p.rwait.L = &amp;amp;p.l&#xA;    p.wwait.L = &amp;amp;p.l&#xA;    r := &amp;amp;PipeReader{p}&#xA;    w := &amp;amp;PipeWriter{p}&#xA;    return r, w&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;pipe 用于在并发时实现输入输出操作，没有内部缓存，所以在并发调用时是安全的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;[返回顶部]()&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Go标准库-io-multi</title>
      <link>http://pokerg.github.io/Programming Language/Go%E6%A0%87%E5%87%86%E5%BA%93-io-multi/</link>
      <pubDate>2013-08-28 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;//接受多个Reader/Writer &#xA;//返回一个Reader/Writer&#xA;//操作这个Reader/Writer 就相当于操作多个Reader/Writer&#xA;func MultiReader(readers ...Reader) Reader {&#xA;    return &amp;amp;multiReader{readers}&#xA;}&#xA;&#xA;func MultiWriter(writers ...Writer) Writer {&#xA;    return &amp;amp;multiWriter{writers}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;multi中定义了两个内部struct，multiReader 和 multiWriter 分别实现了 io.Reader 和 io.Writer&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type multiReader struct {&#xA;    readers []Reader&#xA;}&#xA;type multiWriter struct {&#xA;    writers []Writer&#xA;}&#xA;&#xA;func (mr *multiReader) Read(p []byte) (n int, err error) {&#xA;    for len(mr.readers) &amp;gt; 0 {&#xA;        n, err = mr.readers[0].Read(p)&#xA;        if n &amp;gt; 0 || err != EOF {&#xA;            if err == EOF {&#xA;                // Don&#39;t return EOF yet. There may be more bytes&#xA;                // in the remaining readers.&#xA;                err = nil&#xA;            }&#xA;            return&#xA;        }&#xA;        mr.readers = mr.readers[1:]&#xA;    }&#xA;    return 0, EOF&#xA;}&#xA;&#xA;func (t *multiWriter) Write(p []byte) (n int, err error) {&#xA;    for _, w := range t.writers {&#xA;        n, err = w.Write(p)&#xA;        if err != nil {&#xA;            return&#xA;        }&#xA;        if n != len(p) {&#xA;            err = ErrShortWrite&#xA;            return&#xA;        }&#xA;    }&#xA;    return len(p), nil&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;我们举两个例子，来谈谈应用。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;MultiReader:&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;readers := []io.Reader{&#xA;    strings.NewReader(&amp;quot;from strings reader&amp;quot;),&#xA;    bytes.NewBufferString(&amp;quot;from bytes buffer&amp;quot;),&#xA;}&#xA;reader := io.MultiReader(readers...)&#xA;data := make([]byte, 0, 1024)&#xA;var (&#xA;    err error&#xA;    n   int&#xA;)&#xA;for err != io.EOF {&#xA;    tmp := make([]byte, 512)&#xA;    n, err = reader.Read(tmp)&#xA;    if err == nil {&#xA;        data = append(data, tmp[:n]...)&#xA;    } else {&#xA;        if err != io.EOF {&#xA;            panic(err)&#xA;        }&#xA;    }&#xA;}&#xA;fmt.Printf(&amp;quot;%s\n&amp;quot;, data)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;输出&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;from strings readerfrom bytes buffer&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;MultiReader只是逻辑上将多个Reader组合起来，并不能通过调用一次Read方法获取所有Reader的内容。在所有的Reader内容都被读完后，Reader会返回EOF。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;MultiWriter：&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;file, err := os.Create(&amp;quot;tmp.txt&amp;quot;)&#xA;if err != nil {&#xA;    panic(err)&#xA;}&#xA;defer file.Close()&#xA;writers := []io.Writer{&#xA;    file,&#xA;    os.Stdout,&#xA;}&#xA;writer := io.MultiWriter(writers...)&#xA;writer.Write([]byte(&amp;quot;MultiWriter test&amp;quot;))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;这段程序执行后在生成tmp.txt文件，同时在文件和屏幕中都输出：MultiWriter test 这和Unix中的tee命令类似。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Go标准库-io-ioutil</title>
      <link>http://pokerg.github.io/Programming Language/Go%E6%A0%87%E5%87%86%E5%BA%93-io-ioutil/</link>
      <pubDate>2013-08-28 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&amp;emsp;&amp;emsp;ioutil封装了一些常用的io操作&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;//读取r中所有数据&#xA;//返回 读取的数据 和 error&#xA;//读取成功的话 返回nil 而不是 EOF&#xA;//ReadAll 实际上是通过bytes.Buffer的ReadFrom()实现的&#xA;func ReadAll(r io.Reader) ([]byte, error)&#xA;&#xA;//读取文件中的所有数据&#xA;//返回 读取的数据 和 error&#xA;//读取成功的话 返回nil 而不是 EOF&#xA;//ReadFile 和 ReadAll 都是通过readAll()实现的&#xA;//ReadFile会先判断文件的大小，给bytes.Buffer一个预定义容量，避免额外分配内存。&#xA;func ReadFile(filename string) ([]byte, error)&#xA;&#xA;//将 data 写入 文件&#xA;//如果文件不存在，将以perm权限创建文件&#xA;func WriteFile(filename string, data []byte, perm os.FileMode) error&#xA;&#xA;//定义了一系列文件信息的操作&#xA;type byName []os.FileInfo&#xA;&#xA;func (f byName) Len() int           { return len(f) }&#xA;func (f byName) Less(i, j int) bool { return f[i].Name() &amp;lt; f[j].Name() }&#xA;func (f byName) Swap(i, j int)      { f[i], f[j] = f[j], f[i] }&#xA;&#xA;//读取文件夹中的文件&#xA;//返回 文件信息的序列 和 error&#xA;func ReadDir(dirname string) ([]os.FileInfo, error)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;这里有个实现类似于tree命令的程序&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func main() {&#xA;    if len(os.Args) &amp;gt; 1 {&#xA;        Tree(os.Args[1], 1, map[int]bool{1:true})&#xA;    }&#xA;}&#xA;&#xA;// 列出dirname目录中的目录树，实现类似Unix中的tree命令&#xA;// curHier 当前层级（dirname为第一层）&#xA;// hierMap 当前层级的上几层是否需要&#39;|&#39;的映射&#xA;func Tree(dirname string, curHier int, hierMap map[int]bool) error {&#xA;    dirAbs, err := filepath.Abs(dirname)&#xA;    if err != nil {&#xA;        return err&#xA;    }&#xA;    fileInfos, err := ioutil.ReadDir(dirAbs)&#xA;    if err != nil {&#xA;        return err&#xA;    }&#xA;&#xA;    fileNum := len(fileInfos)&#xA;    for i, fileInfo := range fileInfos {&#xA;        for j := 1; j &amp;lt; curHier; j++ {&#xA;            if hierMap[j] {&#xA;                fmt.Print(&amp;quot;|&amp;quot;)&#xA;            } else {&#xA;                fmt.Print(&amp;quot; &amp;quot;)&#xA;            }&#xA;            fmt.Print(strings.Repeat(&amp;quot; &amp;quot;, 3))&#xA;        }&#xA;&#xA;        // map是引用类型，所以新建一个map&#xA;        tmpMap := map[int]bool{}&#xA;        for k, v := range hierMap {&#xA;            tmpMap[k] = v&#xA;        }&#xA;        if i+1 == fileNum {&#xA;            fmt.Print(&amp;quot;`&amp;quot;)&#xA;            delete(tmpMap, curHier)&#xA;        } else {&#xA;            fmt.Print(&amp;quot;|&amp;quot;)&#xA;            tmpMap[curHier] = true&#xA;        }&#xA;        fmt.Print(&amp;quot;-- &amp;quot;)&#xA;        fmt.Println(fileInfo.Name())&#xA;        if fileInfo.IsDir() {&#xA;            Tree(filepath.Join(dirAbs, fileInfo.Name()), curHier+1, tmpMap)&#xA;        }&#xA;    }&#xA;    return nil&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;//将 io.Reader 封装成 io.ReadCloser&#xA;// 其 Close 方法不做任何事情&#xA;func NopCloser(r io.Reader) io.ReadCloser&#xA;&#xA;//Discard 对应的类型 type devNull int 实现了io.Writer&#xA;//从名字我们就可以看出 Discard    的 任何Write()都会成功但是不干任何事情&#xA;//同时为了优化io.Copy到Discard，避免不必要的工作，实现了io.ReaderFrom接口。&#xA;//ReadFrom的实现是读取内容到一个buf中，最大也就8192字节，其他的会丢弃（当然，这个也不会读取）&#xA;//Discard 用于并发&#xA;var Discard io.Writer = devNull(0)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp; tempfile.go中的函数&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// TempFile 在目录 dir 中创建一个临时文件并将其打开&#xA;// 文件名以 prefix 为前缀&#xA;// 返回创建的文件的对象和创建过程中遇到的任何错误&#xA;// 如果 dir 为空，则在系统的临时目录中创建临时文件&#xA;// 如果环境变量中没有设置系统临时目录，则在 /tmp 中创建临时文件&#xA;// 调用者可以通过 f.Name() 方法获取临时文件的完整路径&#xA;// 调用 TempFile 所创建的临时文件，应该由调用者自己移除&#xA;func TempFile(dir, prefix string) (f *os.File, err error)&#xA;&#xA;// TempDir 功能同 TempFile，只不过创建的是目录&#xA;// 返回值也只返目录的完整路径&#xA;func TempDir(dir, prefix string) (name string, err error)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Go标准库-io-io</title>
      <link>http://pokerg.github.io/Programming Language/Go%E6%A0%87%E5%87%86%E5%BA%93-io-io/</link>
      <pubDate>2013-08-27 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&amp;emsp;&amp;emsp;io包为I/O原语提供了基本的接口。它主要包装了这些原语的已有实现。由于这些接口和原语以不同的实现包装了低级操作，因此除非另行通知，否则客户端不应假定它们对于并行执行是安全的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;首先我们来看几个variables，这几个variables都是读写操作中可能出现的情况&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;//ErrShortWrite 用于一个write少于规定的字符数，但是又不能返回一个明确的错误时&#xA;var ErrShortWrite = errors.New(&amp;quot;short write&amp;quot;)&#xA;&#xA;//ErrShortBuffer 用于一个read要求的字符数多于所能提供的字符&#xA;var ErrShortBuffer = errors.New(&amp;quot;short buffer&amp;quot;)&#xA;&#xA;//EOF 就是end-of-file 不用多解释，但是如果EOF发生在一个结构数据流中，error就不应该是EOF&#xA;var EOF = errors.New(&amp;quot;EOF&amp;quot;)&#xA;&#xA;//ErrUnexpectedEOF 意味着EOF发生在读取一个固定数据块或者数据结构的中间&#xA;var ErrUnexpectedEOF = errors.New(&amp;quot;unexpected EOF&amp;quot;)&#xA;&#xA;//ErrNoProgress 发生在多个io.Reader调用Read()方法，却没有返回任何数据或错误时&#xA;//通常作为一个破损的io.Reader实现的标志&#xA;var ErrNoProgress = errors.New(&amp;quot;multiple Read calls return no data or error&amp;quot;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;io包中最基本的4个接口&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;//Reader 封装了基本的read方法&#xA;//Read()方法读取len(p)个字符放入p中，返回读取的字符数（0&amp;lt;=n&amp;lt;=len(p)) 和 错误。&#xA;//即使 Read 返回的 n &amp;lt; len(p)，它也会在调用过程中使用 p 的全部作为暂存空间。&#xA;//若一些数据可用但不到 len(p) 个字节，Read 会照例返回可用的数据，而不是等待更多数据。&#xA;//当 Read 在成功读取 n &amp;gt; 0 个字节后遇到一个错误或EOF（end-of-file），它就会返回读取的字节数。&#xA;//所以当Read方法返回错误时，不代表没有读取到任何数据。调用者应该处理返回的任何数据，之后才处理可能的错误。&#xA;//&amp;quot;p被装满&amp;quot; err返回nil&#xA;//&amp;quot;数据被读完&amp;quot;, err返回EOF&#xA;//&amp;quot;读取出错&amp;quot;, err返回相应的错误信息&#xA;//以上就是实现io.Reader接口应注意的&#xA;type Reader interface {&#xA;    Read(p []byte) (n int, err error)&#xA;}&#xA;&#xA;//Writer 封装了基本的write方法&#xA;//Write()方法 将p中数据写入相应对象的数据流，返回从p中写入的字符数和错误。&#xA;//当n = len(p)时，返回nil&#xA;//当 n &amp;lt; len(p)时，返回相应的错误信息&#xA;type Writer interface {&#xA;    Write(p []byte) (n int, err error)&#xA;}&#xA;&#xA;//Closer 封装了基本的Close方法&#xA;//Close()用于关闭数据流，文件，数据库，Socket等等&#xA;//经常将Close()的调用放在defer语句&#xA;type Closer interface {&#xA;    Close() error&#xA;}&#xA;&#xA;//Seeker 封装了基本的Seek方法&#xA;//Seek() 设置下一次的读写头，即偏移地址offset&#xA;//offset的解释依据于 whence&#xA;// whence = 0 与文件起始的偏移&#xA;// whence = 1 与当前读写头的偏移&#xA;// whence = 2 与文件尾部的偏移&#xA;type Seeker interface {&#xA;    Seek(offset int64, whence int) (ret int64, err error)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;其他接口都是这四个基本接口的组合，从名字我们就可以判断出来。&#xA;&lt;strong&gt;ReadWriter,ReadCloser,WriteCloser,ReadWriteCloser,ReadSeeker,WriteSeeker,ReadWriteSeeker&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;这里还有一些较为高级一点的输入输出接口&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;//ReaderFrom 封装了ReadFrom方法&#xA;//ReadFrom() 从 r 中读取数据，直到EOF或 error&#xA;//返回 读取的字符数 和 error&#xA;//Copy() 如果相应的参数实现了ReaderFrom接口，会调用ReadFrom()&#xA;type ReaderFrom interface {&#xA;    ReadFrom(r Reader) (n int64, err error)&#xA;}&#xA;&#xA;//WriterTo 封装了WriterTo方法&#xA;//WriteTo()将对象的数据流写入w 直到全部写入或者遇到error&#xA;//返回 写入的字符数 和 error&#xA;//Copy() 如果相应的参数实现了WriterTo接口，会调用WriteTo()&#xA;type WriterTo interface {&#xA;    WriteTo(w Writer) (n int64, err error)&#xA;}&#xA;&#xA;//ReaderAt 封装了ReadAt方法&#xA;//ReadAt() 从对象的数据流的off位置读取len(p)个字符 到 p&#xA;//返回 读取的字符数 和 error&#xA;//当 ReadAt 返回的 n &amp;lt; len(p) 时，它就会返回一个非nil的错误来解释 &#xA;为什么没有返回更多的字节。在这一点上，ReadAt 比 Read 更严格。&#xA;//即使 ReadAt 返回的 n &amp;lt; len(p)，它也会在调用过程中使用&#xA; p 的全部作为暂存空间。若一些数据可用但不到 len(p) 字节，&#xA;ReadAt 就会阻塞直到所有数据都可用或产生一个错误。 &#xA;在这一点上 ReadAt 不同于 Read。&#xA;// 返回读取的字节数 n 和读取时遇到的错误&#xA;//如果 n &amp;lt; len(p)，则需要返回一个 err 值来说明&#xA;// 为什么没有将 p 填满（比如 EOF）&#xA;// 如果 n = len(p)，而且对象的数据没有全部读完，则&#xA;// err 将返回 nil&#xA;// 如果 n = len(p)，而且对象的数据刚好全部读完，则&#xA;// err 将返回 EOF 或者 nil（不确定）&#xA;type ReaderAt interface {&#xA;    ReadAt(p []byte, off int64) (n int, err error)&#xA;}&#xA;&#xA;//WriterAt 封装了WriterAt方法&#xA;//WriteAt() 将 p 中的数据写入到对象数据流的 off 处&#xA;//返回 写入的字符数 和 error&#xA;type WriterAt interface {&#xA;    WriteAt(p []byte, off int64) (n int, err error)&#xA;}&#xA;&#xA;//ByteReader 封装了ReadByte方法&#xA;//ReadByte 从对象的数据流中读取一个字符到 c&#xA;//如何没有字符可读，返回一个error&#xA;type ByteReader interface {&#xA;    ReadByte() (c byte, err error)&#xA;}&#xA;&#xA;//ByteScanner 在ByteReader的基础上加上了UnreadByte方法&#xA;//UnreadByte() 撤销上一次的ReadByte 即将读写头移到上次ReadByte的位置&#xA;//调用UnreadByte()前必须调用ReadByte(),且不能连续调用UnreadByte()两次，否则返回一个错误&#xA;type ByteScanner interface {&#xA;    ByteReader&#xA;    UnreadByte() error&#xA;}&#xA;&#xA;//ByteWriter 封装了 WriteByte方法&#xA;//WriteByte 将一个字节 c 写入到对象的数据流中&#xA;type ByteWriter interface {&#xA;    WriteByte(c byte) error&#xA;}&#xA;&#xA;//RuneReader 封装了ReadRune方法&#xA;//ReadRune() 从对象的数据流中读取一个UTF-8 字符 &#xA;//返回这个 rune, 还有它所占字符数，还有error&#xA;type RuneReader interface {&#xA;    ReadRune() (r rune, size int, err error)&#xA;}&#xA;&#xA;//RuneScanner 类似于 ByteScanner 就不再赘述&#xA;type RuneScanner interface {&#xA;    RuneReader&#xA;    UnreadRune() error&#xA;}&#xA;&#xA;//stringWriter 封装了 WriteString方法&#xA;//WriteString() 将 字符串s 写入 对象的数据流&#xA;//返回写入的字符数 和 error&#xA;type stringWriter interface {&#xA;    WriteString(s string) (n int, err error)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;接下来看看io中的几个函数&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;//向 Writer 中 写入 字符串&#xA;//返回 写入的字符书 和 error&#xA;//如果 w 也实现了 stringWriter接口 将直接调用其WriteString()&#xA;func WriteString(w Writer, s string) (n int, err error) {&#xA;    if sw, ok := w.(stringWriter); ok {&#xA;        return sw.WriteString(s)&#xA;    }&#xA;    return w.Write([]byte(s))&#xA;}&#xA;&#xA;//从Reader中读取至少min个字符 到 buf&#xA;//返回 读取的字符数 和 error&#xA;//只有当没有数据可读，返回EOF&#xA;//如果 n &amp;lt; min 返回ErrUnexpectedEOF&#xA;//如果 min &amp;gt; len(buf) 返回 ErrShortBuffer&#xA;//只有当 n &amp;gt;= min 返回nil&#xA;func ReadAtLeast(r Reader, buf []byte, min int) (n int, err error) {&#xA;    if len(buf) &amp;lt; min {&#xA;        return 0, ErrShortBuffer&#xA;    }&#xA;    for n &amp;lt; min &amp;amp;&amp;amp; err == nil {&#xA;        var nn int&#xA;        nn, err = r.Read(buf[n:])&#xA;        n += nn&#xA;    }&#xA;    if n &amp;gt;= min {&#xA;        err = nil&#xA;    } else if n &amp;gt; 0 &amp;amp;&amp;amp; err == EOF {&#xA;    err = ErrUnexpectedEOF&#xA;    }&#xA;    return&#xA;}&#xA;&#xA;//ReadFull 与 ReadAtLeast相似，min = len(buf)&#xA;func ReadFull(r Reader, buf []byte) (n int, err error) {&#xA;    return ReadAtLeast(r, buf, len(buf))&#xA;}&#xA;&#xA;//从 Reader 中 复制 n个字符 到 Writer&#xA;//返回 复制的字符数 和 复制过程中最早遇到的错误&#xA;//只有 written == n 返回 nil&#xA;//&#xA;func CopyN(dst Writer, src Reader, n int64) (written int64, err error) {&#xA;    written, err = Copy(dst, LimitReader(src, n))&#xA;    if written == n {&#xA;        return n, nil&#xA;    }&#xA;    if written &amp;lt; n &amp;amp;&amp;amp; err == nil {&#xA;        // src stopped early; must have been EOF.&#xA;        err = EOF&#xA;    }&#xA;    return&#xA;}&#xA;&#xA;//将 src 复制到 dst，直到在 src 上到达 EOF 或发生错误。&#xA;//返回 复制的字符数 和 复制过程中最早遇到的错误&#xA;//成功的 Copy 返回 err == nil，而非 err == EOF。&#xA;//由于 Copy 被定义为从 src 读取直到 EOF 为止，&#xA;//因此它不会将来自 Read 的 EOF 当做错误来报告。&#xA;func Copy(dst Writer, src Reader) (written int64, err error) {&#xA;&#xA;    if rt, ok := dst.(ReaderFrom); ok {&#xA;        return rt.ReadFrom(src)&#xA;    }&#xA;&#xA;    if wt, ok := src.(WriterTo); ok {&#xA;        return wt.WriteTo(dst)&#xA;    }&#xA;    buf := make([]byte, 32*1024)&#xA;    for {&#xA;        nr, er := src.Read(buf)&#xA;        if nr &amp;gt; 0 {&#xA;            nw, ew := dst.Write(buf[0:nr])&#xA;            if nw &amp;gt; 0 {&#xA;                written += int64(nw)&#xA;            }&#xA;            if ew != nil {&#xA;                err = ew&#xA;                break&#xA;            }&#xA;            if nr != nw {&#xA;                err = ErrShortWrite&#xA;                break&#xA;            }&#xA;            }&#xA;        if er == EOF {&#xA;            break&#xA;        }&#xA;        if er != nil {&#xA;            err = er&#xA;            break&#xA;        }&#xA;    }&#xA;    return written, err&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;最后看看io中定义的三个struct&lt;/p&gt;&#xA;&#xA;&lt;p&gt;LimiteReader结构&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;//LimiteReader 从R 中 读取　但限制为Ｎ个字符&#xA;//每次调用Read() 都将更新N&#xA;type LimitedReader struct {&#xA;    R Reader // underlying reader&#xA;    N int64  // max bytes remaining&#xA;}&#xA;&#xA;//LimitReader 用来生成 LimiteReader实例&#xA;func LimitReader(r Reader, n int64) Reader { return &amp;amp;LimitedReader{r, n} }&#xA;&#xA;func (l *LimitedReader) Read(p []byte) (n int, err error) {&#xA;    if l.N &amp;lt;= 0 {&#xA;        return 0, EOF //读取完毕后 返回EOF&#xA;    }&#xA;    if int64(len(p)) &amp;gt; l.N {&#xA;        p = p[0:l.N]&#xA;    }&#xA;    n, err = l.R.Read(p)&#xA;    l.N -= int64(n)     //更新N 来表示 剩余能读取的字符数&#xA;    return&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;SectionReader结构&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;//SectionReader是一个struct（没有任何导出的字段）&#xA;//实现了 Read, Seek 和 ReadAt，同时，内嵌了 ReaderAt 接口。&#xA;type SectionReader struct {&#xA;    r     ReaderAt &#xA;    base  int64 //基址 NewSectionReader 会将 base 设置为 off&#xA;    off   int64 //从 r 中的 off 偏移处开始读取数据&#xA;    limit int64 // limit - off = SectionReader 流的长度&#xA;}&#xA;&#xA;// 返回一个 SectionReader&#xA;//它从 r 中的偏移量 off 处读取 n 个字节后以 EOF 停止&#xA;func NewSectionReader(r ReaderAt, off int64, n int64) *SectionReader {&#xA;    return &amp;amp;SectionReader{r, off, off, off + n}&#xA;}&#xA;&#xA;func (s *SectionReader) Read(p []byte) (n int, err error) {&#xA;    if s.off &amp;gt;= s.limit {&#xA;        return 0, EOF&#xA;    }&#xA;    if max := s.limit - s.off; int64(len(p)) &amp;gt; max {&#xA;        p = p[0:max]&#xA;    }&#xA;    n, err = s.r.ReadAt(p, s.off)&#xA;    s.off += int64(n)&#xA;    return&#xA;}&#xA;&#xA;//Seek() 中的 两种错误&#xA;var errWhence = errors.New(&amp;quot;Seek: invalid whence&amp;quot;)&#xA;var errOffset = errors.New(&amp;quot;Seek: invalid offset&amp;quot;)&#xA;&#xA;func (s *SectionReader) Seek(offset int64, whence int) (ret int64, err error) {&#xA;    switch whence {&#xA;    default:&#xA;        return 0, errWhence&#xA;    case 0:&#xA;        offset += s.base&#xA;    case 1:&#xA;        offset += s.off&#xA;    case 2:&#xA;        offset += s.limit&#xA;    }&#xA;    if offset &amp;lt; s.base || offset &amp;gt; s.limit {&#xA;        return 0, errOffset&#xA;    }&#xA;    s.off = offset&#xA;    return offset - s.base, nil&#xA;}&#xA;&#xA;func (s *SectionReader) ReadAt(p []byte, off int64) (n int, err error) {&#xA;    if off &amp;lt; 0 || off &amp;gt;= s.limit-s.base {&#xA;        return 0, EOF&#xA;    }&#xA;    off += s.base&#xA;    if max := s.limit - off; int64(len(p)) &amp;gt; max {&#xA;        p = p[0:max]&#xA;        n, err = s.r.ReadAt(p, off)&#xA;        if err == nil {&#xA;            err = EOF&#xA;        }&#xA;        return n, err&#xA;    }&#xA;    return s.r.ReadAt(p, off)&#xA;}&#xA;&#xA;// 返回 SectionReader的大小&#xA;func (s *SectionReader) Size() int64 { &#xA;    return s.limit - s.base &#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;teeReader结构&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;//将从 r 中读到的数据写入 w 中。&#xA;//所有经由它处理的从 r 的读取都匹配于对应的对 w 的写入。&#xA;//它没有内部缓存，即写入必须在读取完成前完成。&#xA;//任何在写入时遇到的错误都将作为读取错误返回。&#xA;type teeReader struct {&#xA;    r Reader&#xA;    w Writer&#xA;}&#xA;&#xA;func TeeReader(r Reader, w Writer) Reader {&#xA;    return &amp;amp;teeReader{r, w}&#xA;}&#xA;&#xA;func (t *teeReader) Read(p []byte) (n int, err error) {&#xA;    n, err = t.r.Read(p)&#xA;    if n &amp;gt; 0 {&#xA;        if n, err := t.w.Write(p[:n]); err != nil {&#xA;            return n, err&#xA;        }&#xA;    }&#xA;    return&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;[返回顶部]()&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>interface</title>
      <link>http://pokerg.github.io/Programming Language/interface/</link>
      <pubDate>2013-08-26 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;If I could export one feature of Go into other languages, it would be interfaces.&#xA;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;———Rob Pike&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;interface作为Golang的整个类型系统的基石，让Golang在基础编程哲学的探索上达到前所未有的高度。&amp;gt;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;——《Go语言编程》&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;接口是Java引入的特性。在软件工程上占有重要地位。而Golang变革了接口的概念。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;我们考虑这样一个情况，有两个struct都实现了一些非常有用的小子集中的相关方法，这时有办法操作两个struct的任意一个就显得非常有用。那么我们该怎么办呢？这就是接口的作用。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type s1 struct{&#xA;    ...//一些属性&#xA;}&#xA;type s2 struct{&#xA;    ...//一些属性&#xA;｝&#xA;func (a *s1)foo(){&#xA;    ...//具体实现1&#xA;}&#xA;func (b *s2)foo(){&#xA;    ...//具体实现2&#xA;｝&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;这时，如果我们有需要操作两个stuct中的任意一个，可以声明这样一个interface&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type Foo interface{&#xA;    foo()&#xA;    //只要实现了foo()函数，就相当于实现了Foo接口 &#xA;    //我们就可以用接口来调用对象&#xA;&#xA;}&#xA;&#xA;func test(a Foo,b int){&#xA;    a.foo()&#xA;    //传进不同的struct对象，函数将调用不同的foo()方法&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;从这个例子，我们就能看出interface的作用，降低耦合性，可以让某个模块或功能重复利用。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;我们来看看io包，其中最基本的也是最重要的两个接口Reader和Writer。我们说，只要实现了这两个接口，就基本拥有了IO的功能。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func ReadFrom(reader io.Reader,num int)([]byte,error){&#xA;    p := make([]byte,num)&#xA;    n,err：＝　reader.Read(p)&#xA;    if n &amp;gt; 0 {&#xA;        return p[:n],nill&#xA;    }&#xA;    return p,err&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;ReadFrom将io.Reader作为参数，我们可以从任何实现了io.Reader接口的地方读取数据&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;//从标准输入流读取&#xA;data,err := ReadFrom（os.Stdin,10)&#xA;&#xA;//从文件中读取&#xA;file, err1 := os.Open(util.GetProjectRoot() + &amp;quot;01.txt&amp;quot;)&#xA;data,err2 := ReadFrom（file,10)&#xA;&#xA;//从字符串读取&#xA;data，err := ReadFrom(strings.NewReader(&amp;quot;from string&amp;quot;),10)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;这是strings包中关于Reader的Read的实现&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func (r *Reader) Read(b []byte) (n int, err error) {&#xA;    if len(b) == 0 {&#xA;        return 0, nil&#xA;    }&#xA;    if r.i &amp;gt;= len(r.s) {&#xA;        return 0, io.EOF&#xA;    }&#xA;    n = copy(b, r.s[r.i:])&#xA;    r.i += n&#xA;    r.prevRune = -1&#xA;    return&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;这里没有强制声明strings.Reader这个struct实现了哪个interface，但是它实现了Read方法，在Golang中也就实现了io.Reader这个接口。这种隐式的声明在Golang中术语叫做非侵入式接口。这样做的好处，我曾经在 &lt;strong&gt;初识Go语言&lt;/strong&gt; 中提过。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;其一，Go语言的标准库，再也不需要绘制类库的继承树图。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;其二，实现类的时候，只需要关心自己应该提供哪些方法，不用再纠结接口需要拆得多细才合理。接口由使用方按需定义，而不用事前规划。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;其三，不用为了实现一个接口而导入一个包，因为多引用一个外部的包，就意味着更多的耦合。接口由使用方按自身需求来定义，使用方无需关心是否有其他模块定义过类似的接口。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;Golang也可以通过接口的组合，实现一种抽向上的层次，&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type ReadWriter interface {&#xA;    Reader&#xA;    Writer&#xA;}&#xA;&#xA;type ReadCloser interface {&#xA;    Reader&#xA;    Closer&#xA;}&#xA;&#xA;type WriteCloser interface {&#xA;    Writer&#xA;    Closer&#xA;}&#xA;&#xA;type ReadWriteCloser interface {&#xA;    Reader&#xA;    Writer&#xA;    Closer&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;这几个接口都是Reader，Writer，Closer等基本接口的组合，可以说接口组合为Go程序建立起一个严密而有序的体系。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;最后再谈谈一个有趣的interface ——interface｛｝&#xA;由于Go语言中任何对象实例都满足空接口interface{}，所以interface{}看起来像是可以指向任何对象的Any类型。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;var v1 interface{} = 1 // 将int类型赋值给interface{}&#xA;var v2 interface{} = &amp;quot;abc&amp;quot; // 将string类型赋值给interface{}&#xA;var v3 interface{} = &amp;amp;v2 // 将*interface{}类型赋值给interface{}&#xA;var v4 interface{} = struct{ X int }{1}&#xA;var v5 interface{} = &amp;amp;struct{ X int }{1}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;当函数可以接受任意的对象实例时，我们会将其声明为interface{}，最典型的例子是标准库fmt中PrintXXX系列的函数，例如：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func Printf(fmt string, args ...interface{})&#xA;func Println(args ...interface{})&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;####总结&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;interface作为Golang类型系统的基石，为Golang工程形成了一个严密而清晰的体系，但其理念和使用却极为简洁，是Golang众多优秀特性中极为突出的一个，是我们学习Golang必须掌握的一点。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;[返回顶部]()&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>苦难</title>
      <link>http://pokerg.github.io/Philosophy/%E8%8B%A6%E9%9A%BE/</link>
      <pubDate>2013-08-24 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&amp;emsp;&amp;emsp;面对社会悲剧，我们有理想、信念、正义感、崇高感支撑着我们，我们相信自己在精神上无比地优越于那迫害乃至毁灭我们的恶势力，因此我们可以含笑受难，慷慨赴死。我们是舞台上的英雄，哪怕眼前这个剧场里的观众全都浑浑噩噩，是非颠倒，我们仍有勇气把戏演下去，演给我们心目中绝对清醒公正的观众看，我们称这观众为历史、上帝或者良心。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;可是，面对自然悲剧，我们有什么呢？这里没有舞台，只有空漠无际的苍穹。我们不是英雄，只是朝生暮死的众生。任何人间理想都抚慰不了生老病死的悲哀，在天灾人祸面前也谈不上什么正义感。当史前人类遭受大洪水的灭顶之灾时，当庞贝城居民被维苏威火山的岩浆吞没时，他们能有什么慰藉呢？地震,海啸，车祸，空难，瘟疫，绝症&amp;hellip;&amp;hellip;大自然的恶势力轻而易举地把我们或我们的亲人毁灭。我们面对的是没有灵魂的敌手，因而不能以精神的优越自慰，却愈发感到了生命的卑微。没有上帝来拯救我们，因为这灾难正是上帝亲手降下。我们愤怒，但无从泄愤。我们冤屈，但永无申冤之日。我们反抗，但我们的反抗孤立无助，注定失败。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;然而我们未必就因此倒下。也许，没有浪漫气息的悲剧是我们最本质的悲剧，不具有英雄色彩的勇气是我们最真实的勇气。在无可告慰的绝望中，我们咬牙挺住。我们挺立在那里，没有观众，没有证人，也没有期待，没有援军。我们不倒下，仅仅是因为我们不肯让自己倒下。我们以此维护了人的最高的也是最后的尊严————人在神面前的尊严。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;————周国平&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>channel的两个特性</title>
      <link>http://pokerg.github.io/Programming Language/channel%E7%9A%84%E4%B8%A4%E4%B8%AA%E7%89%B9%E6%80%A7/</link>
      <pubDate>2013-08-22 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&amp;emsp;&amp;emsp;channel是Go提供的语言级goroutine间的通信方式。它提供了一种优雅而又强大的，在不使用锁的情况下，从某个goroutine向其他goroutine发送数据流的方式。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;esmp;emsp;这次着重讨论channel的两个重要特性。参考：&lt;a href=&#34;http://dave.cheney.net/2013/04/30/curious-channels&#34;&gt;http://dave.cheney.net/&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;04&lt;/sub&gt;/30/curious-channels&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;被关闭的channel不会block&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&amp;esmp;emsp;一个channel一旦被关闭，就不能再向其发送数据，但是仍然可以获取其中的。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import &amp;quot;fmt&amp;quot;&#xA;&#xA;func main() {&#xA;    ch := make(chan bool, 2)&#xA;    ch &amp;lt;- true&#xA;    ch &amp;lt;- true&#xA;    close(ch)&#xA;&#xA;    for i := 0; i &amp;lt; cap(ch) +1 ; i++ {&#xA;            v, ok := &amp;lt;- ch&#xA;            fmt.Println(v, ok)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;我们创造了缓冲区为两个值的channel。&lt;br/&gt;&#xA;输出结果:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;true true&#xA;true true&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这个程序首先输出发送到channel的两个值，然后在第三次&amp;lt;-时返回false和false。第一个false是channel类型的零值。第二个表示channel的启用状态。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;能够检测channel 的启用状态也是很有用的一个特性。可用于对channel进行range操作。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;esmp;emsp;我们在这里举一个close channel的有用例子。首先看这个程序：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;sync&amp;quot;&#xA;    &amp;quot;time&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;    finish := make(chan bool)&#xA;    var done sync.WaitGroup&#xA;    done.Add(1)&#xA;    go func() {&#xA;            select {&#xA;            case &amp;lt;-time.After(1 * time.Hour):&#xA;            case &amp;lt;-finish:&#xA;            }&#xA;            done.Done()&#xA;    }()&#xA;    t0 := time.Now()&#xA;    finish &amp;lt;- true // 发送关闭信号&#xA;    done.Wait()    // 等待 goroutine 结束&#xA;    fmt.Printf(&amp;quot;Waited %v for goroutine to stop\n&amp;quot;, time.Since(t0))&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这个程序能够正常结束 &lt;code&gt;Waited 129.607us for goroutine to stop&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;但是存在一些问题。首先finish channel 是不带缓冲的。如果接收方忘记了在select语句中添加finish，向其发送数据可能会导致阻塞。当然可以通过对要发送到的select块进行封装，以确保不会阻塞，或者设置带有缓冲的channel。但是，如果有许多goroutine都监听在finish channel上，那就需要跟踪这个情况，并且记住发送正确数量的数据给finish channel。如果无法控制goroutine的创建会很棘手；同时它们也可能是由程序的另一部分创建的，例如在响应网络请求的时候。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;对于这种情况，我们可以利用已经关闭的channel会实时返回这一机制。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;sync&amp;quot;&#xA;    &amp;quot;time&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;    const n = 100&#xA;    finish := make(chan bool)&#xA;    var done sync.WaitGroup&#xA;    for i := 0; i &amp;lt; n; i++ { &#xA;            done.Add(1)&#xA;            go func() {&#xA;                    select {&#xA;                    case &amp;lt;-time.After(1 * time.Hour):&#xA;                    case &amp;lt;-finish:&#xA;                    }&#xA;                    done.Done()&#xA;            }()&#xA;    }&#xA;    t0 := time.Now()&#xA;    close(finish)    // 关闭 finish 使其立即返回&#xA;    done.Wait()      // 等待所有的 goroutine 结束&#xA;    fmt.Printf(&amp;quot;Waited %v for %d goroutines to stop\n&amp;quot;, time.Since(t0), n)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Waited 231.385us for 100 goroutines to stop&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;那么这里发生了什么？当 finish channel 被关闭后，它会立刻返回。那么所有等待接收 time.After channel 或 finish 的 goroutine 的 select 语句就立刻完成了，并且 goroutine 在调用 done.Done() 来减少 WaitGroup 计数器后退出。这个强大的机制在无需知道未知数量的 goroutine 的任何细节而向它们发送信号而成为可能，同时也不用担心死锁。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;nil channel 永远都是 block&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;再看Unknwon的《Go fundamental programming》时，他提到过一个类似于这样的例子。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// WaitMany 等待 a 和 b 关闭。&#xA;func WaitMany(a, b chan bool) {&#xA;    var aclosed, bclosed bool&#xA;    for !aclosed || !bclosed {&#xA;            select {&#xA;            case &amp;lt;-a:&#xA;                    aclosed = true&#xA;            case &amp;lt;-b:&#xA;                    bclosed = true&#xA;            }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;WaitMany() 用于等待 channel a 和 b 关闭是个不错的方法，但是有一个问题。假设 channel a 首先被关闭，然后它会立刻返回。但是由于 bclosed 仍然是 false，程序会进入死循环，而让 channel b 永远不会被判定为关闭。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;当时他也没用给出什么好的解决办法。在这里解决这个问题的比较好的办法就是利用nil channel的阻塞特性。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;time&amp;quot;&#xA;)&#xA;&#xA;func WaitMany(a, b chan bool) {&#xA;    for a != nil || b != nil {&#xA;            select {&#xA;            case &amp;lt;-a:&#xA;                    a = nil &#xA;            case &amp;lt;-b:&#xA;                    b = nil&#xA;            }&#xA;    }&#xA;}&#xA;&#xA;func main() {&#xA;    a, b := make(chan bool), make(chan bool)&#xA;    t0 := time.Now()&#xA;    go func() {&#xA;            close(a)&#xA;            close(b)&#xA;    }()&#xA;    WaitMany(a, b)&#xA;    fmt.Printf(&amp;quot;waited %v for WaitMany\n&amp;quot;, time.Since(t0))&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;在重写的 WaitMany() 中，一旦接收到一个值，就将 a 或 b 的引用设置为 nil。当 nil channel 是 select 语句的一部分时，它实际上会被忽略，因此，将 a 设置为 nil 便会将其从 select 中移除，仅仅留下 b 等待它被关闭，进而退出循环。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;总的来说，close和nil channel这些特性非常简单，但是它们的功能强大，使得创建高并发程序变得简单。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;[返回顶部]()&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Go Build in</title>
      <link>http://pokerg.github.io/Programming Language/Go-Build-in/</link>
      <pubDate>2013-08-20 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;内置关键字（25个 均为小写）&lt;/h2&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;break&amp;emsp;&amp;emsp;default&amp;emsp;&amp;emsp;func&amp;emsp;&amp;emsp;interface&amp;emsp;&amp;emsp;select&lt;br /&gt;&#xA;case&amp;emsp;&amp;emsp;defer&amp;emsp;&amp;emsp;go&amp;emsp;&amp;emsp;map&amp;emsp;&amp;emsp;struct&lt;br /&gt;&#xA;chan&amp;emsp;&amp;emsp;else&amp;emsp;&amp;emsp;goto&amp;emsp;&amp;emsp;package&amp;emsp;&amp;emsp;switch&lt;br /&gt;&#xA;const&amp;emsp;&amp;emsp;fallthrough&amp;emsp;&amp;emsp;if&amp;emsp;&amp;emsp;range&amp;emsp;&amp;emsp;type&lt;br /&gt;&#xA;continue&amp;emsp;&amp;emsp;for&amp;emsp;&amp;emsp; import&amp;emsp;&amp;emsp;return&amp;emsp;&amp;emsp;var &lt;br/&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h2&gt;内置类型&lt;/h2&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;值类型：&lt;br /&gt;&#xA;bool&lt;br /&gt;&#xA;byte&lt;br /&gt;&#xA;int(32 or 64), int8, int16, int32, int64&lt;br /&gt;&#xA;uint(32 or 64), uint8(byte), uint16, uint32, uint64&lt;br /&gt;&#xA;float32, float64&lt;br /&gt;&#xA;string&lt;br /&gt;&#xA;complex64, complex128   &amp;ndash;复数&lt;br /&gt;&#xA;array    &amp;ndash; 固定长度的数组&lt;br /&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;引用类型：(指针类型)&lt;br /&gt;&#xA;slice   &amp;ndash; 切片&lt;br /&gt;&#xA;map        &amp;ndash; 映射&lt;br /&gt;&#xA;chan    &amp;ndash; 管道&lt;br /&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h2&gt;内置函数&lt;/h2&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;append  &amp;ndash; 把东西增加到slice里面,返回修改后的slice&lt;br /&gt;&#xA;close   &amp;ndash; 关闭channel&lt;br /&gt;&#xA;delete    &amp;ndash; 从map中删除key对应的value&lt;br /&gt;&#xA;panic    &amp;ndash; 停止常规的goroutine&lt;br /&gt;&#xA;recover &amp;ndash; 允许程序定义goroutine的panic动作&lt;br /&gt;&#xA;imag    &amp;ndash; 返回complex的实部&lt;br /&gt;&#xA;real    &amp;ndash; 返回complex的虚部&lt;br /&gt;&#xA;make    &amp;ndash; 返回Type本身(只能应用于slice, map, channel)&lt;br /&gt;&#xA;new        &amp;ndash; 返回指向Type的指针&lt;br /&gt;&#xA;cap        &amp;ndash; 容量，容积capacity&lt;br /&gt;&#xA;copy    &amp;ndash; 复制slice，返回复制的数目&lt;br /&gt;&#xA;len        &amp;ndash; 返回长度&lt;br /&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h2&gt;内置接口&lt;/h2&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type error interface {        //只要实现了Error()函数，返回值为String的都实现了err接口&#xA;    Error() string&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Go语言代码风格</title>
      <link>http://pokerg.github.io/Programming Language/Go%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/</link>
      <pubDate>2013-08-19 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;代码必须是本着写给人阅读的原则来编写，只不过顺便给机器执行而已。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;mdash;《计算机程序设计与解释》&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;对于程序员来说，代码风格的重要性自然是不必多说的，我曾经买过一本《Java编程风格》，我们想想光是代码风格就要写成一本书，是多么让人头疼。而Go语言很有可能是第一个将代码风格强制统一的语言。一些在其他语言中编译器可以通过的问题，在Go编译器中会被认为是编译错误。由于刚好Go语言强制规定的代码形式都是我常用的，也是我很喜欢的，所以非常幸运啊。。（这也是我喜欢Go语言的一个重要原因）。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;Go语言关于编码规范的问题，主要分为两类，一是：由编译器进行的强制代码规范；二是：由go fmt 格式化的非强制性编码风格。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;Go语言的强制代码规范是Go设计者认为最需要统一的风格。首先，就是命名，Go语言对于可见性的规则不像C语言用 private public 等关键字来声明可见性，而是规定暴露于外部的名字用大写开头，不需要暴露的用小写字母开头。目前比较流行的命名法有两种：骆驼命名法 和 下划线法。Go语言明确宣告支持骆驼命名法，排斥下划线法。虽然以前写C语言都用的是下划线法，但是后来用php，js，python什么的用的是都是骆驼命名法，而且骆驼命名法打起来明显比下划线法方便，所以也是很喜欢。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;还有就是关于花括号的问题。最初的风格为K&amp;amp;R，后来又有了MS风格，可能因为Go语言的设计者有Ken Thompson，所以，，我们还是使用他所创的那种风格吧。而且我觉得这样写代码更加紧凑，而且清晰度也很高。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;另外Go工具链中还有个go fmt用来格式化代码。它可以调整语句的位置，重新摆放花括号的位置，以制表符来缩进，添加空格等等。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;总的来说，Go语言的代码规范可以算是集C语言出世这几十年来的思想之大成，优雅，规范，非常对我胃口&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>革命</title>
      <link>http://pokerg.github.io/Philosophy/%E9%9D%A9%E5%91%BD/</link>
      <pubDate>2013-08-16 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;加缪的《反抗者》写的很精彩，周国平的点评也很精彩，我忍不住想把它摘录下来&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;“反抗”在本质上是肯定的，反抗者总是为了捍卫某种价值才说“不”的，他要捍卫的这种价值并不属于个人，而是被视为人性的普遍价值。因此，反抗使个人摆脱孤独。“我反抗，故我们存在”这是反抗的意义所在。但其中也隐含着危险，便是把所要捍卫的价值绝对化。其表现之一，就是以历史的名义进行的反抗，即革命。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;对卢梭的《社会契约论》的批判是《反抗者》中的精彩篇章。加缪一针见血地指出，卢梭的 这部为法国革命奠基的著作是新福音书，新宗教，新神学。革命的特点是要在历史中实现某 种绝对价值，并且声称这种价值的实现就是人类的最终统一和历史的最终完成。这一现代革命概念肇始于法国革命。革命所要实现的那个绝对价值必定是抽象的，至高无上的，在卢梭 那里，它就是与每个人的意志相分离的&amp;rdquo;总体意志&amp;rdquo;。&amp;rdquo;总体意志&amp;rdquo;被宣布为神圣的普遍理 性的体现，因而作为这&amp;rdquo;总体意志&amp;rdquo;之载体的抽象的&amp;rdquo;人民&amp;rdquo;也就成了新的上帝。圣·鞠斯 特进而赋予&amp;rdquo;总体意志&amp;rdquo;以道德含义，并据此把&amp;rdquo;任何在细节上反对共和国&amp;rdquo;亦即触犯&amp;rdquo;总 体意志&amp;rdquo;的行为都宣判为罪恶，从而大开杀戒，用断头台来担保品德的纯洁。浓烈的道德化 色彩也正是现代革命的特点之一，正如加缪所说：&amp;rdquo;法国革命要把历史建立在绝对纯洁的原 则上，开创了形式道德的新纪元。&amp;rdquo;而形式道德是要吃人的，它导致了无限镇压原则。它对 心理的威慑力量甚至使无辜的受害者自觉有罪。我们由此而可明白，圣·鞠斯特本人后来从 被捕到处死为何始终保持着沉默，斯大林时期冤案中的那些被告又为何几乎是满怀热情地给 判处他们死刑的法庭以配合。在这里起作用的已经不是法律，而是神学。既然是神圣的&amp;rdquo;人 民&amp;rdquo;在审判，受审者已被置于与&amp;rdquo;人民&amp;rdquo;相对立的位置上，因而在总体上是有罪的，细节就完全不重要了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;革命者自命对于历史负有使命，要献身于历史的终极目标。可是他们是从哪里获知这个终极目标的呢？雅斯贝尔斯指出：人处于历史中，所以不可能把握作为整体的历史。加缪引证了这一见解，进一步指出：因此，任何历史举动都是冒险，无权为任何绝对立场辩护。绝对的理性主义就如同绝对的虚无主义一样，也会把人类引向荒漠。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>初识Go语言[2]</title>
      <link>http://pokerg.github.io/Programming Language/%E5%88%9D%E8%AF%86Go%E8%AF%AD%E8%A8%80%5B2%5D/</link>
      <pubDate>2013-08-14 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&amp;emsp;今天我们接着昨天的话题&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;interface&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;Go语言的设计者之一&lt;strong&gt;Rob Pike&lt;/strong&gt;说过，如果只能选择一个Go语言的特性移植到其他语言，他会选择接口。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;Go语言对编程哲学的变革正是在于接口。&lt;strong&gt;《Go语言编程》&lt;/strong&gt;中说道:&amp;ldquo;如果说goroutine和channel是支撑起Go语言的并发模型的基石，让Go语言在如今集群化和多核化的时代成为一道极为亮丽的风景，那么接口是Go语言整个类型系统的基石，让Go语言在基础编程哲学的探索上达到前所未有的高度&amp;rdquo;,这段话可谓是极其之高的评价。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;与其他语言的接口相比，Go语言的接口是&amp;rdquo;非侵入式&amp;rdquo;的，即不需要明确声明接口的继承，只需要实现其所有函数，就实现了该接口。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;这样做的好处有很多。首先Java，C++等类库的继承树变得毫无意义;其次，我们不用再纠结于接口应该拆的多细;再次，不用为了实现一个接口而导入一个包。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;Go语言中接口的各种操作也是非常方便的，赋值，查询，组合都能非常优雅的完成。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;最后再说说interface｛｝这个在Go语言中的地位类似于Java中的Object,interface{]是可以指向任何对象的Any类型。最为经典的fmt库中的Print等函数 &lt;code&gt;func Printf（fmt string,args ...interface{})&lt;/code&gt; 我们可以用interface{}实现接受任意数量任意类型的参数 再配合上接口查询 类型查询 循环等写出非常漂亮的代码。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;错误处理&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;自从C++以来，错误处理不仅作为一种编程范式，也在语言层面上增加了错误处理的支持。Go语言中的错误处理有个标准模式，即error接口&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;defer也是个非常有意思的东西，它类似C++中的析构函数，如果你是C/C++程序员，你肯定经历过打开一个文件句柄却忘记关闭的情况，使用defer就能很漂亮的解决这个问题。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;panic()和recover()作为错误处理的两个内置函数，使用起来也非常优雅。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;OOP特性&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;Go语言没有其他面向对象编程语言那些继承，虚函数，构造函数等的概念，甚至没有类的概念。有的只是继承于C语言的struct。Go语言放弃了包括继承在内的大量面向对象特性，只保留了组合这个最基本的特性。&#xA;Go语言中可以为任何类型添加方法，自然struct加上方法也就是类，组合也就能实现继承的性质，而且Go语言中没有this指针这个让无数初学者头疼的玩意，在Go语言中本体对象是显式传递的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;Go语言对面向对象编程的支持是语言类型中的天然组成部分，没有太多花里胡哨的东西，整个类型系统再与接口结合，浑然一体。我们用学习C++高级特性的功夫就可以用Go语言编出很多漂亮的工程。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;####总结&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;Go语言语法给我的感觉就是  &lt;strong&gt;简洁  优雅&lt;/strong&gt; ，它通过强大的语言支持和简单的组合就能完成其他语言需要深厚的功底和大量功夫所能实现的特性。 与vim的设计哲学 &lt;em&gt;命令的组合&lt;/em&gt; 也非常相近。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;我是一个非常喜欢简洁，优雅的人，所以当接触到Go的不久，我就为她所痴迷，相信Go势必也会在将来占有很重要的地位。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;[返回顶部]()&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>中蛊者</title>
      <link>http://pokerg.github.io/Philosophy/%E4%B8%AD%E8%9B%8A%E8%80%85/</link>
      <pubDate>2013-08-14 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;人类天性中有一种不可消除的冲动，就是要对世界和人生的问题追根究底。这种冲动虽说提高了人类存在的精神品质，但却不利于人类在生物学意义的存在。仿佛是为了保护人类的存在，上天让这种冲动在少数人身上表现的格外强烈。古往今来，在世界的不同角落，都有这样一些怀着强烈的形而上学冲动的人，不妨说，他们是一些中了形而上学之蛊的人。&#xA;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;ndash;周国平&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;小时候我也经常有这种感觉，觉得周围的一切都是不真实的，觉得自己生活在一个梦里，自己的各种行为以及周围的各种事都是在梦里产生的，而自己只不过在做梦。后来我又想过，我怎么能确定我是在做梦，而不是在梦里又在做梦？。就这样我陷入了一种恐慌，究竟什么是真实？究竟人生的意义是什么？&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;相信每个人都从出生就在寻找着解决自己困惑的方法，我是谁？我从哪来？我将要去往何处？ 人类在黑暗中蹒跚前行，哲学家站在了时代思想的顶峰，看到远方理想的目的地及通往理想目的地的道路。至少人类要有路可走。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;哲学家与思想家不同，思想家追求合理，哲学家追求绝对。为人类的存在寻求一种形而上的绝对的永恒的意义是哲学家探索哲学的目的。宗教正是理想主义之极致，理想主义所相信的绝对精神价值不过是神的同语罢了。上帝是人存在的终极意义和向上动力。但是愈是渴求信仰的灵魂愈是难以盲信。尼采曾绝望地祈求上帝赐予他疯狂，只有疯狂才能让他继续信仰上帝。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;&amp;emsp;哲学家是在无神的沙漠跋涉和虔诚之心破碎的人。深受形而上学之蛊的迫害，他们的才能使得他们成为精神领域的天才，但是即使这样，这种强烈的冲动也有可能毁了他们，尼采最终还是疯了，不用再受折磨，但自此以后他的灵魂也就处于重重的黑暗之中了。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>初识Go语言[1]</title>
      <link>http://pokerg.github.io/Programming Language/%E5%88%9D%E8%AF%86Go%E8%AF%AD%E8%A8%80%5B1%5D/</link>
      <pubDate>2013-08-13 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&amp;emsp;作为一个刚接触Go没几天的Gopher,没什么能力对其原理和高级用法做出分析和评价，姑且就对其语法形式谈谈我的看法，也算是对我这几天来的一个总结和回顾，姑妄言之，大家莫怪。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;变量的声明&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;首先最基本的声明方式     &lt;code&gt;var a,b int&lt;/code&gt;&#xA;和C语言相比 仅仅是把 类型 和 变量名称的顺序调换，但是我认为这样看起来比C语言可读性更高，而且var的引入使注意力更加集中（可能是前段时间php，js，python什么的看多了吧)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;再者 &lt;code&gt;a,b := 1,2&lt;/code&gt; 这种声明方式确实让我耳目一新，Go语言是类型安全的，但是这种写法让我有了动态语言的感觉，使用起来很方便，也很舒服。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;类型&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;Go与C相比类型多了很多，complex,error,map,interface,chan 等等，其中最让我感兴趣的是map 和 interface（chan 是并发的内容，暂不考虑), interface 一会专门讲，我们先谈谈map，php等语言的数组就具有map类似的功能，Go的map使用起来也很方便，赋值，删除，查找做的非常简单和精巧。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;slice看起来很像指向数组的指针，但还有些许不同，它还有元素个数和分配的空间两个“属性”，slice和数组很容易让人联想到STL里的vector和数组的关系，slice的动态扩展空间的能力和各种管理功能很好很强大。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;流程控制&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;Go语言的流程控制语句少了小括号，现在很多语言都去掉了这个，让我们可以少打很多字&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;switch语句默认加了break，这个确实让我很兴奋，不用再担心少写break而出现bug&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;Go语言的循环语言只有for关键字（确实这是最常用的，C语言中我也很少用while和do-while），Go中for的形式非常灵活，功能也很完善。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;goto被许许多多的人所诟病，但是对于Go这样一个仅有25个关键字的语言来说，仍然支持goto关键字，说明goto在某些场合下确实是很合适的。（linux内核中goto出现的频率之高！！！）。break和continue 可以带标签，着实让我感慨，真是为程序员考虑啊。以后再也不用为多重循环的跳转头疼了。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;函数&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;Go语言函数的关键字，让我看着不太爽，func感觉像是被剪掉尾巴的孔雀，缩写的太难看，要不function 要不 fn 多好。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;因为Go的函数是多返回值的，所以它的函数头，返回值位于后头，这样写也挺好 &lt;code&gt;func add(a , b int)(ret int,err error)｛｝&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;Go函数可以有多个返回值，这个是迄今为止Go语言与其他语言最大的不同，结合上Go语言的多重赋值，Go语言的代码会很简洁、优雅。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;######结尾&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;emsp;今天我们就先谈论到这，明天我们说说Go语言的interface，error，和 OOP特性。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;[返回顶部]()&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>HOJ 2654  Printer Queue</title>
      <link>http://pokerg.github.io/ACM/HOJ-2654--Printer-Queue/</link>
      <pubDate>2013-04-09 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&#xA;&lt;/p&gt;&#xA;&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;&#xA;    The only printer in the computer science students&#39; union is experiencing an extremely heavy workload. Sometimes there are a hundred jobs in the printer queue and you may have to wait for hours to get a single page of output. Because some jobs are more important than others, the Hacker General has invented and implemented a simple priority system for the print job queue. Now, each job is assigned a priority between 1 and 9 (with 9 being the highest priority, and 1 being the lowest), and the printer operates as follows.&#xA;&lt;/p&gt;&#xA;&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;&#xA;    &lt;img src=&#34;http://acm.hit.edu.cn/hoj/static/img/pic/26541.bmp&#34; alt=&#34;&#34; style=&#34;margin:10px; padding:0px&#34; /&gt;&#xA;&lt;/p&gt;&#xA;&lt;ul style=&#34;margin:0px; padding:15px 0px 15px 30px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; font-size:16px; line-height:20px; background-color:rgb(247,247,247)&#34;&gt;&#xA;    &lt;li style=&#34;margin:0px; padding:0px&#34;&gt;&#xA;        The first job J in queue is taken from the queue.&#xA;    &lt;/li&gt;&#xA;    &lt;li style=&#34;margin:0px; padding:0px&#34;&gt;&#xA;        If there is some job in the queue with a higher priority than job J, thenmove J to the end of the queue without printing it.&#xA;    &lt;/li&gt;&#xA;    &lt;li style=&#34;margin:0px; padding:0px&#34;&gt;&#xA;        Otherwise, print job J (and do not put it back in the queue).&#xA;    &lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;&#xA;    In this way, all those importantmuffin recipes that the Hacker General is printing get printed very quickly. Of course, those annoying term papers that others are printing may have to wait for quite some time to get printed, but that&#39;s life.&#xA;&lt;/p&gt;&#xA;&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;&#xA;    Your problem with the new policy is that it has become quite tricky to determine when your print job will actually be completed. You decide to write a program to figure this out. The program will be given the current queue (as a list of priorities) as well as the position of your job in the queue, and must then calculate how long it will take until your job is printed, assuming that no additional jobs will be added to the queue. To simplifymatters, we assume that printing a job always takes exactly one minute, and that adding and removing jobs from the queue is instantaneous.&#xA;&lt;/p&gt;&#xA;&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;&#xA;&lt;/p&gt;&#xA;&lt;h3 style=&#34;margin:0px; padding:0px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; line-height:20px; background-color:rgb(247,247,247)&#34;&gt;&#xA;    Input&#xA;&lt;/h3&gt;&#xA;&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;&#xA;&lt;/p&gt;&#xA;&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;&#xA;    One line with a positive integer: the number of test cases (at most 100). Then for each test case:&#xA;&lt;/p&gt;&#xA;&lt;ul style=&#34;margin:0px; padding:15px 0px 15px 30px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; font-size:16px; line-height:20px; background-color:rgb(247,247,247)&#34;&gt;&#xA;    &lt;li style=&#34;margin:0px; padding:0px&#34;&gt;&#xA;        One line with two integers n and m, where n is the number of jobs in the queue (1 ≤ n ≤ 100) and m is the position of your job (0 ≤ m ≤ n - 1). The first position in the queue is number 0, the second is number 1, and so on.&#xA;    &lt;/li&gt;&#xA;    &lt;li style=&#34;margin:0px; padding:0px&#34;&gt;&#xA;        One linewith n integers in the range 1 to 9, giving the priorities of the jobs in the queue. The first integer gives the priority of the first job, the second integer the priority of the second job, and so on.&#xA;    &lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;&#xA;&lt;/p&gt;&#xA;&lt;h3 style=&#34;margin:0px; padding:0px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; line-height:20px; background-color:rgb(247,247,247)&#34;&gt;&#xA;    Output&#xA;&lt;/h3&gt;&#xA;&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;&#xA;&lt;/p&gt;&#xA;&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;&#xA;    For each test case, print one line with a single integer; the number of minutes until your job is completely printed, assuming that no additional print jobs will arrive.&#xA;&lt;/p&gt;&#xA;&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;&#xA;&lt;/p&gt;&#xA;&lt;h3 style=&#34;margin:0px; padding:0px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; line-height:20px; background-color:rgb(247,247,247)&#34;&gt;&#xA;    Sample Input&#xA;&lt;/h3&gt;&#xA;&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;&#xA;&lt;/p&gt;&#xA;&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;&#xA;&lt;/p&gt;&#xA;&lt;pre style=&#34;margin-top:0px; margin-bottom:0px; padding:5px; background-color:rgb(224,224,224); font-size:14px; line-height:16px; overflow:auto; font-family:Consolas,&#39;Lucida Console&#39;,&#39;Andale Mono&#39;,&#39;Bitstream Vera Sans Mono&#39;,&#39;Courier New&#39;,Courier; color:rgb(51,51,51)&#34;&gt;3&#xA;1 0&#xA;5&#xA;4 2&#xA;1 2 3 4&#xA;6 0&#xA;1 1 9 1 1 1&lt;/pre&gt;&#xA;&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;&#xA;&lt;/p&gt;&#xA;&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;&#xA;&lt;/p&gt;&#xA;&lt;h3 style=&#34;margin:0px; padding:0px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; line-height:20px; background-color:rgb(247,247,247)&#34;&gt;&#xA;    Sample Output&#xA;&lt;/h3&gt;&#xA;&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;&#xA;&lt;/p&gt;&#xA;&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;&#xA;&lt;/p&gt;&#xA;&lt;pre style=&#34;margin-top:0px; margin-bottom:0px; padding:5px; background-color:rgb(224,224,224); font-size:14px; line-height:16px; overflow:auto; font-family:Consolas,&#39;Lucida Console&#39;,&#39;Andale Mono&#39;,&#39;Bitstream Vera Sans Mono&#39;,&#39;Courier New&#39;,Courier; color:rgb(51,51,51)&#34;&gt;1&#xA;2&#xA;5&lt;/pre&gt;&#xA;&lt;br /&gt;&#xA;&#xA;&lt;p&gt;&#xA;    &lt;span style=&#34;font-size:24px&#34;&gt;题解：&lt;/span&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;&#xA;    &lt;span style=&#34;font-size:24px&#34;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;/span&gt;&lt;span style=&#34;font-size:18px&#34;&gt;模拟个队列&lt;/span&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;&#xA;    &lt;span style=&#34;font-size:18px&#34;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 要注意 当front 找到 rear 没有比它大的点 time++&lt;/span&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;&#xA;    &lt;span style=&#34;font-size:18px&#34;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;如果这个点是自己的那个点，直接输出。&lt;/span&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;&#xA;    &lt;span style=&#34;font-size:18px&#34;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 另外如果front指向的是自己的点，不能打印的话，标记位置也得跟着变 m = rear - 1&lt;/span&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;&#xA;    &lt;span style=&#34;font-size:18px&#34;&gt;&lt;br /&gt;&#xA;    &lt;/span&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;&#xA;    &lt;span style=&#34;font-size:18px&#34;&gt;&lt;/span&gt;&#xA;&lt;/p&gt;&#xA;&lt;pre name=&#34;code&#34; class=&#34;cpp&#34;&gt;#include &amp;lt;cstdio&amp;gt;&#xA;#include &amp;lt;cstdlib&amp;gt;&#xA;#include &amp;lt;cstring&amp;gt;&#xA;int front,rear;&#xA;int q[10005];&#xA;int main(){&#xA;    int cases,time,n,m,ok;&#xA;    scanf(&amp;quot;%d&amp;quot;,&amp;amp;cases);&#xA;    while(cases--){&#xA;        front = rear = 0;&#xA;        time = 0;&#xA;        scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;m);&#xA;        for(int i = 0; i &amp;lt; n; i++){&#xA;            scanf(&amp;quot;%d&amp;quot;,&amp;amp;q[i]);&#xA;            rear++;&#xA;        }&#xA;        while(front &amp;lt;= rear){&#xA;            int i;&#xA;            for(i = front; i &amp;lt; rear; i++)&#xA;                if(q[i] &amp;gt; q[front]){&#xA;                    q[rear++] = q[front];&#xA;                    break;&#xA;                }&#xA;            if(i &amp;gt;= rear){&#xA;                time += 1;&#xA;                if(front == m){&#xA;                    printf(&amp;quot;%d\n&amp;quot;,time);&#xA;                    break;&#xA;                }&#xA;                else&#xA;                    front ++;&#xA;            }&#xA;            else if(front == m) &#xA;                m = rear - 1;&#xA;            else &#xA;                front++;&#xA;        }&#xA;    }&#xA;    return 0;&#xA;}&#xA;&#xA;        &#xA;&lt;/pre&gt;&#xA;&lt;br /&gt;&#xA;&lt;br /&gt;&#xA;&#xA;&lt;p&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;&#xA;    &lt;span style=&#34;font-size:18px&#34;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;/span&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;&#xA;    &lt;br /&gt;&#xA;    &#xA;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>HOJ 2385 Cube Stacking</title>
      <link>http://pokerg.github.io/ACM/HOJ-2385-Cube-Stacking/</link>
      <pubDate>2013-04-09 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&#xA;&lt;/p&gt;&#xA;&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;&#xA;    Farmer John and Betsy are playing a game with N (1 &amp;lt;= N &amp;lt;= 30,000)identical cubes labeled 1 through N. They start with N stacks, each containing a single cube. Farmer John asks Betsy to perform P (1&amp;lt;= P &amp;lt;= 100,000) operation. There are two types of operations: moves and counts.&#xA;&lt;/p&gt;&#xA;&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;&#xA;&lt;/p&gt;&#xA;&lt;ul style=&#34;margin:0px; padding:15px 0px 15px 30px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; font-size:16px; line-height:20px; background-color:rgb(247,247,247)&#34;&gt;&#xA;    &lt;li style=&#34;margin:0px; padding:0px&#34;&gt;&#xA;        In a move operation, Farmer John asks Bessie to move the stack containing cube X on top of the stack containing cube Y.&#xA;    &lt;/li&gt;&#xA;    &lt;li style=&#34;margin:0px; padding:0px&#34;&gt;&#xA;        In a count operation, Farmer John asks Bessie to count the number of cubes on the stack with cube X that are under the cube X and report that value.&#xA;    &lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;&#xA;    Write a program that can verify the results of the game.&#xA;&lt;/p&gt;&#xA;&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;&#xA;    &lt;span style=&#34;margin:0px; padding:0px; font-size:18px; line-height:28px&#34;&gt;Input&lt;/span&gt;&#xA;&lt;/p&gt;&#xA;&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;&#xA;    * Line 1: A single integer, P&#xA;&lt;/p&gt;&#xA;&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;&#xA;    * Lines 2..P+1: Each of these lines describes a legal operation. Line 2 describes the first operation, etc. Each line begins with a &#39;M&#39; for a move operation or a &#39;C&#39; for a count operation. For move operations, the line also contains two integers: X and Y.For count operations, the line also contains a single integer: X.&#xA;&lt;/p&gt;&#xA;&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;&#xA;    Note that the value for N does not appear in the input file. No move operation will request a move a stack onto itself.&#xA;&lt;/p&gt;&#xA;&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;&#xA;    &lt;span style=&#34;margin:0px; padding:0px; font-size:18px; line-height:28px&#34;&gt;Output&lt;/span&gt;&#xA;&lt;/p&gt;&#xA;&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;&#xA;    Print the output from each of the count operations in the same order as the input file.&#xA;&lt;/p&gt;&#xA;&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;&#xA;    &lt;span style=&#34;margin:0px; padding:0px; font-size:18px; line-height:28px&#34;&gt;Sample Input&lt;/span&gt;&#xA;&lt;/p&gt;&#xA;&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;&#xA;&lt;/p&gt;&#xA;&lt;pre style=&#34;margin-top:0px; margin-bottom:0px; padding:5px; background-color:rgb(224,224,224); font-size:14px; line-height:16px; overflow:auto; font-family:Consolas,&#39;Lucida Console&#39;,&#39;Andale Mono&#39;,&#39;Bitstream Vera Sans Mono&#39;,&#39;Courier New&#39;,Courier; color:rgb(51,51,51)&#34;&gt;6&#xA;M 1 6&#xA;C 1&#xA;M 2 4&#xA;M 2 6&#xA;C 3&#xA;C 4&lt;/pre&gt;&#xA;&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;&#xA;    &lt;span style=&#34;margin:0px; padding:0px; font-size:18px; line-height:28px&#34;&gt;Sample Output&lt;/span&gt;&#xA;&lt;/p&gt;&#xA;&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;&#xA;&lt;/p&gt;&#xA;&lt;pre style=&#34;margin-top:0px; margin-bottom:0px; padding:5px; background-color:rgb(224,224,224); font-size:14px; line-height:16px; overflow:auto; font-family:Consolas,&#39;Lucida Console&#39;,&#39;Andale Mono&#39;,&#39;Bitstream Vera Sans Mono&#39;,&#39;Courier New&#39;,Courier; color:rgb(51,51,51)&#34;&gt;1&#xA;0&#xA;2&lt;/pre&gt;&#xA;&lt;br /&gt;&#xA;&#xA;&lt;p&gt;&#xA;    &lt;span style=&#34;font-size:24px&#34;&gt;题解：&lt;/span&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;&#xA;    &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &lt;span style=&#34;font-size:18px&#34;&gt;并查集，并记录i元素上面和下面的元素个数&lt;/span&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;&#xA;&lt;/p&gt;&#xA;&lt;pre name=&#34;code&#34; class=&#34;cpp&#34;&gt;#include &amp;lt;cstdio&amp;gt;&#xA;#include &amp;lt;cstdlib&amp;gt;&#xA;#include &amp;lt;cstring&amp;gt;&#xA;const int N = 30005;&#xA;int set[N];&#xA;int high[N]; //i元素上面（加上i）的元素个数 &#xA;int low[N];  //i元素下面的元素个数 &#xA;int findset(int x){&#xA;    if(x == set[x])&#xA;        return set[x];&#xA;    int tm = set[x];&#xA;    set[x] = findset(set[x]);&#xA;    low[x] += low[tm];&#xA;    return set[x];&#xA;}&#xA;void unionset(int x,int y){&#xA;    int fx = findset(x);&#xA;    int fy = findset(y);&#xA;    if( fx == fy)&#xA;        return ;&#xA;    set[fx] = fy;&#xA;    low[fx] += high[fy];&#xA;    high[fy] += high[fx];&#xA;}&#xA;int main(){&#xA;    int n;&#xA;    while(scanf(&amp;quot;%d&amp;quot;,&amp;amp;n) != EOF){&#xA;        for(int i = 1; i &amp;lt;= N; i++){&#xA;            set[i] = i;&#xA;                 high[i] = 1;&#xA;        }&#xA;        memset(low,0,sizeof(low));&#xA;        char op;&#xA;        int x,y;&#xA;        getchar();&#xA;        for(int i =1 ; i &amp;lt;= n; i++){&#xA;            scanf(&amp;quot;%c&amp;quot;,&amp;amp;op);&#xA;            if(op == &#39;C&#39;){&#xA;                scanf(&amp;quot;%d&amp;quot;,&amp;amp;x);&#xA;                findset(x);&#xA;                printf(&amp;quot;%d\n&amp;quot;,low[x]);&#xA;            }&#xA;            else{&#xA;                scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;x,&amp;amp;y);&#xA;                unionset(x,y);&#xA;            }&#xA;            getchar();&#xA;        }&#xA;    }&#xA;    return 0;&#xA;}&#xA;&#xA;&#xA;&#xA;&#xA;&lt;/pre&gt;&#xA;&lt;br /&gt;&#xA;&lt;br /&gt;&#xA;&#xA;&lt;p&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;&#xA;    &lt;br /&gt;&#xA;    &#xA;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>HOJ 2033 Ubiquitous Religions</title>
      <link>http://pokerg.github.io/ACM/HOJ-2033-Ubiquitous-Religions/</link>
      <pubDate>2013-04-09 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&#xA;&#x9;&lt;span style=&#34;background-color:rgb(247,247,247); color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; font-size:14px; line-height:20px&#34;&gt;There are so many different religions in the world today that it is difficult to keep track of them all. You are interested in finding out how many different religions students in your university believe in.&lt;/span&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;&#xA;&lt;/p&gt;&#xA;&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;&#xA;&#x9;You know that there are n students in your university (0&amp;nbsp;&amp;lt;&amp;nbsp;&lt;span style=&#34;margin:0px; padding:0px&#34;&gt;n&lt;/span&gt;&amp;nbsp;≤&amp;nbsp;50000). It is infeasible for you to ask every student their religious beliefs. Furthermore, many students are not comfortable expressing their beliefs. One way to avoid these problems is to ask&amp;nbsp;&lt;span style=&#34;margin:0px; padding:0px&#34;&gt;m&lt;/span&gt;&amp;nbsp;(0&amp;nbsp;≤&amp;nbsp;&lt;span style=&#34;margin:0px; padding:0px&#34;&gt;m&lt;/span&gt;&amp;nbsp;≤&amp;nbsp;&amp;nbsp;&lt;span style=&#34;margin:0px; padding:0px&#34;&gt;n&lt;/span&gt;(&lt;span style=&#34;margin:0px; padding:0px&#34;&gt;n&lt;/span&gt;-1)/2) pairs of students and ask them whether they believe in the same religion (e.g. they may know if they both attend the same church). From this data, you may not know what each person believes in, but you can get an idea of the upper bound of how many different religions can be possibly represented on campus. You may assume that each student subscribes to at most one religion.&#xA;&lt;/p&gt;&#xA;&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;&#xA;&#x9;The input consists of a number of cases. Each case starts with a line specifying the integers&amp;nbsp;&lt;span style=&#34;margin:0px; padding:0px&#34;&gt;n&lt;/span&gt;and&amp;nbsp;&lt;span style=&#34;margin:0px; padding:0px&#34;&gt;m&lt;/span&gt;. The next&amp;nbsp;&lt;span style=&#34;margin:0px; padding:0px&#34;&gt;m&lt;/span&gt;&amp;nbsp;lines each consists of two integers i and j, specifying that students i and j believe in the same religion. The students are numbered 1 to&amp;nbsp;&lt;span style=&#34;margin:0px; padding:0px&#34;&gt;n&lt;/span&gt;. The end of input is specified by a line in which&amp;nbsp;&lt;span style=&#34;margin:0px; padding:0px&#34;&gt;n&lt;/span&gt;&amp;nbsp;=&amp;nbsp;&lt;span style=&#34;margin:0px; padding:0px&#34;&gt;m&lt;/span&gt;&amp;nbsp;= 0.&#xA;&lt;/p&gt;&#xA;&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;&#xA;&#x9;For each test case, print on a single line the case number (starting with 1) followed by the maximum number of different religions that the students in the university believe in.&#xA;&lt;/p&gt;&#xA;&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;&#xA;&#x9;&lt;span style=&#34;margin:0px; padding:0px; font-size:18px; line-height:28px&#34;&gt;Sample Input&lt;/span&gt;&#xA;&lt;/p&gt;&#xA;&lt;pre style=&#34;margin-top:0px; margin-bottom:0px; padding:5px; background-color:rgb(224,224,224); font-size:14px; line-height:16px; overflow:auto; font-family:Consolas,&#39;Lucida Console&#39;,&#39;Andale Mono&#39;,&#39;Bitstream Vera Sans Mono&#39;,&#39;Courier New&#39;,Courier; color:rgb(51,51,51)&#34;&gt;10 9&#xA;1 2&#xA;1 3&#xA;1 4&#xA;1 5&#xA;1 6&#xA;1 7&#xA;1 8&#xA;1 9&#xA;1 10&#xA;10 4&#xA;2 3&#xA;4 5&#xA;4 8&#xA;5 8&#xA;0 0&#xA;&lt;/pre&gt;&#xA;&lt;span style=&#34;margin:0px; padding:0px; font-size:18px; line-height:28px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;Sample Output&lt;/span&gt;&lt;span style=&#34;color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; font-size:16px; line-height:20px; background-color:rgb(247,247,247)&#34;&gt;&lt;/span&gt;&#xA;&lt;pre style=&#34;margin-top:0px; margin-bottom:0px; padding:5px; background-color:rgb(224,224,224); font-size:14px; line-height:16px; overflow:auto; font-family:Consolas,&#39;Lucida Console&#39;,&#39;Andale Mono&#39;,&#39;Bitstream Vera Sans Mono&#39;,&#39;Courier New&#39;,Courier; color:rgb(51,51,51)&#34;&gt;Case 1: 1&#xA;Case 2: 7&#xA;&lt;/pre&gt;&#xA;&lt;hr style=&#34;margin:0px; padding:0px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; font-size:16px; line-height:20px; background-color:rgb(247,247,247)&#34; /&gt;&#xA;&lt;span style=&#34;color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; font-size:16px; line-height:20px; background-color:rgb(247,247,247)&#34;&gt;Author:&amp;nbsp;&lt;/span&gt;&lt;span style=&#34;margin:0px; padding:0px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; font-size:16px; line-height:20px; background-color:rgb(247,247,247)&#34;&gt;Howard Cheng&lt;/span&gt;&lt;br /&gt;&#xA;&#xA;&lt;p&gt;&#xA;&#x9;&lt;span style=&#34;margin:0px; padding:0px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; font-size:16px; line-height:20px; background-color:rgb(247,247,247)&#34;&gt;&lt;br /&gt;&#xA;&#x9;&lt;/span&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;&#xA;&#x9;&lt;span style=&#34;margin:0px; padding:0px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; line-height:20px; background-color:rgb(247,247,247)&#34;&gt;&lt;span style=&#34;font-size:24px&#34;&gt;题解：&lt;/span&gt;&lt;/span&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;&#xA;&#x9;&lt;span style=&#34;margin:0px; padding:0px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; line-height:20px; background-color:rgb(247,247,247)&#34;&gt;&lt;span style=&#34;font-size:24px&#34;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;/span&gt;&lt;span style=&#34;font-size:18px&#34;&gt;并查集，判断有多少个祖先，用一个数组记录访问状态即可。&lt;/span&gt;&lt;/span&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;&#xA;&#x9;&lt;span style=&#34;margin:0px; padding:0px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; line-height:20px; background-color:rgb(247,247,247)&#34;&gt;&lt;span style=&#34;font-size:18px&#34;&gt;&lt;br /&gt;&#xA;&#x9;&lt;/span&gt;&lt;/span&gt;&#xA;&lt;/p&gt;&#xA;&lt;pre name=&#34;code&#34; class=&#34;cpp&#34;&gt;#include &amp;lt;cstdio&amp;gt;&#xA;#include &amp;lt;cstdlib&amp;gt;&#xA;#include &amp;lt;cstring&amp;gt;&#xA;int set[50005];&#xA;bool vis[50005];&#xA;int findset(int x){&#xA;&#x9;if(x == set[x])&#xA;&#x9;   return x;&#xA;&#x9;set[x] = findset(set[x]);&#xA;&#x9;return set[x];&#xA;}&#xA;int main(){&#xA;&#x9;int n,m;&#xA;&#x9;int cases = 0;&#xA;&#x9;while(scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;m) &amp;amp;&amp;amp; n &amp;amp;&amp;amp; m){&#xA;&#x9;&#x9;cases ++;&#xA;&#x9;&#x9;for(int i = 1; i &amp;lt;= n; i++)&#xA;&#x9;&#x9;&#x9;set[i] = i;&#xA;&#x9;        int fx,fy;&#xA;&#x9;        for(int i = 1; i &amp;lt;= m; i++){&#xA;&#x9;&#x9;        scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;fx,&amp;amp;fy);&#xA;&#x9;&#x9;        fx = findset(fx);&#xA;&#x9;&#x9;        fy = findset(fy);&#xA;&#x9;&#x9;        if(fx &amp;lt; fy)&#xA;&#x9;&#x9;&#x9;     set[fy] = fx;&#xA;&#x9;&#x9;        else&#xA;&#x9;&#x9;&#x9;     set[fx] = fy;&#xA;&#x9;&#x9;}&#xA;&#x9;        memset(vis,false,sizeof(vis));&#xA;&#x9;        int res = 0;&#xA;&#x9;        for(int i = 1; i &amp;lt;= n; i++){&#xA;&#x9;&#x9;         if(vis[findset(i)] == false){&#xA;                     res ++;&#xA;&#x9;&#x9;             vis[findset(i)] = true;&#xA;&#x9;&#x9;&#x9; }&#xA;&#x9;&#x9;}&#xA;                printf(&amp;quot;Case %d: %d\n&amp;quot;,cases,res);&#xA;&#x9;}&#xA;        return 0;&#xA;}&#x9;&#xA;&lt;/pre&gt;&#xA;&lt;br /&gt;&#xA;&lt;br /&gt;&#xA;&lt;br /&gt;&#xA;&lt;br /&gt;&#xA;&#xA;&lt;p&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;&#xA;&#x9;&lt;span style=&#34;margin:0px; padding:0px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; line-height:20px; background-color:rgb(247,247,247)&#34;&gt;&lt;span style=&#34;font-size:24px&#34;&gt;&lt;br /&gt;&#xA;&#x9;&lt;/span&gt;&lt;/span&gt;&#xA;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>HOJ 1031 Piggy-Bank</title>
      <link>http://pokerg.github.io/ACM/HOJ-1031-Piggy-Bank/</link>
      <pubDate>2013-04-09 12:00:00 +0800</pubDate>
      <description>&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;&#xA;&#x9;Before ACM can do anything, a&amp;nbsp;budget must be prepared and the necessary financial support obtained. The main income for this action comes from Irreversibly Bound Money (IBM). The idea behind is simple. Whenever some ACM member has any small money, he takes all the coins and throws them into a piggy-bank. You know that this process is irreversible, the coins cannot be removed without breaking the pig. After a sufficiently long time, there should be enough cash in the piggy-bank to pay everything that needs to be paid.&#xA;&lt;/p&gt;&#xA;&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;&#xA;&#x9;But there is a big problem with piggy-banks. It is not possible to determine how much money is inside. So we might break the pig into pieces only to find out that there is not enough money. Clearly, we want to avoid this unpleasant situation. The only possibility is to weigh the piggy-bank and try to guess how many coins are inside. Assume that we are able to determine the weight of the pig exactly and that we know the weights of all coins of a given currency. Then there is some minimum amount of money in the piggy-bank that we can guarantee. Your task is to find out this worst case and determine the minimum amount of cash inside the piggy-bank. We need your help. No more prematurely broken pigs!&#xA;&lt;/p&gt;&#xA;&lt;span style=&#34;margin:0px; padding:0px; font-size:18px; line-height:28px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;Input Specification&lt;/span&gt;&lt;span style=&#34;color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; font-size:16px; line-height:20px; background-color:rgb(247,247,247)&#34;&gt;&lt;/span&gt;&#xA;&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;&#xA;&#x9;The input consists of&amp;nbsp;&lt;var style=&#34;margin:0px; padding:0px&#34;&gt;T&lt;/var&gt;&amp;nbsp;test cases. The number of them (&lt;var style=&#34;margin:0px; padding:0px&#34;&gt;T&lt;/var&gt;) is given on the first line of the input file. Each test case begins with a line containing two integers&amp;nbsp;&lt;var style=&#34;margin:0px; padding:0px&#34;&gt;E&lt;/var&gt;&amp;nbsp;and&amp;nbsp;&lt;var style=&#34;margin:0px; padding:0px&#34;&gt;F&lt;/var&gt;. They indicate the weight of an empty pig and of the pig filled with coins. Both weights are given in grams. No pig will weigh more than 10 kg, that means&amp;nbsp;&lt;var style=&#34;margin:0px; padding:0px&#34;&gt;1 &amp;lt;= E &amp;lt;= F &amp;lt;= 10000&lt;/var&gt;. On the second line of each test case, there is an integer number&amp;nbsp;&lt;var style=&#34;margin:0px; padding:0px&#34;&gt;N&lt;/var&gt;&amp;nbsp;(&lt;var style=&#34;margin:0px; padding:0px&#34;&gt;1 &amp;lt;= N &amp;lt;= 500&lt;/var&gt;) that gives the number of various coins used in the given currency. Following this are exactly&amp;nbsp;&lt;var style=&#34;margin:0px; padding:0px&#34;&gt;N&lt;/var&gt;&amp;nbsp;lines, each specifying one coin type. These lines contain two integers each,&amp;nbsp;&lt;var style=&#34;margin:0px; padding:0px&#34;&gt;P&lt;/var&gt;and&amp;nbsp;&lt;var style=&#34;margin:0px; padding:0px&#34;&gt;W&lt;/var&gt;&amp;nbsp;(&lt;var style=&#34;margin:0px; padding:0px&#34;&gt;1 &amp;lt;= P &amp;lt;= 50000&lt;/var&gt;,&amp;nbsp;&lt;var style=&#34;margin:0px; padding:0px&#34;&gt;1 &amp;lt;= W &amp;lt;=10000&lt;/var&gt;).&amp;nbsp;&lt;var style=&#34;margin:0px; padding:0px&#34;&gt;P&lt;/var&gt;&amp;nbsp;is the value of the coin in monetary units,&amp;nbsp;&lt;var style=&#34;margin:0px; padding:0px&#34;&gt;W&lt;/var&gt;&amp;nbsp;is it&#39;s weight in grams.&#xA;&lt;/p&gt;&#xA;&lt;span style=&#34;margin:0px; padding:0px; font-size:18px; line-height:28px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;Output Specification&lt;/span&gt;&lt;span style=&#34;color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; font-size:16px; line-height:20px; background-color:rgb(247,247,247)&#34;&gt;&lt;/span&gt;&#xA;&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;&#xA;&#x9;Print exactly one line of output for each test case. The line must contain the&amp;nbsp;sentence &amp;quot;&lt;code style=&#34;margin:0px; padding:0px&#34;&gt;The minimum amount of money in the piggy-bank is&amp;nbsp;&lt;var style=&#34;margin:0px; padding:0px&#34;&gt;X&lt;/var&gt;.&lt;/code&gt;&amp;nbsp;where&amp;nbsp;&lt;var style=&#34;margin:0px; padding:0px&#34;&gt;X&lt;/var&gt;&amp;nbsp;is the minimum amount of money that can be achieved using coins with the given total weight. If the weight cannot be reached exactly, print a&amp;nbsp;line &amp;quot;&lt;code style=&#34;margin:0px; padding:0px&#34;&gt;This is impossible.&lt;/code&gt;.&#xA;&lt;/p&gt;&#xA;&lt;span style=&#34;margin:0px; padding:0px; font-size:18px; line-height:28px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;Sample Input:&lt;/span&gt;&#xA;&lt;pre style=&#34;margin-top:0px; margin-bottom:0px; padding:5px; background-color:rgb(224,224,224); font-size:14px; line-height:16px; overflow:auto; font-family:Consolas,&#39;Lucida Console&#39;,&#39;Andale Mono&#39;,&#39;Bitstream Vera Sans Mono&#39;,&#39;Courier New&#39;,Courier; color:rgb(51,51,51)&#34;&gt;3&#xA;10 110&#xA;2&#xA;1 1&#xA;30 50&#xA;10 110&#xA;2&#xA;1 1&#xA;50 30&#xA;1 6&#xA;2&#xA;10 3&#xA;20 4&#xA;&lt;/pre&gt;&#xA;&lt;span style=&#34;margin:0px; padding:0px; font-size:18px; line-height:28px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;Sample Output:&lt;/span&gt;&#xA;&lt;pre style=&#34;margin-top:0px; margin-bottom:0px; padding:5px; background-color:rgb(224,224,224); font-size:14px; line-height:16px; overflow:auto; font-family:Consolas,&#39;Lucida Console&#39;,&#39;Andale Mono&#39;,&#39;Bitstream Vera Sans Mono&#39;,&#39;Courier New&#39;,Courier; color:rgb(51,51,51)&#34;&gt;The minimum amount of money in the piggy-bank is 60.&#xA;The minimum amount of money in the piggy-bank is 100.&#xA;This is impossible.&lt;/pre&gt;&#xA;&lt;p&gt;&#xA;&#x9;&lt;span style=&#34;font-size:24px&#34;&gt;&lt;br /&gt;&#xA;&#x9;&lt;/span&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;&#xA;&#x9;&lt;span style=&#34;font-size:24px&#34;&gt;题解：&lt;/span&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;&#xA;&#x9;&lt;span style=&#34;font-size:24px&#34;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;/span&gt;&lt;span style=&#34;font-size:18px&#34;&gt;完全背包问题,可以看看《背包问题九讲》&lt;/span&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;&#xA;&#x9;&lt;span style=&#34;font-size:18px&#34;&gt;&lt;/span&gt;&#xA;&lt;/p&gt;&#xA;&lt;pre name=&#34;code&#34; class=&#34;cpp&#34;&gt;#include &amp;lt;cstdio&amp;gt;&#xA;#include &amp;lt;cstdlib&amp;gt;&#xA;#include &amp;lt;cstring&amp;gt;&#xA;const int N = 505;&#xA;const int inf = 1000000000;&#xA;int w[N],p[N];&#xA;int dp[10005];&#xA;int main(){&#xA;&#x9;int cases,e,f,n;&#xA;&#x9;scanf(&amp;quot;%d&amp;quot;,&amp;amp;cases);&#xA;&#x9;while(cases --){&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;e,&amp;amp;f);&#xA;&#x9;&#x9;for(int i = 1; i &amp;lt;= f; i ++)&#xA;&#x9;&#x9;   dp[i] = inf;&#xA;        dp[0] = 0;&#xA;&#x9;&#x9;f -= e;&#xA;&#x9;&#x9;scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);&#xA;&#x9;&#x9;for(int i = 1; i &amp;lt;= n; i++)&#xA;&#x9;&#x9;&#x9;scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;p[i],&amp;amp;w[i]);&#xA;&#x9;&#x9;for(int i = 1; i &amp;lt;= n ; i++)&#xA;&#x9;&#x9;&#x9;for(int j = w[i]; j &amp;lt;= f; j++)&#xA;&#x9;&#x9;&#x9;&#x9;if(dp[j - w[i]] + p[i] &amp;lt; dp[j]) dp[j] = dp[j - w[i]] + p[i];&#xA;&#x9;&#x9;if(dp[f] == inf) &#xA;&#x9;&#x9;    printf(&amp;quot;This is impossible.\n&amp;quot;);&#xA;&#x9;&#x9;else&#xA;&#x9;&#x9;    printf(&amp;quot;The minimum amount of money in the piggy-bank is %d.\n&amp;quot;,dp[f]);&#x9;        &#xA;&#x9;}&#xA;    return 0;&#xA;}&#x9;&#xA;&#x9;&#x9;&#xA;&lt;/pre&gt;&#xA;&lt;br /&gt;&#xA;&lt;br /&gt;&#xA;&#xA;&lt;p&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;&#xA;&#x9;&lt;br /&gt;&#xA;&#x9;&#xA;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>HOJ 2196 Job Scheduling by Open Bidding</title>
      <link>http://pokerg.github.io/ACM/HOJ-2196-Job-Scheduling-by-Open-Bidding/</link>
      <pubDate>2013-04-07 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;&#xA;    Your team is setting up a computing resource devoted to batch processing of compute-bound jobs. In addition, you have decided to use static scheduling for each period of time. Naturally, you wish to maximize the income for each set of jobs run, and you have been given the responsibility of finding an optimal mix of jobs for each set of candidate jobs. The jobs are submitted by an open bid process: clients will specify the amount of processor time they wish to reserve and the dollar amount that they wish to pay. If a job finishes early, the client will still pay the full amount, and if a job exceeds the requested time, it will be terminated and (of course) the client will still pay the full amount. For purposes of scheduling, your team assumes that each job will in fact use its entire scheduled time slot. In the interests of good customer relations, though, you are not to include a bid in the schedule if there is not sufficient time available to satisfy it — we’re not going to over-book like the airlines do, and then hope someone doesn’t use the full allotment!&#xA;&lt;/p&gt;&#xA;&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;&#xA;    &lt;span style=&#34;margin:0px; padding:0px; font-size:18px; line-height:28px&#34;&gt;Input&lt;/span&gt;&#xA;&lt;/p&gt;&#xA;&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;&#xA;    The input file begins with a line containing a single integer (no white space) specifying the number of problem sets in the file.&#xA;&lt;/p&gt;&#xA;&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;&#xA;    Each problem set consists of (n+2) lines (no white space except as specified):&#xA;&lt;/p&gt;&#xA;&lt;ul style=&#34;margin:0px; padding:15px 0px 15px 30px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; font-size:16px; line-height:20px; background-color:rgb(247,247,247)&#34;&gt;&#xA;    &lt;li style=&#34;margin:0px; padding:0px&#34;&gt;&#xA;        a single integer n (n &amp;lt;= 500) specifying the number of candidate jobs to be schedu&#xA;    &lt;/li&gt;&#xA;    &lt;li style=&#34;margin:0px; padding:0px&#34;&gt;&#xA;        n lines giving the bid as an integer specifying the number of seconds followed by a single space and then a dollar amount given in decimal form (always showing two digits to the right of the decimal point)&#xA;    &lt;/li&gt;&#xA;    &lt;li style=&#34;margin:0px; padding:0px&#34;&gt;&#xA;        a single integer t (t &amp;lt;= 2000) specifying the amount of time to be scheduled with these job&#xA;    &lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;&#xA;    &lt;span style=&#34;margin:0px; padding:0px; font-size:18px; line-height:28px&#34;&gt;Output&lt;/span&gt;&#xA;&lt;/p&gt;&#xA;&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;&#xA;    Each problem set will be numbered (beginning at one) and will generate a single line: Problem&amp;nbsp;:&amp;nbsp;seconds scheduled for $abc.de where&amp;nbsp;is replaced by the problem set number,&amp;nbsp;is replaced with the total time actually scheduled (possibly not the full input time), and $abc.de is replaced by the dollar amount, given always with the leading currency symbol and with two digits to the right of the decimal point. There will be no blank lines, and the final line will end with the new-line character.&#xA;&lt;/p&gt;&#xA;&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;&#xA;    &lt;span style=&#34;margin:0px; padding:0px; font-size:18px; line-height:28px&#34;&gt;Sample Input&lt;/span&gt;&#xA;&lt;/p&gt;&#xA;&lt;pre style=&#34;margin-top:0px; margin-bottom:0px; background-color:rgb(224,224,224); padding:5px; font-size:14px; line-height:16px; overflow:auto; font-family:Consolas,&#39;Lucida Console&#39;,&#39;Andale Mono&#39;,&#39;Bitstream Vera Sans Mono&#39;,&#39;Courier New&#39;,Courier; color:rgb(51,51,51)&#34;&gt;1&#xA;10&#xA;19 0.78&#xA;12 0.31&#xA;17 0.77&#xA;22 0.77&#xA;8 0.56&#xA;10 0.33&#xA;17 0.35&#xA;24 0.12&#xA;22 0.70&#xA;5 0.52&#xA;120&lt;/pre&gt;&#xA;&lt;span style=&#34;margin:0px; padding:0px; font-size:18px; line-height:28px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;Sample Output&lt;/span&gt;&#xA;&lt;pre style=&#34;margin-top:0px; margin-bottom:0px; background-color:rgb(224,224,224); padding:5px; font-size:14px; line-height:16px; overflow:auto; font-family:Consolas,&#39;Lucida Console&#39;,&#39;Andale Mono&#39;,&#39;Bitstream Vera Sans Mono&#39;,&#39;Courier New&#39;,Courier; color:rgb(51,51,51)&#34;&gt;Problem 1: 120 seconds scheduled for $4.78&lt;/pre&gt;&#xA;&lt;p&gt;&#xA;    &lt;strong&gt;&lt;span style=&#34;font-size:32px&#34;&gt;&amp;nbsp;题解：&amp;nbsp;&lt;/span&gt;&lt;/strong&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;&#xA;    &lt;strong&gt;&lt;span style=&#34;font-size:32px&#34;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;span style=&#34;font-size:24px&#34;&gt;基本的01背包问题，直接给代码吧&lt;/span&gt;&lt;/strong&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;&#xA;    &lt;strong&gt;&lt;/strong&gt;&#xA;&lt;/p&gt;&#xA;&lt;pre name=&#34;code&#34; class=&#34;html&#34;&gt;&lt;span style=&#34;font-size: 18px;&#34;&gt;#include &amp;lt;cstdio&amp;gt;&#xA;#include &amp;lt;cstdlib&amp;gt;&#xA;#include &amp;lt;cstring&amp;gt;&#xA;int c[505];&#xA;double w[505];&#xA;double f[2005];&#xA;double w_max(double a,double b){&#xA;    return a &amp;gt; b ? a : b;&#xA;}&#xA;int main(){&#xA;    int cases,n,r = 0;&#xA;    scanf(&amp;quot;%d&amp;quot;,&amp;amp;cases);&#xA;    while(cases&amp;ndash;){&#xA;        r++;&#xA;        memset(f,0,sizeof(f));&#xA;        scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);&#xA;        for(int i = 0; i &amp;lt; n; i++)&#xA;            scanf(&amp;quot;%d %lf&amp;quot;,&amp;amp;c[i],&amp;amp;w[i]);&#xA;        int time;&#xA;        scanf(&amp;quot;%d&amp;quot;,&amp;amp;time);&#xA;        for(int i = 0; i &amp;lt; n; i++)&#xA;            for(int j = time; j &amp;gt;= c[i]; j&amp;ndash;)&#xA;                f[j] = w_max(f[j],f[j - c[i]] + w[i]);&#xA;        int actTime = 0;&#xA;        double maxSum = 0;&#xA;        for(int i = 1; i &amp;lt;= time; i ++)&#xA;            if(f[i] &amp;gt; maxSum)&#xA;                actTime = i, maxSum = f[i];&#xA;        printf(&amp;quot;Problem %d: %d seconds scheduled for $%.2lf\n&amp;quot;,r,actTime,maxSum);&#xA;    }&#xA;    return 0;&#xA;}&lt;/span&gt;&lt;span style=&#34; font-size: 24px;&#34;&gt;&lt;strong&gt;&#xA;&lt;/strong&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>HOJ 1019 Grandpa&#39;s Other Estate</title>
      <link>http://pokerg.github.io/ACM/HOJ-1019-Grandpa%27s-Other-Estate/</link>
      <pubDate>2013-04-02 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;From our previous contest, we know that Kamran the Believer inherited many of his grandpa&amp;rsquo;s belongings. Apparently, his grandpa had been a mathematician in his life with interests in puzzle solving, since he has made Kamran solve another programming problem!&lt;br /&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&#xA;&lt;/p&gt;&#xA;&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;&#xA;    Grandpa had a big garden with many valuable walnut trees. He has written in his will that Kamran can inherit one piece of square shaped land of a given size in the garden, such that its sides be parallel to the x and y axes. Taking advantage of the fact that no other restrictions have been mentioned in the will, Kamran wants to choose the land in which the most number of trees lie. Kamran is too wealthy now and thus too lazy to spend time and solve another algorithmic problem. He has hired you to solve this problem for him.&#xA;&lt;/p&gt;&#xA;&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;&#xA;    You are given the location of all trees in the big garden and the size of the land to choose. You are to write a program to find out where to choose the land so that the most number of trees lie in it. You may consider trees as points in the plane and the land as a square. You are to find the position of the square such that it includes as many points as possible. Note that the points on the border of the square are considered to be inside it.&#xA;&lt;/p&gt;&#xA;&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;&#xA;    &lt;span style=&#34;margin:0px; padding:0px; font-size:18px; line-height:28px&#34;&gt;Input&lt;/span&gt;&lt;br style=&#34;margin:0px; padding:0px&#34; /&gt;&#xA;    The first line of the input file contains a single integer t (1&amp;lt;=t&amp;lt;=10), the number of test cases, followed by the input data for each test case. The first line of each test case contains an integer n (1&amp;lt;=n&amp;lt;=100), the number of trees, and an integer r (1&amp;lt;=r&amp;lt;=1000), the length of the land&#39;s side, followed by n lines, each containing two integers x and y (0&amp;lt;=x , y &amp;lt;= 100,000) representing the coordinates of a walnut tree. Note that all coordinates are pairwise distinct.&#xA;&lt;/p&gt;&#xA;&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;&#xA;    &lt;span style=&#34;margin:0px; padding:0px; font-size:18px; line-height:28px&#34;&gt;Output&lt;/span&gt;&lt;br style=&#34;margin:0px; padding:0px&#34; /&gt;&#xA;    There should be one line per test case containing the maximum number of trees that Kamran can own.&#xA;&lt;/p&gt;&#xA;&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;&#xA;    &lt;span style=&#34;margin:0px; padding:0px; font-size:18px; line-height:28px&#34;&gt;Sample Input&lt;/span&gt;&#xA;&lt;/p&gt;&#xA;&lt;pre style=&#34;margin-top:0px; margin-bottom:0px; padding:5px; background-color:rgb(224,224,224); font-size:14px; line-height:16px; overflow:auto; font-family:Consolas,&#39;Lucida Console&#39;,&#39;Andale Mono&#39;,&#39;Bitstream Vera Sans Mono&#39;,&#39;Courier New&#39;,Courier; color:rgb(51,51,51)&#34;&gt;1&#xA;3 1&#xA;1 2&#xA;2 1&#xA;4 3&lt;/pre&gt;&#xA;&lt;p&gt;&#xA;    &lt;span style=&#34;margin:0px; padding:0px; font-size:18px; line-height:28px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;Sample Output&lt;/span&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;&#xA;    &lt;span style=&#34;margin:0px; padding:0px; font-size:18px; line-height:28px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;&lt;/span&gt;&#xA;&lt;/p&gt;&#xA;&lt;pre style=&#34;margin-top:0px; margin-bottom:0px; background-color:rgb(224,224,224); padding:5px; font-size:14px; line-height:16px; overflow:auto; font-family:Consolas,&#39;Lucida Console&#39;,&#39;Andale Mono&#39;,&#39;Bitstream Vera Sans Mono&#39;,&#39;Courier New&#39;,Courier; color:rgb(51,51,51)&#34;&gt;2&lt;/pre&gt;&#xA;&lt;br /&gt;&#xA;&#xA;&lt;p&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;&#xA;    &lt;span style=&#34;margin:0px; padding:0px; font-size:18px; line-height:28px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;&lt;strong&gt;题解：&lt;/strong&gt;&lt;/span&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;&#xA;    &lt;span style=&#34;margin:0px; padding:0px; font-size:18px; line-height:28px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;&lt;strong&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;只需将正方形从左到右，从上到下扫描一遍，更新res, 即可&lt;/strong&gt;&lt;/span&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;&#xA;    &lt;span style=&#34;margin:0px; padding:0px; font-size:18px; line-height:28px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;&lt;/span&gt;&#xA;&lt;/p&gt;&#xA;&lt;pre name=&#34;code&#34; class=&#34;cpp&#34;&gt;#include &amp;lt;cstdio&amp;gt;&#xA;#include &amp;lt;cstdlib&amp;gt;&#xA;#include &amp;lt;algorithm&amp;gt;&#xA;#include &amp;lt;cmath&amp;gt;&#xA;using namespace std;&#xA;struct point&#xA;{&#xA;    int x,y;&#xA;};&#xA;point p[105];&#xA;bool judge(int x1,int x2,int y2,int y1,point a){&#xA;    if((a.x - x1) * (a.x - x2) &amp;lt;= 0 &amp;amp;&amp;amp; (a.y - y1) * (a.y - y2) &amp;lt;= 0)&#xA;        return true;&#xA;    return false;&#xA;}&#xA;int main(){&#xA;    int t,n,r;&#xA;    scanf(&amp;quot;%d&amp;quot;,&amp;amp;t);&#xA;    while(t--){&#xA;        scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;r);&#xA;        for(int i = 1; i &amp;lt;= n; i++)&#xA;            scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;p[i].x,&amp;amp;p[i].y);&#xA;        int res = 1;&#xA;        int temp;&#xA;        for(int i = 1; i &amp;lt;= n; i ++)&#xA;            for(int j = i + 1; j &amp;lt;= n; j ++){&#xA;                if (abs(p[i].x - p[j].x) &amp;gt; r || abs(p[i].y - p[j].y) &amp;gt; r)continue;&#xA;                int tx = min(p[i].x,p[j].x);&#xA;                int ty = max(p[i].y,p[j].y);&#xA;                temp = 0;&#xA;                for(int k = 1; k &amp;lt;= n; k++)&#xA;                    if(judge(tx,tx + r, ty , ty - r,p[k]))&#xA;                        temp ++;&#xA;                res = max(res,temp);&#xA;            }&#xA;        printf(&amp;quot;%d\n&amp;quot;,res);&#xA;    }&#xA;    return 0;&#xA;}&lt;/pre&gt;&#xA;&lt;br /&gt;&#xA;&lt;br /&gt;&#xA;&#xA;&lt;p&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;&#xA;    &lt;span style=&#34;margin:0px; padding:0px; font-size:18px; line-height:28px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;&lt;br /&gt;&#xA;    &lt;/span&gt;&#xA;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>转： HOJ 1016 Joseph&#39;s problem I</title>
      <link>http://pokerg.github.io/ACM/%E8%BD%AC%EF%BC%9A-HOJ-1016-Joseph%27s-problem-I/</link>
      <pubDate>2013-03-28 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;div style=&#34;&#34;&gt;&#xA;    &lt;div id=&#34;sina_keyword_ad_area2&#34; style=&#34;line-height:25px&#34;&gt;&#xA;        &lt;div style=&#34;line-height:25px&#34;&gt;&#xA;            先说说经典的Joseph问题吧，说有n个要被处决的人（编号0~(n-1))，从0开始报数，报到(m-1)的会被杀掉，剩下的人继续从0开始报数，如此下去最后剩的一个人会存活下来。说Joseph发现了这个规律而且把他透露了出来，现在假如你在这n个人里面，你会选择几号位置站下。&#xA;            &lt;p style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px 0px 10px; line-height:25px; padding-right:0px&#34;&gt;&#xA;                　　很显然你会选择能活下来的那个位置，所以问题就是如何得到这个位置。&#xA;            &lt;/p&gt;&#xA;            &lt;p style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px 0px 10px; line-height:25px; padding-right:0px&#34;&gt;&#xA;                　　首先想到的是模拟(至少我笨脑子是这么想的)，但无论是用链表还是用数组这个时间复杂度都是比较高的，至少交题的时候会TLE，这里介绍一种线性时间的解法，出自大师Knuth的哦。&#xA;            &lt;/p&gt;&#xA;            &lt;p style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px 0px 10px; line-height:25px; padding-right:0px&#34;&gt;&#xA;                　　考虑下第一次杀人的时候，编号为k = (m - 1) % n的同学挂了，那我们从k + 1重新从0开始编号&#xA;            &lt;/p&gt;&#xA;            &lt;p style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px 0px 10px; line-height:25px; padding-right:0px&#34;&gt;&#xA;                　　k + 1 ==&amp;gt; 0&#xA;            &lt;/p&gt;&#xA;            &lt;p style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px 0px 10px; line-height:25px; padding-right:0px&#34;&gt;&#xA;                　　k + 2 ==&amp;gt; 1&#xA;            &lt;/p&gt;&#xA;            &lt;p style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px 0px 10px; line-height:25px; padding-right:0px&#34;&gt;&#xA;                　　……&#xA;            &lt;/p&gt;&#xA;            &lt;p style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px 0px 10px; line-height:25px; padding-right:0px&#34;&gt;&#xA;                　　……&#xA;            &lt;/p&gt;&#xA;            &lt;p style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px 0px 10px; line-height:25px; padding-right:0px&#34;&gt;&#xA;                　　k - 2 ==&amp;gt; n - 2&#xA;            &lt;/p&gt;&#xA;            &lt;p style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px 0px 10px; line-height:25px; padding-right:0px&#34;&gt;&#xA;                　　k - 1 ==&amp;gt; n - 1&#xA;            &lt;/p&gt;&#xA;            &lt;p style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px 0px 10px; line-height:25px; padding-right:0px&#34;&gt;&#xA;                　　好了，剩余的n - 1个同学又组成了一个新的Joseph环，对新环来说，编号k = (m - 1) % (n - 1)的同学会挂，如此下去，这里面似乎有某种规律可寻。&#xA;            &lt;/p&gt;&#xA;            &lt;p style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px 0px 10px; line-height:25px; padding-right:0px&#34;&gt;&#xA;                　　考虑到不会死的同学一直不会被杀(废话)，我们设i个同学时的不会挂的同学的编号(即解)为x，那么当死掉一个同学剩余i - 1个同学的时候，x仍然不会被杀，但此时的x已经由编号变换变成了x’，即x’是i - 1的情况时的解！一直推下去直到i - (i - 1)即1的情况，那1的时候解明显是0嘛！(注意编号是从0开始的)，倒推回来，那问题不就解决了么！&#xA;            &lt;/p&gt;&#xA;            &lt;p style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px 0px 10px; line-height:25px; padding-right:0px&#34;&gt;&#xA;                　　好了，分析清楚了剩下的就只是数学推导了，这个我比较烦，直接给公式吧：&#xA;            &lt;/p&gt;&#xA;            &lt;p style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px 0px 10px; line-height:25px; padding-right:0px&#34;&gt;&#xA;                　　向下变换：x’ = (x - (k + 1)) % i;&#xA;            &lt;/p&gt;&#xA;            &lt;p style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px 0px 10px; line-height:25px; padding-right:0px&#34;&gt;&#xA;                　　向上变换：x = (x + k + 1) % i;&#xA;            &lt;/p&gt;&#xA;            &lt;p style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px 0px 10px; line-height:25px; padding-right:0px&#34;&gt;&#xA;                　　其中：　　k = (m - 1) % i;&#xA;            &lt;/p&gt;&#xA;            &lt;p style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px 0px 10px; line-height:25px; padding-right:0px&#34;&gt;&#xA;                　　带入可得：x = (x’ + m) % i;&#xA;            &lt;/p&gt;&#xA;            &lt;p style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px 0px 10px; line-height:25px; padding-right:0px&#34;&gt;&#xA;                　　OK，现在应该很好写代码了：&#xA;            &lt;/p&gt;&#xA;            &lt;p style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px 0px 10px; line-height:25px; padding-right:0px&#34;&gt;　　&#xA;                &lt;code style=&#34;line-height:25px&#34;&gt;&lt;span style=&#34;font-family:新宋体; line-height:25px&#34;&gt;int Joseph(int n,int m)&lt;br style=&#34;line-height:25px&#34; /&gt;&#xA;                　　{&lt;br style=&#34;line-height:25px&#34; /&gt;&#xA;                &amp;nbsp;&lt;wbr style=&#34;line-height:25px&#34;&gt;&amp;nbsp;&lt;wbr style=&#34;line-height:25px&#34;&gt;&amp;nbsp;&lt;wbr style=&#34;line-height:25px&#34;&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;　　int i,result;&lt;br style=&#34;line-height:25px&#34; /&gt;&#xA;                &amp;nbsp;&lt;wbr style=&#34;line-height:25px&#34;&gt;&amp;nbsp;&lt;wbr style=&#34;line-height:25px&#34;&gt;&lt;br style=&#34;line-height:25px&#34; /&gt;&#xA;                &amp;nbsp;&lt;wbr style=&#34;line-height:25px&#34;&gt;&amp;nbsp;&lt;wbr style=&#34;line-height:25px&#34;&gt;&amp;nbsp;&lt;wbr style=&#34;line-height:25px&#34;&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;　　for (i = 1,result = 0;i &amp;lt; n;i++)&lt;br style=&#34;line-height:25px&#34; /&gt;&#xA;                &amp;nbsp;&lt;wbr style=&#34;line-height:25px&#34;&gt;&amp;nbsp;&lt;wbr style=&#34;line-height:25px&#34;&gt;&amp;nbsp;&lt;wbr style=&#34;line-height:25px&#34;&gt;&amp;nbsp;&lt;wbr style=&#34;line-height:25px&#34;&gt;&amp;nbsp;&lt;wbr style=&#34;line-height:25px&#34;&gt;&amp;nbsp;&lt;wbr style=&#34;line-height:25px&#34;&gt;&amp;nbsp;&lt;wbr style=&#34;line-height:25px&#34;&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;　　result = (result + m) % i;&lt;br style=&#34;line-height:25px&#34; /&gt;&#xA;                &amp;nbsp;&lt;wbr style=&#34;line-height:25px&#34;&gt;&amp;nbsp;&lt;wbr style=&#34;line-height:25px&#34;&gt;&amp;nbsp;&lt;wbr style=&#34;line-height:25px&#34;&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;　　return result;&lt;br style=&#34;line-height:25px&#34; /&gt;&#xA;                　　}&lt;/wbr&gt;&lt;/wbr&gt;&lt;/wbr&gt;&lt;/wbr&gt;&lt;/wbr&gt;&lt;/wbr&gt;&lt;/wbr&gt;&lt;/wbr&gt;&lt;/wbr&gt;&lt;/wbr&gt;&lt;/wbr&gt;&lt;/wbr&gt;&lt;/wbr&gt;&lt;/wbr&gt;&lt;/wbr&gt;&lt;/wbr&gt;&lt;/wbr&gt;&lt;/wbr&gt;&lt;/span&gt;&lt;/code&gt;&#xA;            &lt;/p&gt;&#xA;            &lt;p style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px 0px 10px; line-height:25px; padding-right:0px&#34;&gt;&#xA;                　　现在再来看看HOJ上的两道Joseph问题，有了上面的基础，只要做个脑筋急转弯就行了。&#xA;            &lt;/p&gt;&#xA;            &lt;p style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px 0px 10px; line-height:25px; padding-right:0px&#34;&gt;&#xA;                　　先看第一道(1016)，说Joseph把杀人的秘密传出来之后，很多聪明的或者还不够聪明的程序员都能够选择合适的位置使自己存活下来，但 Joseph的表兄，一个恶毒的一直致力于将世界上所有愚蠢的程序员杀光光的人，又发明出一种新的玩法来杀人，如果你又很不幸的站在了这n个人里面，你会选择哪个位置站下。&#xA;            &lt;/p&gt;&#xA;            &lt;p style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px 0px 10px; line-height:25px; padding-right:0px&#34;&gt;&#xA;                　　Joseph表兄的新玩法的特点是m是不再是给定的一个确定的数值，而且是按照素数从小到大变动的，即取值依次为{2, 3, 5, 7, ……}。&#xA;            &lt;/p&gt;&#xA;            &lt;p style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px 0px 10px; line-height:25px; padding-right:0px&#34;&gt;&#xA;                　　当然你仍然选择不会挂的位置站下。&#xA;            &lt;/p&gt;&#xA;            &lt;p style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px 0px 10px; line-height:25px; padding-right:0px&#34;&gt;&#xA;                　　题目已经说得很清楚了，不难想到我们只要在递推的过程中更新m的值就行了，m属于素数的集合，所以我们只要开个数组保存有用的素数，然后使m在其中取值就行了。&#xA;            &lt;/p&gt;&#xA;            &lt;p style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px 0px 10px; line-height:25px; padding-right:0px&#34;&gt;&#xA;                　　还有一点值得注意的是由于第1次杀人的时候取的值是prime[0]，第2次是prime[1]，……第n次是prime[n-1]，所以往回推的时候第1次取的应该是prime[n-1]，第2次是prime[n-2]，……则第i次应该是prime[n-i]。&#xA;            &lt;/p&gt;&#xA;        &lt;/div&gt;&#xA;    &lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;br /&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;pre class=&#34;cpp&#34; name=&#34;code&#34;&gt;#include &amp;lt;iostream&amp;gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;const int SIZE = 3502;&#xA;int prime[SIZE];&#xA;int result[SIZE];&#xA;int isprime(int n)&#xA;{&#xA;    for (int i=3 ;i*i&amp;lt;=n;i+=2)&#xA;    {&#xA;        if (n%i==0)&#xA;            return 0;&#xA;    }&#xA;    return 1;&#xA;}&#xA;int main()&#xA;{&#xA;    int prime[SIZE];&#xA;    int result[SIZE];&#xA;    int i,j;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;for(i = 3,j = 1,prime[0] = 2;j &amp;amp;lt; SIZE;i += 2)&#xA;    if(isprime(i))&#xA;        prime[j++] = i;&#xA;for(i = 1;i &amp;amp;lt; SIZE;i++)&#xA;    for(j = 1,result[i] = 0;j &amp;amp;lt;= i;j++)&#xA;        result[i] = (result[i] + prime[i-j]) % j;&#xA;while(scanf(&amp;amp;quot;%d&amp;amp;quot;,&amp;amp;amp;i) == 1 &amp;amp;amp;&amp;amp;amp; i)&#xA;{&#xA;    printf(&amp;amp;quot;%d\n&amp;amp;quot;,result[i] + 1);&#xA;}&#xA;return 0;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;}&#xA;&lt;/pre&gt;&#xA;&lt;br /&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>HOJ 1015  Nearly prime numbers</title>
      <link>http://pokerg.github.io/ACM/HOJ-1015--Nearly-prime-numbers/</link>
      <pubDate>2013-03-27 12:00:00 +0800</pubDate>
      <description>&lt;p style=&#34;&#34;&gt;&#xA;&#x9;Nearly prime number is an integer positive number for which it is possible to find such primes&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px; padding-right:0px&#34;&gt;P&lt;sub style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px; padding-right:0px&#34;&gt;1&lt;/sub&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;and&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px; padding-right:0px&#34;&gt;P&lt;sub style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px; padding-right:0px&#34;&gt;2&lt;/sub&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;that given number is equal to&lt;span style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px; padding-right:0px&#34;&gt;P&lt;sub style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px; padding-right:0px&#34;&gt;1&lt;/sub&gt;*P&lt;sub style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px; padding-right:0px&#34;&gt;2&lt;/sub&gt;&lt;/span&gt;. There is given a sequence on&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px; padding-right:0px&#34;&gt;N&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;integer positive numbers, you are to write a program that prints Yes if given number is nearly prime and No otherwise.&#xA;&lt;/p&gt;&#xA;Input&lt;span style=&#34;&#34;&gt;&lt;/span&gt;&#xA;&lt;p style=&#34;&#34;&gt;&#xA;&#x9;Input consists of&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px; padding-right:0px&#34;&gt;N+&lt;/span&gt;1 numbers. First is positive integer&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px; padding-right:0px&#34;&gt;N (1&amp;lt;=N&amp;lt;=50000)&lt;/span&gt;. Next&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px; padding-right:0px&#34;&gt;N&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;numbers followed by&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px; padding-right:0px&#34;&gt;N&lt;/span&gt;. Each number is not greater than&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px; padding-right:0px&#34;&gt;10&lt;sup style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px; padding-right:0px&#34;&gt;9&lt;/sup&gt;&lt;/span&gt;. All numbers separated by whitespace(s).&#xA;&lt;/p&gt;&#xA;Output&lt;span style=&#34;&#34;&gt;&lt;/span&gt;&#xA;&lt;p style=&#34;&#34;&gt;&#xA;&#x9;Write a line in output for each number of given sequence. Write Yes if given number is nearly prime and No in other case.&#xA;&lt;/p&gt;&#xA;Sample Input&lt;span style=&#34;&#34;&gt;&lt;/span&gt;&#xA;&lt;pre style=&#34;&#34;&gt;1&#xA;6&#xA;&lt;/pre&gt;&#xA;Sample Output&lt;span style=&#34;&#34;&gt;&lt;/span&gt;&#xA;&lt;p style=&#34;&#34;&gt;&#xA;&#x9;Yes&#xA;&lt;/p&gt;&#xA;&lt;p&gt;&#xA;&#x9;&amp;nbsp;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;&#xA;&#x9;&amp;nbsp;&#xA;&lt;/p&gt;&#xA;&lt;pre class=&#34;cpp&#34; name=&#34;code&#34;&gt;#include &amp;lt;cstdio&amp;gt;&#xA;#include &amp;lt;cstdlib&amp;gt;&#xA;bool isPrime(int n){&#xA;&#x9;if(n == 2)&#xA;&#x9;   return true;&#xA;    if(n % 2 == 0)&#xA;       return false;&#xA;&#x9;for(int i = 3; i * i &amp;lt;= n; i += 2)&#xA;&#x9;&#x9;if(n % i == 0)&#xA;&#x9;&#x9;&#x9;return false;&#xA;&#x9;return true;&#xA;}&#xA;bool isNearlyPrime(int n){&#xA;    if(n % 2 == 0 &amp;amp;&amp;amp; isPrime(n / 2))&#xA;        return true;&#xA;    for(int i = 3; i * i &amp;lt;= n; i += 2)&#xA;        if(n % i == 0 &amp;amp;&amp;amp; isPrime(i))&#xA;            if(isPrime(n / i))&#xA;              return true;&#xA;    return false;&#xA;}&#xA;int main(){&#xA;&#x9;int n;&#xA;&#x9;int a[50005];&#xA;&#x9;while(scanf(&amp;quot;%d&amp;quot;,&amp;amp;n) != EOF){&#xA;&#x9;&#x9;for(int i = 0; i &amp;lt; n; i++)&#xA;&#x9;&#x9;  scanf(&amp;quot;%d&amp;quot;,&amp;amp;a[i]);&#xA;&#x9;&#x9;for(int i = 0; i &amp;lt; n; i++){&#xA;&#x9;&#x9;&#x9;if(isNearlyPrime(a[i]))&#xA;&#x9;&#x9;&#x9;&#x9;printf(&amp;quot;Yes\n&amp;quot;);&#xA;&#x9;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;&#x9;printf(&amp;quot;No\n&amp;quot;);&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return 0;&#xA;}&lt;/pre&gt;&#xA;&lt;p&gt;&#xA;&#x9;&lt;br /&gt;&#xA;&#x9;&amp;nbsp;&#xA;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>HDOJ 4509  湫湫系列故事——减肥记II</title>
      <link>http://pokerg.github.io/ACM/HDOJ-4509--%E6%B9%AB%E6%B9%AB%E7%B3%BB%E5%88%97%E6%95%85%E4%BA%8B%E2%80%94%E2%80%94%E5%87%8F%E8%82%A5%E8%AE%B0II/</link>
      <pubDate>2013-03-23 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;div class=&#34;panel_title&#34; align=&#34;left&#34; style=&#34;font-size:18px; height:38px; font-family:Arial; font-weight:bold; color:rgb(124,169,237); padding-bottom:0px; padding-top:0px; padding-left:14px; padding-right:14px; background-color:transparent&#34;&gt;&#xA;    Problem Description&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;panel_content&#34; style=&#34;font-size:14px; height:auto; font-family:&#39;Times New Roman&#39;; padding-bottom:0px; text-align:left; padding-top:0px; padding-left:20px; margin:0px; padding-right:20px&#34;&gt;&#xA;    　　虽然制定了减肥食谱，但是湫湫显然克制不住吃货的本能，根本没有按照食谱行动！&lt;br /&gt;&#xA;    于是，结果显而易见…&lt;br /&gt;&#xA;    　　但是没有什么能难倒高智商美女湫湫的，她决定另寻对策——吃没关系，咱吃进去再运动运动消耗掉不就好了？&lt;br /&gt;&#xA;    　　湫湫在内心咆哮：“我真是天才啊~(≧▽≦)/~”&lt;br /&gt;&#xA;    &lt;br /&gt;&#xA;    　　可是，大家要知道，过年回家多忙啊——帮忙家里做大扫除，看电影，看小说，高中同学聚餐，初中同学聚餐，小学同学聚餐，吃东西，睡觉，吃东西，睡觉，吃东西，睡觉……所以锻炼得抽着时间来。&lt;br /&gt;&#xA;    &lt;br /&gt;&#xA;    　　但是，湫湫实在太忙了，所以没时间去算一天有多少时间可以用于锻炼，现在她把每日行程告诉你，拜托你帮忙算算吧~&lt;br /&gt;&#xA;    &lt;br /&gt;&#xA;    　　皮埃斯：一天是24小时，每小时60分钟&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;panel_bottom&#34; style=&#34;font-size:14px; height:auto; font-family:&#39;Times New Roman&#39;; margin:0px&#34;&gt;&#xA;    &amp;nbsp;&#xA;&lt;/div&gt;&#xA;&lt;br style=&#34;font-size:14px; font-family:&#39;Times New Roman&#39;&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;div class=&#34;panel_title&#34; align=&#34;left&#34; style=&#34;font-size:18px; height:38px; font-family:Arial; font-weight:bold; color:rgb(124,169,237); padding-bottom:0px; padding-top:0px; padding-left:14px; padding-right:14px; background-color:transparent&#34;&gt;&#xA;    Input&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;panel_content&#34; style=&#34;font-size:14px; height:auto; font-family:&#39;Times New Roman&#39;; padding-bottom:0px; text-align:left; padding-top:0px; padding-left:20px; margin:0px; padding-right:20px&#34;&gt;&#xA;    输入数据包括多组测试用例。&lt;br /&gt;&#xA;    每组测试数据首先是一个整数n，表示当天有n件事要做。&amp;nbsp;&lt;br /&gt;&#xA;    接下来n行，第i行是第i件事的开始时间和结束时间，时间格式为HH:MM。&lt;br /&gt;&#xA;    &lt;br /&gt;&#xA;    [Technical Specification]&lt;br /&gt;&#xA;    1. 1 &amp;lt;= n &amp;lt;= 500000&lt;br /&gt;&#xA;    2. 00 &amp;lt;= HH &amp;lt;= 23&lt;br /&gt;&#xA;    3. 00 &amp;lt;= MM &amp;lt;= 59&lt;br /&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;/div&gt;&#xA;&lt;div class=&#34;panel_bottom&#34; style=&#34;font-size:14px; height:auto; font-family:&#39;Times New Roman&#39;; margin:0px&#34;&gt;&#xA;    &amp;nbsp;&#xA;&lt;/div&gt;&#xA;&lt;br style=&#34;font-size:14px; font-family:&#39;Times New Roman&#39;&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;div class=&#34;panel_title&#34; align=&#34;left&#34; style=&#34;font-size:18px; height:38px; font-family:Arial; font-weight:bold; color:rgb(124,169,237); padding-bottom:0px; padding-top:0px; padding-left:14px; padding-right:14px; background-color:transparent&#34;&gt;&#xA;    Output&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;panel_content&#34; style=&#34;font-size:14px; height:auto; font-family:&#39;Times New Roman&#39;; padding-bottom:0px; text-align:left; padding-top:0px; padding-left:20px; margin:0px; padding-right:20px&#34;&gt;&#xA;    请输出一个整数，即湫湫当天可以用于锻炼的时间（单位分钟）&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;panel_bottom&#34; style=&#34;font-size:14px; height:auto; font-family:&#39;Times New Roman&#39;; margin:0px&#34;&gt;&#xA;    &amp;nbsp;&#xA;&lt;/div&gt;&#xA;&lt;br style=&#34;font-size:14px; font-family:&#39;Times New Roman&#39;&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;div class=&#34;panel_title&#34; align=&#34;left&#34; style=&#34;font-size:18px; height:38px; font-family:Arial; font-weight:bold; color:rgb(124,169,237); padding-bottom:0px; padding-top:0px; padding-left:14px; padding-right:14px; background-color:transparent&#34;&gt;&#xA;    Sample Input&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;panel_content&#34; style=&#34;font-size:14px; height:auto; font-family:&#39;Times New Roman&#39;; padding-bottom:0px; text-align:left; padding-top:0px; padding-left:20px; margin:0px; padding-right:20px&#34;&gt;&#xA;    &lt;pre style=&#34;margin-bottom:0px; margin-top:0px&#34;&gt;&lt;div style=&#34;font-family:&#39;Courier New&#39;,Courier,monospace&#34;&gt;1&#xA;15:36 18:40&#xA;4&#xA;01:35 10:36&#xA;04:54 22:36&#xA;10:18 18:40&#xA;11:47 17:53&lt;/div&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;panel_bottom&#34; style=&#34;font-size:14px; height:auto; font-family:&#39;Times New Roman&#39;; margin:0px&#34;&gt;&#xA;    &amp;nbsp;&#xA;&lt;/div&gt;&#xA;&lt;br style=&#34;font-size:14px; font-family:&#39;Times New Roman&#39;&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;div class=&#34;panel_title&#34; align=&#34;left&#34; style=&#34;font-size:18px; height:38px; font-family:Arial; font-weight:bold; color:rgb(124,169,237); padding-bottom:0px; padding-top:0px; padding-left:14px; padding-right:14px; background-color:transparent&#34;&gt;&#xA;    Sample Output&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;panel_content&#34; style=&#34;font-size:14px; height:auto; font-family:&#39;Times New Roman&#39;; padding-bottom:0px; text-align:left; padding-top:0px; padding-left:20px; margin:0px; padding-right:20px&#34;&gt;&#xA;    &lt;pre style=&#34;margin-bottom:0px; margin-top:0px&#34;&gt;&lt;div style=&#34;font-family:&#39;Courier New&#39;,Courier,monospace&#34;&gt;1256&#xA;179&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;div style=&#34;border-top:rgb(183,203,255) 1px dashed; font-family:&#39;Times New Roman&#39;; border-right:rgb(183,203,255) 1px dashed; border-bottom:rgb(183,203,255) 1px dashed; padding-bottom:6px; padding-top:6px; padding-left:6px; border-left:rgb(183,203,255) 1px dashed; padding-right:6px; background-color:rgb(244,251,255)&#34;&gt;&lt;div style=&#34;font-family:Arial; border-bottom:rgb(183,203,255) 1px dashed; font-weight:bold; color:rgb(124,169,237)&#34;&gt;&lt;em&gt;Hint&lt;/em&gt;&lt;/div&gt;&#xA;大量输入，建议用scanf读数据。&#xA;&lt;/div&gt;&lt;span style=&#34;font-size:1px&#34;&gt; &lt;/span&gt; &lt;/div&gt;&lt;/pre&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;panel_bottom&#34; style=&#34;font-size:14px; height:auto; font-family:&#39;Times New Roman&#39;; margin:0px&#34;&gt;&#xA;    &amp;nbsp;&#xA;&lt;/div&gt;&#xA;&lt;br style=&#34;font-size:14px; font-family:&#39;Times New Roman&#39;&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;div class=&#34;panel_content&#34; style=&#34;font-size:14px; height:auto; font-family:&#39;Times New Roman&#39;; padding-bottom:0px; text-align:left; padding-top:0px; padding-left:20px; margin:0px; padding-right:20px&#34;&gt;&#xA;    &lt;span style=&#34;font-size:24px&#34;&gt;&lt;strong&gt;题解：&lt;/strong&gt;&lt;/span&gt;&#xA;&lt;/div&gt;&#xA;&lt;div class=&#34;panel_bottom&#34; style=&#34;font-size:14px; height:auto; font-family:&#39;Times New Roman&#39;; margin:0px&#34;&gt;&#xA;    &amp;nbsp;&#xA;&lt;/div&gt;&#xA;&lt;p&gt;&#xA;    &lt;span style=&#34;font-family:KaiTi_GB2312; font-size:24px&#34;&gt;&lt;strong&gt;&amp;nbsp; &amp;nbsp; 由于时间是以分钟为单位，我们可以把时间看做 24 * 60 个 点 初值为 0&lt;/strong&gt;&lt;/span&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;&#xA;    &lt;span style=&#34;font-family:KaiTi_GB2312; font-size:24px&#34;&gt;&lt;strong&gt;&amp;nbsp; &amp;nbsp; 若某个点被占用， 记为 1&lt;/strong&gt;&lt;/span&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;&#xA;    &lt;span style=&#34;font-family:KaiTi_GB2312; font-size:24px&#34;&gt;&lt;strong&gt;&amp;nbsp; &amp;nbsp;最后统计 为 0 点 的 个数 即为可用时间&lt;/strong&gt;&lt;/span&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;&#xA;    &lt;span style=&#34;font-family:KaiTi_GB2312; font-size:24px&#34;&gt;&lt;strong&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;/strong&gt;&lt;/span&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;&#xA;    &lt;br /&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;/p&gt;&#xA;&lt;p&gt;&#xA;    &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&#xA;&lt;/p&gt;&lt;/p&gt;&#xA;</description>
    </item>
  </channel>
</rss>