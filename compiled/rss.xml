<?xml version="1.0"?>
<rss version="2.0">
  <channel>
    <title>pokerG</title>
    <link>http://pokerg.github.io</link>
    <pubDate>22 Sep 13 16:26 CST</pubDate>
    <item>
      <title>Go1.2 Release</title>
      <link>http://pokerg.github.io/Programming Language/Go1.2-Release/</link>
      <pubDate>2013-09-22 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&amp;emsp;&amp;emsp;Go1.2发布了，做了一些调整和改进，这里我就只谈谈几个跟我目前关系比较大的，其他的请去查看[release notes](&amp;ldquo;http://tip.golang.org/doc/go1.2&amp;rdquo;)&lt;/p&gt;

&lt;h1&gt;nil 的使用&lt;/h1&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;在Go1.0中 例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type T struct {
    X [1&amp;lt;&amp;lt;24]byte
    Field int32
}

func main() {
    var x *T
    ...
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;这个nil 指针 x 可以访问非法内存， x.Field 可以访问 1&amp;lt;&amp;lt;24的内存.在Go1.2中 编译器会确保不会错误的使用nil 指针。&lt;/p&gt;

&lt;h1&gt;切片有三个index&lt;/h1&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;在Go1.2中 使用切片操作一个存在的数组或切片时可以指定容量（capacity）。必须小于原数组或切片的容量。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var array [10]int
slice = array[2:4:6]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;第三个index是用来指定容量的。当操作 这个 slice时 ，不能访问 原 array 中 的后两个元素&lt;/p&gt;

&lt;h1&gt;Test coverage&lt;/h1&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;关于 go test -cover  目前还不是很清楚，所以先空下了， 可以通过 &lt;code&gt;go help testflag&lt;/code&gt;
或 &lt;code&gt;go tool cover -help&lt;/code&gt;  来查看具体用法和作用&lt;/p&gt;

&lt;h1&gt;go doc 被删掉&lt;/h1&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;现在没有 &amp;ldquo;go doc&amp;rdquo; 这个命令了， 只有 &amp;ldquo;godoc&amp;rdquo;&lt;/p&gt;

&lt;h1&gt;go get -t&lt;/h1&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;-t 参数 可以下载package的依赖项的测试程序&lt;/p&gt;
</description>
    </item>
    <item>
      <title>文明的翅膀</title>
      <link>http://pokerg.github.io/History/%E6%96%87%E6%98%8E%E7%9A%84%E7%BF%85%E8%86%80/</link>
      <pubDate>2013-09-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&amp;emsp;&amp;emsp;历史的进程是残酷的。上了“文明毁灭黑名单”的有古埃及，巴比伦，哈拉巴，克里特，奥尔梅克，赫梯，波斯，玛雅等等，不下二三十中。&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;绵延不绝的是中华文明起死回生的则是希腊-罗马文明。何以如此？这是一个“斯芬克斯之谜”。易中天在《易中天中华史-奠基人》中揭示了这个谜底。这篇文章虽然观点并不是很新颖，但是从角度上来说，让我读起来感觉很有趣。&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;斯芬克斯，是希腊人对狮身人面像的称呼。不过在希腊的斯芬克斯却又两只翅膀。这就比古埃及的那个家伙，显得轻盈娟修。翅膀，是重要的。没有翅膀就不能飞。文明没有翅膀，就只能原地踏步，最终只得陨落。但是怎样飞翔，却要看是什么样的翅膀。&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;中华的翅膀，是忧患心理和乐观态度。&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;忧患是我们民族文化的底色。从《诗·小雅·小旻》“战战兢兢，如临深渊，如履薄冰“，到孟子的“生于忧患，死于安乐”，再到《义勇军进行曲》，忧患意识贯穿来整个中华史。&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;但是我们民族优势乐观的。我们相信“天遂人愿”，相信“善恶有报”，相信“事在人为”。因此，我们“不改其乐”，哪怕“自得其乐”,也总归”乐在其中“。&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;一忧一乐，从制度上来说就是有礼有乐。礼就是“理”，伦理，秩序，体现忧患；乐（le）就是“乐”（yue），讲快乐，讲和谐，造就乐观。&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;希腊的翅膀，是科学精神和艺术气质。&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;希腊人的科学不是实用主义的。他们“为思想而思想，为科学而科学”。所以他们能把埃及人用于测量土地和修建金字塔的技术，变成几何学；也能把巴比伦的占星术，变成天文学。&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;与此同时，希腊人又极具艺术气质。正如马克思所说，希腊人是”正常的儿童“，所以”为艺术而艺术，为审美而审美“。这种纯粹，使他们即使在纵欲和淫乐，也毫无负罪感。&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;科学与艺术，在希腊人那里是对立的，也是统一的。统一于单纯，统一于天然，统一于率真。&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;希腊精神是互补的。同样中华精神也是互补结构。对立统一，相辅相成，共同塑造着一个伟大的民族。
这也许就是秘密所在&amp;ndash;那些毁灭的文明，很可能都只有一只翅膀。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>jekyllTogor</title>
      <link>http://pokerg.github.io/Programming Language/jekyllTogor/</link>
      <pubDate>2013-09-03 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&amp;emsp;&amp;emsp;前几天在Github上看到gor——Go编写的静态博客引擎,顿时有了不小的兴趣，就试了一下&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;先说说我的感受吧（帮gor做做广告了），首先它的安装真的很简单，作为静态语言，只需要编译成可执行文件就可使用，go的工具链很方便的就能实现，（具体安装方法可以参考它的&lt;a href=&#34;https://github.com/wendal/gor&#34;&gt;主页&lt;/a&gt;.如果你想全局使用的话，将它路径加到$PATH里就行了，这个就不用多说了。当时装jekyll时真是崩溃死了，没学过ruby，先得装ruby，刚开始装的是2.0,然后装jekyll，反正也看不懂，就跟着别人的来，一直出问题，最后用尽各种方法都不行，花了有两个多小时吧，最后灵光一闪，是不是ruby的版本有问题。。然后换成了1.9.3.最后终于成功了。。！！真是崩溃的要死。gor的第二个优点就是速度快，系统级语言确实是不能比的，而且它和jekyll的工作原理不同。这两点我认为是的对新手来说很重要的。&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;当然上述其实不是本文的重点（汗。。）。gor 的 元数据 和 jekyll的有点区别。我的Blog虽然不多。但要是一个个手动改的话，也是很麻烦的。作为coder，目的是实现自动化，这种事当然不能这么干，同时也是为了练习Golang，所以就写了个&lt;a href=&#34;https://github.com/pokerG/jekyllTogor&#34;&gt;脚本&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;通过写这个脚本，发现了一些问题和情况。好久没有写程序了，手速下降的不行行了。。关键是对Go的不熟练，这个脚本其实是很简单的，但是我写了3个小时把。理论掌握的多，实践少。&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;接下来为了改善这种情况，一方面是接着分析Go的标准库，看看Go的创始者的code是怎么写的,这是提高能力的一个关键方法。还有就是练习练习再练习。&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;接下来主要先分析这几部分：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;string&lt;/li&gt;
&lt;li&gt;file&lt;/li&gt;
&lt;li&gt;regexp&lt;/li&gt;
&lt;li&gt;refelect&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    <item>
      <title>Go标准库-bufio</title>
      <link>http://pokerg.github.io/Programming Language/Go%E6%A0%87%E5%87%86%E5%BA%93-bufio/</link>
      <pubDate>2013-08-28 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&amp;emsp;&amp;emsp;bufio包实现了带缓存的I/O操作。封装了一个io.Reader或io.Writer对象，返回一个具有缓存和文本读写的对象。&lt;/p&gt;

&lt;h1&gt;bufio.go&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;//实现了带缓存的
type Reader struct{
        buf          []byte
        rd           io.Reader
        r, w         int
        err          error
        lastByte     int
        lastRuneSize int
}

//NewReaderSize将rd封装成一个具有size大小的bufio.Reader对象
//如果rd的类型就是bufio.Reader且size &amp;gt; minReadBufferSize = 16 直接返回
//size的大小要大于 minReadBufferSize 否则 返回大小为minReadBufferSize的bufio.Reader
func NewReaderSize(rd io.Reader, size int) *Reader

//NewReader 返回 大小为defaultBufSize = 4096的Reader
func NewReader(rd io.Reader) *Reader

//Peek返回
func (b *Reader) Peek(n int) ([]byte, error)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    <item>
      <title>Go标准库-io-pipe</title>
      <link>http://pokerg.github.io/Programming Language/Go%E6%A0%87%E5%87%86%E5%BA%93-io-pipe/</link>
      <pubDate>2013-08-28 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&amp;emsp;&amp;emsp;pipe中基本的struct是 pipe&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//pipe 是 PipeReader 和 PipeWriter 的底层实现
type pipe struct {
    //sync.Mutex 是 一个并发时用的锁，这个以后在sync包中会讲到
    //rl/wl 控制同时只有一个读取器或写入器
    rl    sync.Mutex 
    wl    sync.Mutex 
    l     sync.Mutex //用于保护其他字段
    data  []byte     //管道中的数据
    // r/wwait 控制读取器或写入器等待  
    rwait sync.Cond  
    wwait sync.Cond  
    // r/werr 如果读取器（写入器）关闭，该错误会被Write（Read）方法返回
    rerr  error      
    werr  error     
}

//ErrClosePipe 用于返回对于关闭的管道的操作错误
var ErrClosedPipe = errors.New(&amp;quot;io: read/write on closed pipe&amp;quot;)

func (p *pipe) read(b []byte) (n int, err error) {
// One reader at a time.（控制一次只能一个读取器）
    p.rl.Lock()
    defer p.rl.Unlock()

    // 保护其他字段的读写
    p.l.Lock()
    defer p.l.Unlock()
    for {
        // Reader端关闭后，再Read，则返回ErrClosedPipe
        if p.rerr != nil {
            return 0, ErrClosedPipe
        }
        // 管道中有数据，退出循环
        if p.data != nil {
            break
        }
        // Writer端关闭，返回p.werr
        if p.werr != nil {
            return 0, p.werr
        }
        // 没有数据或管道没有关闭，读取端等待
        p.rwait.Wait()
    }
    // 管道中有数据，将其copy一份到b中
    n = copy(b, p.data)
    p.data = p.data[n:]
    // 如果管道数据被读光，需要唤醒在等待的Writer
    if len(p.data) == 0 {
        p.data = nil
        p.wwait.Signal()
    }
    return
}

func (p *pipe) write(b []byte) (n int, err error) {
// pipe uses nil to mean not available
    if b == nil {
        // zero的定义为：var zero [0]byte
        b = zero[:]
    }

    // One writer at a time.
    p.wl.Lock()
    defer p.wl.Unlock()

    p.l.Lock()
    defer p.l.Unlock()

    p.data = b
    // 唤醒在等待的Reader
    p.rwait.Signal()
    for {
        // 数据被读走，退出循环
        if p.data == nil {
            break
        }
        // Reader端关闭，设置err = p.rerr，退出循环
        if p.rerr != nil {
            err = p.rerr
            break
        }
        // Writer端关闭后，再Writer，设置err =   、ErrClosedPipe
        if p.werr != nil {
            err = ErrClosedPipe
        }
        // 数据没被读走（全部）或管道读取端没关闭，则等待
        p.wwait.Wait()
    }
    // 计算写入的字节数
    n = len(b) - len(p.data)
    p.data = nil // in case of rerr or werr
    return
}

//关闭读取器
func (p *pipe) rclose(err error) {
    if err == nil {
        err = ErrClosedPipe
    }
    p.l.Lock()
    defer p.l.Unlock()
    p.rerr = err
    p.rwait.Signal()
    p.wwait.Signal()
}

//关闭写入端
func (p *pipe) wclose(err error) {
    if err == nil {
        err = EOF
    }
    p.l.Lock()
    defer p.l.Unlock()
    p.werr = err
    p.rwait.Signal()
    p.wwait.Signal()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;pipe中对外的两个结构是PipeReader 和 PipeWriter。&lt;br/&gt;
&amp;emsp;&amp;emsp;PipeReader 实现了io.Reader 和 io.Closer&lt;br/&gt;
&amp;emsp;&amp;emsp;PipeWriter 实现了io.Wrter 和 io.Closer&lt;br/&gt;
&amp;emsp;&amp;emsp;这两个结构的Read/Write 事实上是调用了pipe的实现。&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;关于 Read 方法的说明：从管道中读取数据。该方法会堵塞，直到管道写入端开始写入数据或写入端关闭了。如果写入端关闭时带上了error（即调用CloseWithError关闭），该方法返回的err就是写入端传递的error；否则err为EOF。&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;关于 Write 方法的说明：写数据到管道中。该方法会堵塞，直到管道读取端读完所有数据或读取端关闭了。如果读取端关闭时带上了error（即调用CloseWithError关闭），该方法返回的err就是读取端
传递的error；否则err为 ErrClosedPipe。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//返回一组对应的管道输入输出
func Pipe() (*PipeReader, *PipeWriter) {
    p := new(pipe)
    p.rwait.L = &amp;amp;p.l
    p.wwait.L = &amp;amp;p.l
    r := &amp;amp;PipeReader{p}
    w := &amp;amp;PipeWriter{p}
    return r, w
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;pipe 用于在并发时实现输入输出操作，没有内部缓存，所以在并发调用时是安全的。&lt;/p&gt;

&lt;p&gt;[返回顶部]()&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Go标准库-io-multi</title>
      <link>http://pokerg.github.io/Programming Language/Go%E6%A0%87%E5%87%86%E5%BA%93-io-multi/</link>
      <pubDate>2013-08-28 12:00:00 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;//接受多个Reader/Writer 
//返回一个Reader/Writer
//操作这个Reader/Writer 就相当于操作多个Reader/Writer
func MultiReader(readers ...Reader) Reader {
    return &amp;amp;multiReader{readers}
}

func MultiWriter(writers ...Writer) Writer {
    return &amp;amp;multiWriter{writers}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;multi中定义了两个内部struct，multiReader 和 multiWriter 分别实现了 io.Reader 和 io.Writer&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type multiReader struct {
    readers []Reader
}
type multiWriter struct {
    writers []Writer
}

func (mr *multiReader) Read(p []byte) (n int, err error) {
    for len(mr.readers) &amp;gt; 0 {
        n, err = mr.readers[0].Read(p)
        if n &amp;gt; 0 || err != EOF {
            if err == EOF {
                // Don&#39;t return EOF yet. There may be more bytes
                // in the remaining readers.
                err = nil
            }
            return
        }
        mr.readers = mr.readers[1:]
    }
    return 0, EOF
}

func (t *multiWriter) Write(p []byte) (n int, err error) {
    for _, w := range t.writers {
        n, err = w.Write(p)
        if err != nil {
            return
        }
        if n != len(p) {
            err = ErrShortWrite
            return
        }
    }
    return len(p), nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;我们举两个例子，来谈谈应用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;MultiReader:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;readers := []io.Reader{
    strings.NewReader(&amp;quot;from strings reader&amp;quot;),
    bytes.NewBufferString(&amp;quot;from bytes buffer&amp;quot;),
}
reader := io.MultiReader(readers...)
data := make([]byte, 0, 1024)
var (
    err error
    n   int
)
for err != io.EOF {
    tmp := make([]byte, 512)
    n, err = reader.Read(tmp)
    if err == nil {
        data = append(data, tmp[:n]...)
    } else {
        if err != io.EOF {
            panic(err)
        }
    }
}
fmt.Printf(&amp;quot;%s\n&amp;quot;, data)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from strings readerfrom bytes buffer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;MultiReader只是逻辑上将多个Reader组合起来，并不能通过调用一次Read方法获取所有Reader的内容。在所有的Reader内容都被读完后，Reader会返回EOF。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;MultiWriter：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;file, err := os.Create(&amp;quot;tmp.txt&amp;quot;)
if err != nil {
    panic(err)
}
defer file.Close()
writers := []io.Writer{
    file,
    os.Stdout,
}
writer := io.MultiWriter(writers...)
writer.Write([]byte(&amp;quot;MultiWriter test&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;这段程序执行后在生成tmp.txt文件，同时在文件和屏幕中都输出：MultiWriter test 这和Unix中的tee命令类似。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Go标准库-io-ioutil</title>
      <link>http://pokerg.github.io/Programming Language/Go%E6%A0%87%E5%87%86%E5%BA%93-io-ioutil/</link>
      <pubDate>2013-08-28 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&amp;emsp;&amp;emsp;ioutil封装了一些常用的io操作&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//读取r中所有数据
//返回 读取的数据 和 error
//读取成功的话 返回nil 而不是 EOF
//ReadAll 实际上是通过bytes.Buffer的ReadFrom()实现的
func ReadAll(r io.Reader) ([]byte, error)

//读取文件中的所有数据
//返回 读取的数据 和 error
//读取成功的话 返回nil 而不是 EOF
//ReadFile 和 ReadAll 都是通过readAll()实现的
//ReadFile会先判断文件的大小，给bytes.Buffer一个预定义容量，避免额外分配内存。
func ReadFile(filename string) ([]byte, error)

//将 data 写入 文件
//如果文件不存在，将以perm权限创建文件
func WriteFile(filename string, data []byte, perm os.FileMode) error

//定义了一系列文件信息的操作
type byName []os.FileInfo

func (f byName) Len() int           { return len(f) }
func (f byName) Less(i, j int) bool { return f[i].Name() &amp;lt; f[j].Name() }
func (f byName) Swap(i, j int)      { f[i], f[j] = f[j], f[i] }

//读取文件夹中的文件
//返回 文件信息的序列 和 error
func ReadDir(dirname string) ([]os.FileInfo, error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;这里有个实现类似于tree命令的程序&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
    if len(os.Args) &amp;gt; 1 {
        Tree(os.Args[1], 1, map[int]bool{1:true})
    }
}

// 列出dirname目录中的目录树，实现类似Unix中的tree命令
// curHier 当前层级（dirname为第一层）
// hierMap 当前层级的上几层是否需要&#39;|&#39;的映射
func Tree(dirname string, curHier int, hierMap map[int]bool) error {
    dirAbs, err := filepath.Abs(dirname)
    if err != nil {
        return err
    }
    fileInfos, err := ioutil.ReadDir(dirAbs)
    if err != nil {
        return err
    }

    fileNum := len(fileInfos)
    for i, fileInfo := range fileInfos {
        for j := 1; j &amp;lt; curHier; j++ {
            if hierMap[j] {
                fmt.Print(&amp;quot;|&amp;quot;)
            } else {
                fmt.Print(&amp;quot; &amp;quot;)
            }
            fmt.Print(strings.Repeat(&amp;quot; &amp;quot;, 3))
        }

        // map是引用类型，所以新建一个map
        tmpMap := map[int]bool{}
        for k, v := range hierMap {
            tmpMap[k] = v
        }
        if i+1 == fileNum {
            fmt.Print(&amp;quot;`&amp;quot;)
            delete(tmpMap, curHier)
        } else {
            fmt.Print(&amp;quot;|&amp;quot;)
            tmpMap[curHier] = true
        }
        fmt.Print(&amp;quot;-- &amp;quot;)
        fmt.Println(fileInfo.Name())
        if fileInfo.IsDir() {
            Tree(filepath.Join(dirAbs, fileInfo.Name()), curHier+1, tmpMap)
        }
    }
    return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//将 io.Reader 封装成 io.ReadCloser
// 其 Close 方法不做任何事情
func NopCloser(r io.Reader) io.ReadCloser

//Discard 对应的类型 type devNull int 实现了io.Writer
//从名字我们就可以看出 Discard    的 任何Write()都会成功但是不干任何事情
//同时为了优化io.Copy到Discard，避免不必要的工作，实现了io.ReaderFrom接口。
//ReadFrom的实现是读取内容到一个buf中，最大也就8192字节，其他的会丢弃（当然，这个也不会读取）
//Discard 用于并发
var Discard io.Writer = devNull(0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;emsp;&amp;emsp; tempfile.go中的函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// TempFile 在目录 dir 中创建一个临时文件并将其打开
// 文件名以 prefix 为前缀
// 返回创建的文件的对象和创建过程中遇到的任何错误
// 如果 dir 为空，则在系统的临时目录中创建临时文件
// 如果环境变量中没有设置系统临时目录，则在 /tmp 中创建临时文件
// 调用者可以通过 f.Name() 方法获取临时文件的完整路径
// 调用 TempFile 所创建的临时文件，应该由调用者自己移除
func TempFile(dir, prefix string) (f *os.File, err error)

// TempDir 功能同 TempFile，只不过创建的是目录
// 返回值也只返目录的完整路径
func TempDir(dir, prefix string) (name string, err error)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    <item>
      <title>Go标准库-io-io</title>
      <link>http://pokerg.github.io/Programming Language/Go%E6%A0%87%E5%87%86%E5%BA%93-io-io/</link>
      <pubDate>2013-08-27 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&amp;emsp;&amp;emsp;io包为I/O原语提供了基本的接口。它主要包装了这些原语的已有实现。由于这些接口和原语以不同的实现包装了低级操作，因此除非另行通知，否则客户端不应假定它们对于并行执行是安全的。&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;首先我们来看几个variables，这几个variables都是读写操作中可能出现的情况&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//ErrShortWrite 用于一个write少于规定的字符数，但是又不能返回一个明确的错误时
var ErrShortWrite = errors.New(&amp;quot;short write&amp;quot;)

//ErrShortBuffer 用于一个read要求的字符数多于所能提供的字符
var ErrShortBuffer = errors.New(&amp;quot;short buffer&amp;quot;)

//EOF 就是end-of-file 不用多解释，但是如果EOF发生在一个结构数据流中，error就不应该是EOF
var EOF = errors.New(&amp;quot;EOF&amp;quot;)

//ErrUnexpectedEOF 意味着EOF发生在读取一个固定数据块或者数据结构的中间
var ErrUnexpectedEOF = errors.New(&amp;quot;unexpected EOF&amp;quot;)

//ErrNoProgress 发生在多个io.Reader调用Read()方法，却没有返回任何数据或错误时
//通常作为一个破损的io.Reader实现的标志
var ErrNoProgress = errors.New(&amp;quot;multiple Read calls return no data or error&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;io包中最基本的4个接口&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//Reader 封装了基本的read方法
//Read()方法读取len(p)个字符放入p中，返回读取的字符数（0&amp;lt;=n&amp;lt;=len(p)) 和 错误。
//即使 Read 返回的 n &amp;lt; len(p)，它也会在调用过程中使用 p 的全部作为暂存空间。
//若一些数据可用但不到 len(p) 个字节，Read 会照例返回可用的数据，而不是等待更多数据。
//当 Read 在成功读取 n &amp;gt; 0 个字节后遇到一个错误或EOF（end-of-file），它就会返回读取的字节数。
//所以当Read方法返回错误时，不代表没有读取到任何数据。调用者应该处理返回的任何数据，之后才处理可能的错误。
//&amp;quot;p被装满&amp;quot; err返回nil
//&amp;quot;数据被读完&amp;quot;, err返回EOF
//&amp;quot;读取出错&amp;quot;, err返回相应的错误信息
//以上就是实现io.Reader接口应注意的
type Reader interface {
    Read(p []byte) (n int, err error)
}

//Writer 封装了基本的write方法
//Write()方法 将p中数据写入相应对象的数据流，返回从p中写入的字符数和错误。
//当n = len(p)时，返回nil
//当 n &amp;lt; len(p)时，返回相应的错误信息
type Writer interface {
    Write(p []byte) (n int, err error)
}

//Closer 封装了基本的Close方法
//Close()用于关闭数据流，文件，数据库，Socket等等
//经常将Close()的调用放在defer语句
type Closer interface {
    Close() error
}

//Seeker 封装了基本的Seek方法
//Seek() 设置下一次的读写头，即偏移地址offset
//offset的解释依据于 whence
// whence = 0 与文件起始的偏移
// whence = 1 与当前读写头的偏移
// whence = 2 与文件尾部的偏移
type Seeker interface {
    Seek(offset int64, whence int) (ret int64, err error)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;其他接口都是这四个基本接口的组合，从名字我们就可以判断出来。
&lt;strong&gt;ReadWriter,ReadCloser,WriteCloser,ReadWriteCloser,ReadSeeker,WriteSeeker,ReadWriteSeeker&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;这里还有一些较为高级一点的输入输出接口&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//ReaderFrom 封装了ReadFrom方法
//ReadFrom() 从 r 中读取数据，直到EOF或 error
//返回 读取的字符数 和 error
//Copy() 如果相应的参数实现了ReaderFrom接口，会调用ReadFrom()
type ReaderFrom interface {
    ReadFrom(r Reader) (n int64, err error)
}

//WriterTo 封装了WriterTo方法
//WriteTo()将对象的数据流写入w 直到全部写入或者遇到error
//返回 写入的字符数 和 error
//Copy() 如果相应的参数实现了WriterTo接口，会调用WriteTo()
type WriterTo interface {
    WriteTo(w Writer) (n int64, err error)
}

//ReaderAt 封装了ReadAt方法
//ReadAt() 从对象的数据流的off位置读取len(p)个字符 到 p
//返回 读取的字符数 和 error
//当 ReadAt 返回的 n &amp;lt; len(p) 时，它就会返回一个非nil的错误来解释 
为什么没有返回更多的字节。在这一点上，ReadAt 比 Read 更严格。
//即使 ReadAt 返回的 n &amp;lt; len(p)，它也会在调用过程中使用
 p 的全部作为暂存空间。若一些数据可用但不到 len(p) 字节，
ReadAt 就会阻塞直到所有数据都可用或产生一个错误。 
在这一点上 ReadAt 不同于 Read。
// 返回读取的字节数 n 和读取时遇到的错误
//如果 n &amp;lt; len(p)，则需要返回一个 err 值来说明
// 为什么没有将 p 填满（比如 EOF）
// 如果 n = len(p)，而且对象的数据没有全部读完，则
// err 将返回 nil
// 如果 n = len(p)，而且对象的数据刚好全部读完，则
// err 将返回 EOF 或者 nil（不确定）
type ReaderAt interface {
    ReadAt(p []byte, off int64) (n int, err error)
}

//WriterAt 封装了WriterAt方法
//WriteAt() 将 p 中的数据写入到对象数据流的 off 处
//返回 写入的字符数 和 error
type WriterAt interface {
    WriteAt(p []byte, off int64) (n int, err error)
}

//ByteReader 封装了ReadByte方法
//ReadByte 从对象的数据流中读取一个字符到 c
//如何没有字符可读，返回一个error
type ByteReader interface {
    ReadByte() (c byte, err error)
}

//ByteScanner 在ByteReader的基础上加上了UnreadByte方法
//UnreadByte() 撤销上一次的ReadByte 即将读写头移到上次ReadByte的位置
//调用UnreadByte()前必须调用ReadByte(),且不能连续调用UnreadByte()两次，否则返回一个错误
type ByteScanner interface {
    ByteReader
    UnreadByte() error
}

//ByteWriter 封装了 WriteByte方法
//WriteByte 将一个字节 c 写入到对象的数据流中
type ByteWriter interface {
    WriteByte(c byte) error
}

//RuneReader 封装了ReadRune方法
//ReadRune() 从对象的数据流中读取一个UTF-8 字符 
//返回这个 rune, 还有它所占字符数，还有error
type RuneReader interface {
    ReadRune() (r rune, size int, err error)
}

//RuneScanner 类似于 ByteScanner 就不再赘述
type RuneScanner interface {
    RuneReader
    UnreadRune() error
}

//stringWriter 封装了 WriteString方法
//WriteString() 将 字符串s 写入 对象的数据流
//返回写入的字符数 和 error
type stringWriter interface {
    WriteString(s string) (n int, err error)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;接下来看看io中的几个函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//向 Writer 中 写入 字符串
//返回 写入的字符书 和 error
//如果 w 也实现了 stringWriter接口 将直接调用其WriteString()
func WriteString(w Writer, s string) (n int, err error) {
    if sw, ok := w.(stringWriter); ok {
        return sw.WriteString(s)
    }
    return w.Write([]byte(s))
}

//从Reader中读取至少min个字符 到 buf
//返回 读取的字符数 和 error
//只有当没有数据可读，返回EOF
//如果 n &amp;lt; min 返回ErrUnexpectedEOF
//如果 min &amp;gt; len(buf) 返回 ErrShortBuffer
//只有当 n &amp;gt;= min 返回nil
func ReadAtLeast(r Reader, buf []byte, min int) (n int, err error) {
    if len(buf) &amp;lt; min {
        return 0, ErrShortBuffer
    }
    for n &amp;lt; min &amp;amp;&amp;amp; err == nil {
        var nn int
        nn, err = r.Read(buf[n:])
        n += nn
    }
    if n &amp;gt;= min {
        err = nil
    } else if n &amp;gt; 0 &amp;amp;&amp;amp; err == EOF {
    err = ErrUnexpectedEOF
    }
    return
}

//ReadFull 与 ReadAtLeast相似，min = len(buf)
func ReadFull(r Reader, buf []byte) (n int, err error) {
    return ReadAtLeast(r, buf, len(buf))
}

//从 Reader 中 复制 n个字符 到 Writer
//返回 复制的字符数 和 复制过程中最早遇到的错误
//只有 written == n 返回 nil
//
func CopyN(dst Writer, src Reader, n int64) (written int64, err error) {
    written, err = Copy(dst, LimitReader(src, n))
    if written == n {
        return n, nil
    }
    if written &amp;lt; n &amp;amp;&amp;amp; err == nil {
        // src stopped early; must have been EOF.
        err = EOF
    }
    return
}

//将 src 复制到 dst，直到在 src 上到达 EOF 或发生错误。
//返回 复制的字符数 和 复制过程中最早遇到的错误
//成功的 Copy 返回 err == nil，而非 err == EOF。
//由于 Copy 被定义为从 src 读取直到 EOF 为止，
//因此它不会将来自 Read 的 EOF 当做错误来报告。
func Copy(dst Writer, src Reader) (written int64, err error) {

    if rt, ok := dst.(ReaderFrom); ok {
        return rt.ReadFrom(src)
    }

    if wt, ok := src.(WriterTo); ok {
        return wt.WriteTo(dst)
    }
    buf := make([]byte, 32*1024)
    for {
        nr, er := src.Read(buf)
        if nr &amp;gt; 0 {
            nw, ew := dst.Write(buf[0:nr])
            if nw &amp;gt; 0 {
                written += int64(nw)
            }
            if ew != nil {
                err = ew
                break
            }
            if nr != nw {
                err = ErrShortWrite
                break
            }
            }
        if er == EOF {
            break
        }
        if er != nil {
            err = er
            break
        }
    }
    return written, err
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;最后看看io中定义的三个struct&lt;/p&gt;

&lt;p&gt;LimiteReader结构&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//LimiteReader 从R 中 读取　但限制为Ｎ个字符
//每次调用Read() 都将更新N
type LimitedReader struct {
    R Reader // underlying reader
    N int64  // max bytes remaining
}

//LimitReader 用来生成 LimiteReader实例
func LimitReader(r Reader, n int64) Reader { return &amp;amp;LimitedReader{r, n} }

func (l *LimitedReader) Read(p []byte) (n int, err error) {
    if l.N &amp;lt;= 0 {
        return 0, EOF //读取完毕后 返回EOF
    }
    if int64(len(p)) &amp;gt; l.N {
        p = p[0:l.N]
    }
    n, err = l.R.Read(p)
    l.N -= int64(n)     //更新N 来表示 剩余能读取的字符数
    return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SectionReader结构&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//SectionReader是一个struct（没有任何导出的字段）
//实现了 Read, Seek 和 ReadAt，同时，内嵌了 ReaderAt 接口。
type SectionReader struct {
    r     ReaderAt 
    base  int64 //基址 NewSectionReader 会将 base 设置为 off
    off   int64 //从 r 中的 off 偏移处开始读取数据
    limit int64 // limit - off = SectionReader 流的长度
}

// 返回一个 SectionReader
//它从 r 中的偏移量 off 处读取 n 个字节后以 EOF 停止
func NewSectionReader(r ReaderAt, off int64, n int64) *SectionReader {
    return &amp;amp;SectionReader{r, off, off, off + n}
}

func (s *SectionReader) Read(p []byte) (n int, err error) {
    if s.off &amp;gt;= s.limit {
        return 0, EOF
    }
    if max := s.limit - s.off; int64(len(p)) &amp;gt; max {
        p = p[0:max]
    }
    n, err = s.r.ReadAt(p, s.off)
    s.off += int64(n)
    return
}

//Seek() 中的 两种错误
var errWhence = errors.New(&amp;quot;Seek: invalid whence&amp;quot;)
var errOffset = errors.New(&amp;quot;Seek: invalid offset&amp;quot;)

func (s *SectionReader) Seek(offset int64, whence int) (ret int64, err error) {
    switch whence {
    default:
        return 0, errWhence
    case 0:
        offset += s.base
    case 1:
        offset += s.off
    case 2:
        offset += s.limit
    }
    if offset &amp;lt; s.base || offset &amp;gt; s.limit {
        return 0, errOffset
    }
    s.off = offset
    return offset - s.base, nil
}

func (s *SectionReader) ReadAt(p []byte, off int64) (n int, err error) {
    if off &amp;lt; 0 || off &amp;gt;= s.limit-s.base {
        return 0, EOF
    }
    off += s.base
    if max := s.limit - off; int64(len(p)) &amp;gt; max {
        p = p[0:max]
        n, err = s.r.ReadAt(p, off)
        if err == nil {
            err = EOF
        }
        return n, err
    }
    return s.r.ReadAt(p, off)
}

// 返回 SectionReader的大小
func (s *SectionReader) Size() int64 { 
    return s.limit - s.base 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;teeReader结构&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//将从 r 中读到的数据写入 w 中。
//所有经由它处理的从 r 的读取都匹配于对应的对 w 的写入。
//它没有内部缓存，即写入必须在读取完成前完成。
//任何在写入时遇到的错误都将作为读取错误返回。
type teeReader struct {
    r Reader
    w Writer
}

func TeeReader(r Reader, w Writer) Reader {
    return &amp;amp;teeReader{r, w}
}

func (t *teeReader) Read(p []byte) (n int, err error) {
    n, err = t.r.Read(p)
    if n &amp;gt; 0 {
        if n, err := t.w.Write(p[:n]); err != nil {
            return n, err
        }
    }
    return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;[返回顶部]()&lt;/p&gt;
</description>
    </item>
    <item>
      <title>interface</title>
      <link>http://pokerg.github.io/Programming Language/interface/</link>
      <pubDate>2013-08-26 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;
&lt;p&gt;If I could export one feature of Go into other languages, it would be interfaces.
&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;———Rob Pike&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;interface作为Golang的整个类型系统的基石，让Golang在基础编程哲学的探索上达到前所未有的高度。&amp;gt;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;——《Go语言编程》&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;接口是Java引入的特性。在软件工程上占有重要地位。而Golang变革了接口的概念。&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;我们考虑这样一个情况，有两个struct都实现了一些非常有用的小子集中的相关方法，这时有办法操作两个struct的任意一个就显得非常有用。那么我们该怎么办呢？这就是接口的作用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type s1 struct{
    ...//一些属性
}
type s2 struct{
    ...//一些属性
｝
func (a *s1)foo(){
    ...//具体实现1
}
func (b *s2)foo(){
    ...//具体实现2
｝
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;这时，如果我们有需要操作两个stuct中的任意一个，可以声明这样一个interface&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Foo interface{
    foo()
    //只要实现了foo()函数，就相当于实现了Foo接口 
    //我们就可以用接口来调用对象

}

func test(a Foo,b int){
    a.foo()
    //传进不同的struct对象，函数将调用不同的foo()方法
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;从这个例子，我们就能看出interface的作用，降低耦合性，可以让某个模块或功能重复利用。&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;我们来看看io包，其中最基本的也是最重要的两个接口Reader和Writer。我们说，只要实现了这两个接口，就基本拥有了IO的功能。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func ReadFrom(reader io.Reader,num int)([]byte,error){
    p := make([]byte,num)
    n,err：＝　reader.Read(p)
    if n &amp;gt; 0 {
        return p[:n],nill
    }
    return p,err
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;ReadFrom将io.Reader作为参数，我们可以从任何实现了io.Reader接口的地方读取数据&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//从标准输入流读取
data,err := ReadFrom（os.Stdin,10)

//从文件中读取
file, err1 := os.Open(util.GetProjectRoot() + &amp;quot;01.txt&amp;quot;)
data,err2 := ReadFrom（file,10)

//从字符串读取
data，err := ReadFrom(strings.NewReader(&amp;quot;from string&amp;quot;),10)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;这是strings包中关于Reader的Read的实现&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (r *Reader) Read(b []byte) (n int, err error) {
    if len(b) == 0 {
        return 0, nil
    }
    if r.i &amp;gt;= len(r.s) {
        return 0, io.EOF
    }
    n = copy(b, r.s[r.i:])
    r.i += n
    r.prevRune = -1
    return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;这里没有强制声明strings.Reader这个struct实现了哪个interface，但是它实现了Read方法，在Golang中也就实现了io.Reader这个接口。这种隐式的声明在Golang中术语叫做非侵入式接口。这样做的好处，我曾经在 &lt;strong&gt;初识Go语言&lt;/strong&gt; 中提过。&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;其一，Go语言的标准库，再也不需要绘制类库的继承树图。&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;其二，实现类的时候，只需要关心自己应该提供哪些方法，不用再纠结接口需要拆得多细才合理。接口由使用方按需定义，而不用事前规划。&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;其三，不用为了实现一个接口而导入一个包，因为多引用一个外部的包，就意味着更多的耦合。接口由使用方按自身需求来定义，使用方无需关心是否有其他模块定义过类似的接口。&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;Golang也可以通过接口的组合，实现一种抽向上的层次，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type ReadWriter interface {
    Reader
    Writer
}

type ReadCloser interface {
    Reader
    Closer
}

type WriteCloser interface {
    Writer
    Closer
}

type ReadWriteCloser interface {
    Reader
    Writer
    Closer
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;这几个接口都是Reader，Writer，Closer等基本接口的组合，可以说接口组合为Go程序建立起一个严密而有序的体系。&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;最后再谈谈一个有趣的interface ——interface｛｝
由于Go语言中任何对象实例都满足空接口interface{}，所以interface{}看起来像是可以指向任何对象的Any类型。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var v1 interface{} = 1 // 将int类型赋值给interface{}
var v2 interface{} = &amp;quot;abc&amp;quot; // 将string类型赋值给interface{}
var v3 interface{} = &amp;amp;v2 // 将*interface{}类型赋值给interface{}
var v4 interface{} = struct{ X int }{1}
var v5 interface{} = &amp;amp;struct{ X int }{1}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;当函数可以接受任意的对象实例时，我们会将其声明为interface{}，最典型的例子是标准库fmt中PrintXXX系列的函数，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func Printf(fmt string, args ...interface{})
func Println(args ...interface{})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;####总结&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;interface作为Golang类型系统的基石，为Golang工程形成了一个严密而清晰的体系，但其理念和使用却极为简洁，是Golang众多优秀特性中极为突出的一个，是我们学习Golang必须掌握的一点。&lt;/p&gt;

&lt;p&gt;[返回顶部]()&lt;/p&gt;
</description>
    </item>
    <item>
      <title>苦难</title>
      <link>http://pokerg.github.io/Philosophy/%E8%8B%A6%E9%9A%BE/</link>
      <pubDate>2013-08-24 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&amp;emsp;&amp;emsp;面对社会悲剧，我们有理想、信念、正义感、崇高感支撑着我们，我们相信自己在精神上无比地优越于那迫害乃至毁灭我们的恶势力，因此我们可以含笑受难，慷慨赴死。我们是舞台上的英雄，哪怕眼前这个剧场里的观众全都浑浑噩噩，是非颠倒，我们仍有勇气把戏演下去，演给我们心目中绝对清醒公正的观众看，我们称这观众为历史、上帝或者良心。&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;可是，面对自然悲剧，我们有什么呢？这里没有舞台，只有空漠无际的苍穹。我们不是英雄，只是朝生暮死的众生。任何人间理想都抚慰不了生老病死的悲哀，在天灾人祸面前也谈不上什么正义感。当史前人类遭受大洪水的灭顶之灾时，当庞贝城居民被维苏威火山的岩浆吞没时，他们能有什么慰藉呢？地震,海啸，车祸，空难，瘟疫，绝症&amp;hellip;&amp;hellip;大自然的恶势力轻而易举地把我们或我们的亲人毁灭。我们面对的是没有灵魂的敌手，因而不能以精神的优越自慰，却愈发感到了生命的卑微。没有上帝来拯救我们，因为这灾难正是上帝亲手降下。我们愤怒，但无从泄愤。我们冤屈，但永无申冤之日。我们反抗，但我们的反抗孤立无助，注定失败。&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;然而我们未必就因此倒下。也许，没有浪漫气息的悲剧是我们最本质的悲剧，不具有英雄色彩的勇气是我们最真实的勇气。在无可告慰的绝望中，我们咬牙挺住。我们挺立在那里，没有观众，没有证人，也没有期待，没有援军。我们不倒下，仅仅是因为我们不肯让自己倒下。我们以此维护了人的最高的也是最后的尊严————人在神面前的尊严。&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;————周国平&lt;/p&gt;
</description>
    </item>
    <item>
      <title>channel的两个特性</title>
      <link>http://pokerg.github.io/Programming Language/channel%E7%9A%84%E4%B8%A4%E4%B8%AA%E7%89%B9%E6%80%A7/</link>
      <pubDate>2013-08-22 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&amp;emsp;&amp;emsp;channel是Go提供的语言级goroutine间的通信方式。它提供了一种优雅而又强大的，在不使用锁的情况下，从某个goroutine向其他goroutine发送数据流的方式。&lt;/p&gt;

&lt;p&gt;&amp;esmp;emsp;这次着重讨论channel的两个重要特性。参考：&lt;a href=&#34;http://dave.cheney.net/2013/04/30/curious-channels&#34;&gt;http://dave.cheney.net/&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;04&lt;/sub&gt;/30/curious-channels&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;被关闭的channel不会block&lt;/h2&gt;

&lt;p&gt;&amp;esmp;emsp;一个channel一旦被关闭，就不能再向其发送数据，但是仍然可以获取其中的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
    ch := make(chan bool, 2)
    ch &amp;lt;- true
    ch &amp;lt;- true
    close(ch)

    for i := 0; i &amp;lt; cap(ch) +1 ; i++ {
            v, ok := &amp;lt;- ch
            fmt.Println(v, ok)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们创造了缓冲区为两个值的channel。&lt;br/&gt;
输出结果:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;true true
true true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个程序首先输出发送到channel的两个值，然后在第三次&amp;lt;-时返回false和false。第一个false是channel类型的零值。第二个表示channel的启用状态。&lt;/p&gt;

&lt;p&gt;能够检测channel 的启用状态也是很有用的一个特性。可用于对channel进行range操作。&lt;/p&gt;

&lt;p&gt;&amp;esmp;emsp;我们在这里举一个close channel的有用例子。首先看这个程序：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;sync&amp;quot;
    &amp;quot;time&amp;quot;
)

func main() {
    finish := make(chan bool)
    var done sync.WaitGroup
    done.Add(1)
    go func() {
            select {
            case &amp;lt;-time.After(1 * time.Hour):
            case &amp;lt;-finish:
            }
            done.Done()
    }()
    t0 := time.Now()
    finish &amp;lt;- true // 发送关闭信号
    done.Wait()    // 等待 goroutine 结束
    fmt.Printf(&amp;quot;Waited %v for goroutine to stop\n&amp;quot;, time.Since(t0))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个程序能够正常结束 &lt;code&gt;Waited 129.607us for goroutine to stop&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;但是存在一些问题。首先finish channel 是不带缓冲的。如果接收方忘记了在select语句中添加finish，向其发送数据可能会导致阻塞。当然可以通过对要发送到的select块进行封装，以确保不会阻塞，或者设置带有缓冲的channel。但是，如果有许多goroutine都监听在finish channel上，那就需要跟踪这个情况，并且记住发送正确数量的数据给finish channel。如果无法控制goroutine的创建会很棘手；同时它们也可能是由程序的另一部分创建的，例如在响应网络请求的时候。&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;对于这种情况，我们可以利用已经关闭的channel会实时返回这一机制。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;sync&amp;quot;
    &amp;quot;time&amp;quot;
)

func main() {
    const n = 100
    finish := make(chan bool)
    var done sync.WaitGroup
    for i := 0; i &amp;lt; n; i++ { 
            done.Add(1)
            go func() {
                    select {
                    case &amp;lt;-time.After(1 * time.Hour):
                    case &amp;lt;-finish:
                    }
                    done.Done()
            }()
    }
    t0 := time.Now()
    close(finish)    // 关闭 finish 使其立即返回
    done.Wait()      // 等待所有的 goroutine 结束
    fmt.Printf(&amp;quot;Waited %v for %d goroutines to stop\n&amp;quot;, time.Since(t0), n)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;emsp;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Waited 231.385us for 100 goroutines to stop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;那么这里发生了什么？当 finish channel 被关闭后，它会立刻返回。那么所有等待接收 time.After channel 或 finish 的 goroutine 的 select 语句就立刻完成了，并且 goroutine 在调用 done.Done() 来减少 WaitGroup 计数器后退出。这个强大的机制在无需知道未知数量的 goroutine 的任何细节而向它们发送信号而成为可能，同时也不用担心死锁。&lt;/p&gt;

&lt;h2&gt;nil channel 永远都是 block&lt;/h2&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;再看Unknwon的《Go fundamental programming》时，他提到过一个类似于这样的例子。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// WaitMany 等待 a 和 b 关闭。
func WaitMany(a, b chan bool) {
    var aclosed, bclosed bool
    for !aclosed || !bclosed {
            select {
            case &amp;lt;-a:
                    aclosed = true
            case &amp;lt;-b:
                    bclosed = true
            }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;WaitMany() 用于等待 channel a 和 b 关闭是个不错的方法，但是有一个问题。假设 channel a 首先被关闭，然后它会立刻返回。但是由于 bclosed 仍然是 false，程序会进入死循环，而让 channel b 永远不会被判定为关闭。&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;当时他也没用给出什么好的解决办法。在这里解决这个问题的比较好的办法就是利用nil channel的阻塞特性。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;time&amp;quot;
)

func WaitMany(a, b chan bool) {
    for a != nil || b != nil {
            select {
            case &amp;lt;-a:
                    a = nil 
            case &amp;lt;-b:
                    b = nil
            }
    }
}

func main() {
    a, b := make(chan bool), make(chan bool)
    t0 := time.Now()
    go func() {
            close(a)
            close(b)
    }()
    WaitMany(a, b)
    fmt.Printf(&amp;quot;waited %v for WaitMany\n&amp;quot;, time.Since(t0))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;在重写的 WaitMany() 中，一旦接收到一个值，就将 a 或 b 的引用设置为 nil。当 nil channel 是 select 语句的一部分时，它实际上会被忽略，因此，将 a 设置为 nil 便会将其从 select 中移除，仅仅留下 b 等待它被关闭，进而退出循环。&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;总的来说，close和nil channel这些特性非常简单，但是它们的功能强大，使得创建高并发程序变得简单。&lt;/p&gt;

&lt;p&gt;[返回顶部]()&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Go Build in</title>
      <link>http://pokerg.github.io/Programming Language/Go-Build-in/</link>
      <pubDate>2013-08-20 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;内置关键字（25个 均为小写）&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;break&amp;emsp;&amp;emsp;default&amp;emsp;&amp;emsp;func&amp;emsp;&amp;emsp;interface&amp;emsp;&amp;emsp;select&lt;br /&gt;
case&amp;emsp;&amp;emsp;defer&amp;emsp;&amp;emsp;go&amp;emsp;&amp;emsp;map&amp;emsp;&amp;emsp;struct&lt;br /&gt;
chan&amp;emsp;&amp;emsp;else&amp;emsp;&amp;emsp;goto&amp;emsp;&amp;emsp;package&amp;emsp;&amp;emsp;switch&lt;br /&gt;
const&amp;emsp;&amp;emsp;fallthrough&amp;emsp;&amp;emsp;if&amp;emsp;&amp;emsp;range&amp;emsp;&amp;emsp;type&lt;br /&gt;
continue&amp;emsp;&amp;emsp;for&amp;emsp;&amp;emsp; import&amp;emsp;&amp;emsp;return&amp;emsp;&amp;emsp;var &lt;br/&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;内置类型&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;值类型：&lt;br /&gt;
bool&lt;br /&gt;
byte&lt;br /&gt;
int(32 or 64), int8, int16, int32, int64&lt;br /&gt;
uint(32 or 64), uint8(byte), uint16, uint32, uint64&lt;br /&gt;
float32, float64&lt;br /&gt;
string&lt;br /&gt;
complex64, complex128   &amp;ndash;复数&lt;br /&gt;
array    &amp;ndash; 固定长度的数组&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;引用类型：(指针类型)&lt;br /&gt;
slice   &amp;ndash; 切片&lt;br /&gt;
map        &amp;ndash; 映射&lt;br /&gt;
chan    &amp;ndash; 管道&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;内置函数&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;append  &amp;ndash; 把东西增加到slice里面,返回修改后的slice&lt;br /&gt;
close   &amp;ndash; 关闭channel&lt;br /&gt;
delete    &amp;ndash; 从map中删除key对应的value&lt;br /&gt;
panic    &amp;ndash; 停止常规的goroutine&lt;br /&gt;
recover &amp;ndash; 允许程序定义goroutine的panic动作&lt;br /&gt;
imag    &amp;ndash; 返回complex的实部&lt;br /&gt;
real    &amp;ndash; 返回complex的虚部&lt;br /&gt;
make    &amp;ndash; 返回Type本身(只能应用于slice, map, channel)&lt;br /&gt;
new        &amp;ndash; 返回指向Type的指针&lt;br /&gt;
cap        &amp;ndash; 容量，容积capacity&lt;br /&gt;
copy    &amp;ndash; 复制slice，返回复制的数目&lt;br /&gt;
len        &amp;ndash; 返回长度&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;内置接口&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;type error interface {        //只要实现了Error()函数，返回值为String的都实现了err接口
    Error() string
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    <item>
      <title>Go语言代码风格</title>
      <link>http://pokerg.github.io/Programming Language/Go%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/</link>
      <pubDate>2013-08-19 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;代码必须是本着写给人阅读的原则来编写，只不过顺便给机器执行而已。&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;mdash;《计算机程序设计与解释》&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;对于程序员来说，代码风格的重要性自然是不必多说的，我曾经买过一本《Java编程风格》，我们想想光是代码风格就要写成一本书，是多么让人头疼。而Go语言很有可能是第一个将代码风格强制统一的语言。一些在其他语言中编译器可以通过的问题，在Go编译器中会被认为是编译错误。由于刚好Go语言强制规定的代码形式都是我常用的，也是我很喜欢的，所以非常幸运啊。。（这也是我喜欢Go语言的一个重要原因）。&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;Go语言关于编码规范的问题，主要分为两类，一是：由编译器进行的强制代码规范；二是：由go fmt 格式化的非强制性编码风格。&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;Go语言的强制代码规范是Go设计者认为最需要统一的风格。首先，就是命名，Go语言对于可见性的规则不像C语言用 private public 等关键字来声明可见性，而是规定暴露于外部的名字用大写开头，不需要暴露的用小写字母开头。目前比较流行的命名法有两种：骆驼命名法 和 下划线法。Go语言明确宣告支持骆驼命名法，排斥下划线法。虽然以前写C语言都用的是下划线法，但是后来用php，js，python什么的用的是都是骆驼命名法，而且骆驼命名法打起来明显比下划线法方便，所以也是很喜欢。&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;还有就是关于花括号的问题。最初的风格为K&amp;amp;R，后来又有了MS风格，可能因为Go语言的设计者有Ken Thompson，所以，，我们还是使用他所创的那种风格吧。而且我觉得这样写代码更加紧凑，而且清晰度也很高。&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;另外Go工具链中还有个go fmt用来格式化代码。它可以调整语句的位置，重新摆放花括号的位置，以制表符来缩进，添加空格等等。&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;总的来说，Go语言的代码规范可以算是集C语言出世这几十年来的思想之大成，优雅，规范，非常对我胃口&lt;/p&gt;
</description>
    </item>
    <item>
      <title>革命</title>
      <link>http://pokerg.github.io/Philosophy/%E9%9D%A9%E5%91%BD/</link>
      <pubDate>2013-08-16 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;加缪的《反抗者》写的很精彩，周国平的点评也很精彩，我忍不住想把它摘录下来&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;“反抗”在本质上是肯定的，反抗者总是为了捍卫某种价值才说“不”的，他要捍卫的这种价值并不属于个人，而是被视为人性的普遍价值。因此，反抗使个人摆脱孤独。“我反抗，故我们存在”这是反抗的意义所在。但其中也隐含着危险，便是把所要捍卫的价值绝对化。其表现之一，就是以历史的名义进行的反抗，即革命。&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;对卢梭的《社会契约论》的批判是《反抗者》中的精彩篇章。加缪一针见血地指出，卢梭的 这部为法国革命奠基的著作是新福音书，新宗教，新神学。革命的特点是要在历史中实现某 种绝对价值，并且声称这种价值的实现就是人类的最终统一和历史的最终完成。这一现代革命概念肇始于法国革命。革命所要实现的那个绝对价值必定是抽象的，至高无上的，在卢梭 那里，它就是与每个人的意志相分离的&amp;rdquo;总体意志&amp;rdquo;。&amp;rdquo;总体意志&amp;rdquo;被宣布为神圣的普遍理 性的体现，因而作为这&amp;rdquo;总体意志&amp;rdquo;之载体的抽象的&amp;rdquo;人民&amp;rdquo;也就成了新的上帝。圣·鞠斯 特进而赋予&amp;rdquo;总体意志&amp;rdquo;以道德含义，并据此把&amp;rdquo;任何在细节上反对共和国&amp;rdquo;亦即触犯&amp;rdquo;总 体意志&amp;rdquo;的行为都宣判为罪恶，从而大开杀戒，用断头台来担保品德的纯洁。浓烈的道德化 色彩也正是现代革命的特点之一，正如加缪所说：&amp;rdquo;法国革命要把历史建立在绝对纯洁的原 则上，开创了形式道德的新纪元。&amp;rdquo;而形式道德是要吃人的，它导致了无限镇压原则。它对 心理的威慑力量甚至使无辜的受害者自觉有罪。我们由此而可明白，圣·鞠斯特本人后来从 被捕到处死为何始终保持着沉默，斯大林时期冤案中的那些被告又为何几乎是满怀热情地给 判处他们死刑的法庭以配合。在这里起作用的已经不是法律，而是神学。既然是神圣的&amp;rdquo;人 民&amp;rdquo;在审判，受审者已被置于与&amp;rdquo;人民&amp;rdquo;相对立的位置上，因而在总体上是有罪的，细节就完全不重要了。&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;革命者自命对于历史负有使命，要献身于历史的终极目标。可是他们是从哪里获知这个终极目标的呢？雅斯贝尔斯指出：人处于历史中，所以不可能把握作为整体的历史。加缪引证了这一见解，进一步指出：因此，任何历史举动都是冒险，无权为任何绝对立场辩护。绝对的理性主义就如同绝对的虚无主义一样，也会把人类引向荒漠。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>初识Go语言[2]</title>
      <link>http://pokerg.github.io/Programming Language/%E5%88%9D%E8%AF%86Go%E8%AF%AD%E8%A8%80%5B2%5D/</link>
      <pubDate>2013-08-14 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&amp;emsp;今天我们接着昨天的话题&lt;/p&gt;

&lt;h2&gt;interface&lt;/h2&gt;

&lt;p&gt;&amp;emsp;Go语言的设计者之一&lt;strong&gt;Rob Pike&lt;/strong&gt;说过，如果只能选择一个Go语言的特性移植到其他语言，他会选择接口。&lt;/p&gt;

&lt;p&gt;&amp;emsp;Go语言对编程哲学的变革正是在于接口。&lt;strong&gt;《Go语言编程》&lt;/strong&gt;中说道:&amp;ldquo;如果说goroutine和channel是支撑起Go语言的并发模型的基石，让Go语言在如今集群化和多核化的时代成为一道极为亮丽的风景，那么接口是Go语言整个类型系统的基石，让Go语言在基础编程哲学的探索上达到前所未有的高度&amp;rdquo;,这段话可谓是极其之高的评价。&lt;/p&gt;

&lt;p&gt;&amp;emsp;与其他语言的接口相比，Go语言的接口是&amp;rdquo;非侵入式&amp;rdquo;的，即不需要明确声明接口的继承，只需要实现其所有函数，就实现了该接口。&lt;/p&gt;

&lt;p&gt;&amp;emsp;这样做的好处有很多。首先Java，C++等类库的继承树变得毫无意义;其次，我们不用再纠结于接口应该拆的多细;再次，不用为了实现一个接口而导入一个包。&lt;/p&gt;

&lt;p&gt;&amp;emsp;Go语言中接口的各种操作也是非常方便的，赋值，查询，组合都能非常优雅的完成。&lt;/p&gt;

&lt;p&gt;&amp;emsp;最后再说说interface｛｝这个在Go语言中的地位类似于Java中的Object,interface{]是可以指向任何对象的Any类型。最为经典的fmt库中的Print等函数 &lt;code&gt;func Printf（fmt string,args ...interface{})&lt;/code&gt; 我们可以用interface{}实现接受任意数量任意类型的参数 再配合上接口查询 类型查询 循环等写出非常漂亮的代码。&lt;/p&gt;

&lt;h2&gt;错误处理&lt;/h2&gt;

&lt;p&gt;&amp;emsp;自从C++以来，错误处理不仅作为一种编程范式，也在语言层面上增加了错误处理的支持。Go语言中的错误处理有个标准模式，即error接口&lt;/p&gt;

&lt;p&gt;&amp;emsp;defer也是个非常有意思的东西，它类似C++中的析构函数，如果你是C/C++程序员，你肯定经历过打开一个文件句柄却忘记关闭的情况，使用defer就能很漂亮的解决这个问题。&lt;/p&gt;

&lt;p&gt;&amp;emsp;panic()和recover()作为错误处理的两个内置函数，使用起来也非常优雅。&lt;/p&gt;

&lt;h2&gt;OOP特性&lt;/h2&gt;

&lt;p&gt;&amp;emsp;Go语言没有其他面向对象编程语言那些继承，虚函数，构造函数等的概念，甚至没有类的概念。有的只是继承于C语言的struct。Go语言放弃了包括继承在内的大量面向对象特性，只保留了组合这个最基本的特性。
Go语言中可以为任何类型添加方法，自然struct加上方法也就是类，组合也就能实现继承的性质，而且Go语言中没有this指针这个让无数初学者头疼的玩意，在Go语言中本体对象是显式传递的。&lt;/p&gt;

&lt;p&gt;&amp;emsp;Go语言对面向对象编程的支持是语言类型中的天然组成部分，没有太多花里胡哨的东西，整个类型系统再与接口结合，浑然一体。我们用学习C++高级特性的功夫就可以用Go语言编出很多漂亮的工程。&lt;/p&gt;

&lt;p&gt;####总结&lt;/p&gt;

&lt;p&gt;&amp;emsp;Go语言语法给我的感觉就是  &lt;strong&gt;简洁  优雅&lt;/strong&gt; ，它通过强大的语言支持和简单的组合就能完成其他语言需要深厚的功底和大量功夫所能实现的特性。 与vim的设计哲学 &lt;em&gt;命令的组合&lt;/em&gt; 也非常相近。&lt;/p&gt;

&lt;p&gt;&amp;emsp;我是一个非常喜欢简洁，优雅的人，所以当接触到Go的不久，我就为她所痴迷，相信Go势必也会在将来占有很重要的地位。&lt;/p&gt;

&lt;p&gt;[返回顶部]()&lt;/p&gt;
</description>
    </item>
    <item>
      <title>中蛊者</title>
      <link>http://pokerg.github.io/Philosophy/%E4%B8%AD%E8%9B%8A%E8%80%85/</link>
      <pubDate>2013-08-14 12:00:00 +0800</pubDate>
      <description>&lt;blockquote&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;人类天性中有一种不可消除的冲动，就是要对世界和人生的问题追根究底。这种冲动虽说提高了人类存在的精神品质，但却不利于人类在生物学意义的存在。仿佛是为了保护人类的存在，上天让这种冲动在少数人身上表现的格外强烈。古往今来，在世界的不同角落，都有这样一些怀着强烈的形而上学冲动的人，不妨说，他们是一些中了形而上学之蛊的人。
&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;ndash;周国平&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;小时候我也经常有这种感觉，觉得周围的一切都是不真实的，觉得自己生活在一个梦里，自己的各种行为以及周围的各种事都是在梦里产生的，而自己只不过在做梦。后来我又想过，我怎么能确定我是在做梦，而不是在梦里又在做梦？。就这样我陷入了一种恐慌，究竟什么是真实？究竟人生的意义是什么？&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;相信每个人都从出生就在寻找着解决自己困惑的方法，我是谁？我从哪来？我将要去往何处？ 人类在黑暗中蹒跚前行，哲学家站在了时代思想的顶峰，看到远方理想的目的地及通往理想目的地的道路。至少人类要有路可走。&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;哲学家与思想家不同，思想家追求合理，哲学家追求绝对。为人类的存在寻求一种形而上的绝对的永恒的意义是哲学家探索哲学的目的。宗教正是理想主义之极致，理想主义所相信的绝对精神价值不过是神的同语罢了。上帝是人存在的终极意义和向上动力。但是愈是渴求信仰的灵魂愈是难以盲信。尼采曾绝望地祈求上帝赐予他疯狂，只有疯狂才能让他继续信仰上帝。&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;哲学家是在无神的沙漠跋涉和虔诚之心破碎的人。深受形而上学之蛊的迫害，他们的才能使得他们成为精神领域的天才，但是即使这样，这种强烈的冲动也有可能毁了他们，尼采最终还是疯了，不用再受折磨，但自此以后他的灵魂也就处于重重的黑暗之中了。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>初识Go语言[1]</title>
      <link>http://pokerg.github.io/Programming Language/%E5%88%9D%E8%AF%86Go%E8%AF%AD%E8%A8%80%5B1%5D/</link>
      <pubDate>2013-08-13 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&amp;emsp;作为一个刚接触Go没几天的Gopher,没什么能力对其原理和高级用法做出分析和评价，姑且就对其语法形式谈谈我的看法，也算是对我这几天来的一个总结和回顾，姑妄言之，大家莫怪。&lt;/p&gt;

&lt;h2&gt;变量的声明&lt;/h2&gt;

&lt;p&gt;&amp;emsp;首先最基本的声明方式     &lt;code&gt;var a,b int&lt;/code&gt;
和C语言相比 仅仅是把 类型 和 变量名称的顺序调换，但是我认为这样看起来比C语言可读性更高，而且var的引入使注意力更加集中（可能是前段时间php，js，python什么的看多了吧)&lt;/p&gt;

&lt;p&gt;&amp;emsp;再者 &lt;code&gt;a,b := 1,2&lt;/code&gt; 这种声明方式确实让我耳目一新，Go语言是类型安全的，但是这种写法让我有了动态语言的感觉，使用起来很方便，也很舒服。&lt;/p&gt;

&lt;h2&gt;类型&lt;/h2&gt;

&lt;p&gt;&amp;emsp;Go与C相比类型多了很多，complex,error,map,interface,chan 等等，其中最让我感兴趣的是map 和 interface（chan 是并发的内容，暂不考虑), interface 一会专门讲，我们先谈谈map，php等语言的数组就具有map类似的功能，Go的map使用起来也很方便，赋值，删除，查找做的非常简单和精巧。&lt;/p&gt;

&lt;p&gt;&amp;emsp;slice看起来很像指向数组的指针，但还有些许不同，它还有元素个数和分配的空间两个“属性”，slice和数组很容易让人联想到STL里的vector和数组的关系，slice的动态扩展空间的能力和各种管理功能很好很强大。&lt;/p&gt;

&lt;h2&gt;流程控制&lt;/h2&gt;

&lt;p&gt;&amp;emsp;Go语言的流程控制语句少了小括号，现在很多语言都去掉了这个，让我们可以少打很多字&lt;/p&gt;

&lt;p&gt;&amp;emsp;switch语句默认加了break，这个确实让我很兴奋，不用再担心少写break而出现bug&lt;/p&gt;

&lt;p&gt;&amp;emsp;Go语言的循环语言只有for关键字（确实这是最常用的，C语言中我也很少用while和do-while），Go中for的形式非常灵活，功能也很完善。&lt;/p&gt;

&lt;p&gt;&amp;emsp;goto被许许多多的人所诟病，但是对于Go这样一个仅有25个关键字的语言来说，仍然支持goto关键字，说明goto在某些场合下确实是很合适的。（linux内核中goto出现的频率之高！！！）。break和continue 可以带标签，着实让我感慨，真是为程序员考虑啊。以后再也不用为多重循环的跳转头疼了。&lt;/p&gt;

&lt;h2&gt;函数&lt;/h2&gt;

&lt;p&gt;&amp;emsp;Go语言函数的关键字，让我看着不太爽，func感觉像是被剪掉尾巴的孔雀，缩写的太难看，要不function 要不 fn 多好。&lt;/p&gt;

&lt;p&gt;&amp;emsp;因为Go的函数是多返回值的，所以它的函数头，返回值位于后头，这样写也挺好 &lt;code&gt;func add(a , b int)(ret int,err error)｛｝&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;Go函数可以有多个返回值，这个是迄今为止Go语言与其他语言最大的不同，结合上Go语言的多重赋值，Go语言的代码会很简洁、优雅。&lt;/p&gt;

&lt;p&gt;######结尾&lt;/p&gt;

&lt;p&gt;&amp;emsp;今天我们就先谈论到这，明天我们说说Go语言的interface，error，和 OOP特性。&lt;/p&gt;

&lt;p&gt;[返回顶部]()&lt;/p&gt;
</description>
    </item>
    <item>
      <title>HOJ 2654  Printer Queue</title>
      <link>http://pokerg.github.io/ACM/HOJ-2654--Printer-Queue/</link>
      <pubDate>2013-04-09 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;
&lt;/p&gt;
&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;
    The only printer in the computer science students&#39; union is experiencing an extremely heavy workload. Sometimes there are a hundred jobs in the printer queue and you may have to wait for hours to get a single page of output. Because some jobs are more important than others, the Hacker General has invented and implemented a simple priority system for the print job queue. Now, each job is assigned a priority between 1 and 9 (with 9 being the highest priority, and 1 being the lowest), and the printer operates as follows.
&lt;/p&gt;
&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;
    &lt;img src=&#34;http://acm.hit.edu.cn/hoj/static/img/pic/26541.bmp&#34; alt=&#34;&#34; style=&#34;margin:10px; padding:0px&#34; /&gt;
&lt;/p&gt;
&lt;ul style=&#34;margin:0px; padding:15px 0px 15px 30px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; font-size:16px; line-height:20px; background-color:rgb(247,247,247)&#34;&gt;
    &lt;li style=&#34;margin:0px; padding:0px&#34;&gt;
        The first job J in queue is taken from the queue.
    &lt;/li&gt;
    &lt;li style=&#34;margin:0px; padding:0px&#34;&gt;
        If there is some job in the queue with a higher priority than job J, thenmove J to the end of the queue without printing it.
    &lt;/li&gt;
    &lt;li style=&#34;margin:0px; padding:0px&#34;&gt;
        Otherwise, print job J (and do not put it back in the queue).
    &lt;/li&gt;
&lt;/ul&gt;
&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;
    In this way, all those importantmuffin recipes that the Hacker General is printing get printed very quickly. Of course, those annoying term papers that others are printing may have to wait for quite some time to get printed, but that&#39;s life.
&lt;/p&gt;
&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;
    Your problem with the new policy is that it has become quite tricky to determine when your print job will actually be completed. You decide to write a program to figure this out. The program will be given the current queue (as a list of priorities) as well as the position of your job in the queue, and must then calculate how long it will take until your job is printed, assuming that no additional jobs will be added to the queue. To simplifymatters, we assume that printing a job always takes exactly one minute, and that adding and removing jobs from the queue is instantaneous.
&lt;/p&gt;
&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;
&lt;/p&gt;
&lt;h3 style=&#34;margin:0px; padding:0px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; line-height:20px; background-color:rgb(247,247,247)&#34;&gt;
    Input
&lt;/h3&gt;
&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;
&lt;/p&gt;
&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;
    One line with a positive integer: the number of test cases (at most 100). Then for each test case:
&lt;/p&gt;
&lt;ul style=&#34;margin:0px; padding:15px 0px 15px 30px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; font-size:16px; line-height:20px; background-color:rgb(247,247,247)&#34;&gt;
    &lt;li style=&#34;margin:0px; padding:0px&#34;&gt;
        One line with two integers n and m, where n is the number of jobs in the queue (1 ≤ n ≤ 100) and m is the position of your job (0 ≤ m ≤ n - 1). The first position in the queue is number 0, the second is number 1, and so on.
    &lt;/li&gt;
    &lt;li style=&#34;margin:0px; padding:0px&#34;&gt;
        One linewith n integers in the range 1 to 9, giving the priorities of the jobs in the queue. The first integer gives the priority of the first job, the second integer the priority of the second job, and so on.
    &lt;/li&gt;
&lt;/ul&gt;
&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;
&lt;/p&gt;
&lt;h3 style=&#34;margin:0px; padding:0px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; line-height:20px; background-color:rgb(247,247,247)&#34;&gt;
    Output
&lt;/h3&gt;
&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;
&lt;/p&gt;
&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;
    For each test case, print one line with a single integer; the number of minutes until your job is completely printed, assuming that no additional print jobs will arrive.
&lt;/p&gt;
&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;
&lt;/p&gt;
&lt;h3 style=&#34;margin:0px; padding:0px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; line-height:20px; background-color:rgb(247,247,247)&#34;&gt;
    Sample Input
&lt;/h3&gt;
&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;
&lt;/p&gt;
&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;
&lt;/p&gt;
&lt;pre style=&#34;margin-top:0px; margin-bottom:0px; padding:5px; background-color:rgb(224,224,224); font-size:14px; line-height:16px; overflow:auto; font-family:Consolas,&#39;Lucida Console&#39;,&#39;Andale Mono&#39;,&#39;Bitstream Vera Sans Mono&#39;,&#39;Courier New&#39;,Courier; color:rgb(51,51,51)&#34;&gt;3
1 0
5
4 2
1 2 3 4
6 0
1 1 9 1 1 1&lt;/pre&gt;
&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;
&lt;/p&gt;
&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;
&lt;/p&gt;
&lt;h3 style=&#34;margin:0px; padding:0px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; line-height:20px; background-color:rgb(247,247,247)&#34;&gt;
    Sample Output
&lt;/h3&gt;
&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;
&lt;/p&gt;
&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;
&lt;/p&gt;
&lt;pre style=&#34;margin-top:0px; margin-bottom:0px; padding:5px; background-color:rgb(224,224,224); font-size:14px; line-height:16px; overflow:auto; font-family:Consolas,&#39;Lucida Console&#39;,&#39;Andale Mono&#39;,&#39;Bitstream Vera Sans Mono&#39;,&#39;Courier New&#39;,Courier; color:rgb(51,51,51)&#34;&gt;1
2
5&lt;/pre&gt;
&lt;br /&gt;

&lt;p&gt;
    &lt;span style=&#34;font-size:24px&#34;&gt;题解：&lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
    &lt;span style=&#34;font-size:24px&#34;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;/span&gt;&lt;span style=&#34;font-size:18px&#34;&gt;模拟个队列&lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
    &lt;span style=&#34;font-size:18px&#34;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 要注意 当front 找到 rear 没有比它大的点 time++&lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
    &lt;span style=&#34;font-size:18px&#34;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;如果这个点是自己的那个点，直接输出。&lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
    &lt;span style=&#34;font-size:18px&#34;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 另外如果front指向的是自己的点，不能打印的话，标记位置也得跟着变 m = rear - 1&lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
    &lt;span style=&#34;font-size:18px&#34;&gt;&lt;br /&gt;
    &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
    &lt;span style=&#34;font-size:18px&#34;&gt;&lt;/span&gt;
&lt;/p&gt;
&lt;pre name=&#34;code&#34; class=&#34;cpp&#34;&gt;#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cstdlib&amp;gt;
#include &amp;lt;cstring&amp;gt;
int front,rear;
int q[10005];
int main(){
    int cases,time,n,m,ok;
    scanf(&amp;quot;%d&amp;quot;,&amp;amp;cases);
    while(cases--){
        front = rear = 0;
        time = 0;
        scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;m);
        for(int i = 0; i &amp;lt; n; i++){
            scanf(&amp;quot;%d&amp;quot;,&amp;amp;q[i]);
            rear++;
        }
        while(front &amp;lt;= rear){
            int i;
            for(i = front; i &amp;lt; rear; i++)
                if(q[i] &amp;gt; q[front]){
                    q[rear++] = q[front];
                    break;
                }
            if(i &amp;gt;= rear){
                time += 1;
                if(front == m){
                    printf(&amp;quot;%d\n&amp;quot;,time);
                    break;
                }
                else
                    front ++;
            }
            else if(front == m) 
                m = rear - 1;
            else 
                front++;
        }
    }
    return 0;
}

        
&lt;/pre&gt;
&lt;br /&gt;
&lt;br /&gt;

&lt;p&gt;
&lt;/p&gt;
&lt;p&gt;
    &lt;span style=&#34;font-size:18px&#34;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
    &lt;br /&gt;
    
&lt;/p&gt;
</description>
    </item>
    <item>
      <title>HOJ 2385 Cube Stacking</title>
      <link>http://pokerg.github.io/ACM/HOJ-2385-Cube-Stacking/</link>
      <pubDate>2013-04-09 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;
&lt;/p&gt;
&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;
    Farmer John and Betsy are playing a game with N (1 &amp;lt;= N &amp;lt;= 30,000)identical cubes labeled 1 through N. They start with N stacks, each containing a single cube. Farmer John asks Betsy to perform P (1&amp;lt;= P &amp;lt;= 100,000) operation. There are two types of operations: moves and counts.
&lt;/p&gt;
&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;
&lt;/p&gt;
&lt;ul style=&#34;margin:0px; padding:15px 0px 15px 30px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; font-size:16px; line-height:20px; background-color:rgb(247,247,247)&#34;&gt;
    &lt;li style=&#34;margin:0px; padding:0px&#34;&gt;
        In a move operation, Farmer John asks Bessie to move the stack containing cube X on top of the stack containing cube Y.
    &lt;/li&gt;
    &lt;li style=&#34;margin:0px; padding:0px&#34;&gt;
        In a count operation, Farmer John asks Bessie to count the number of cubes on the stack with cube X that are under the cube X and report that value.
    &lt;/li&gt;
&lt;/ul&gt;
&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;
    Write a program that can verify the results of the game.
&lt;/p&gt;
&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;
    &lt;span style=&#34;margin:0px; padding:0px; font-size:18px; line-height:28px&#34;&gt;Input&lt;/span&gt;
&lt;/p&gt;
&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;
    * Line 1: A single integer, P
&lt;/p&gt;
&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;
    * Lines 2..P+1: Each of these lines describes a legal operation. Line 2 describes the first operation, etc. Each line begins with a &#39;M&#39; for a move operation or a &#39;C&#39; for a count operation. For move operations, the line also contains two integers: X and Y.For count operations, the line also contains a single integer: X.
&lt;/p&gt;
&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;
    Note that the value for N does not appear in the input file. No move operation will request a move a stack onto itself.
&lt;/p&gt;
&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;
    &lt;span style=&#34;margin:0px; padding:0px; font-size:18px; line-height:28px&#34;&gt;Output&lt;/span&gt;
&lt;/p&gt;
&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;
    Print the output from each of the count operations in the same order as the input file.
&lt;/p&gt;
&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;
    &lt;span style=&#34;margin:0px; padding:0px; font-size:18px; line-height:28px&#34;&gt;Sample Input&lt;/span&gt;
&lt;/p&gt;
&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;
&lt;/p&gt;
&lt;pre style=&#34;margin-top:0px; margin-bottom:0px; padding:5px; background-color:rgb(224,224,224); font-size:14px; line-height:16px; overflow:auto; font-family:Consolas,&#39;Lucida Console&#39;,&#39;Andale Mono&#39;,&#39;Bitstream Vera Sans Mono&#39;,&#39;Courier New&#39;,Courier; color:rgb(51,51,51)&#34;&gt;6
M 1 6
C 1
M 2 4
M 2 6
C 3
C 4&lt;/pre&gt;
&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;
    &lt;span style=&#34;margin:0px; padding:0px; font-size:18px; line-height:28px&#34;&gt;Sample Output&lt;/span&gt;
&lt;/p&gt;
&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;
&lt;/p&gt;
&lt;pre style=&#34;margin-top:0px; margin-bottom:0px; padding:5px; background-color:rgb(224,224,224); font-size:14px; line-height:16px; overflow:auto; font-family:Consolas,&#39;Lucida Console&#39;,&#39;Andale Mono&#39;,&#39;Bitstream Vera Sans Mono&#39;,&#39;Courier New&#39;,Courier; color:rgb(51,51,51)&#34;&gt;1
0
2&lt;/pre&gt;
&lt;br /&gt;

&lt;p&gt;
    &lt;span style=&#34;font-size:24px&#34;&gt;题解：&lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
    &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &lt;span style=&#34;font-size:18px&#34;&gt;并查集，并记录i元素上面和下面的元素个数&lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
&lt;/p&gt;
&lt;pre name=&#34;code&#34; class=&#34;cpp&#34;&gt;#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cstdlib&amp;gt;
#include &amp;lt;cstring&amp;gt;
const int N = 30005;
int set[N];
int high[N]; //i元素上面（加上i）的元素个数 
int low[N];  //i元素下面的元素个数 
int findset(int x){
    if(x == set[x])
        return set[x];
    int tm = set[x];
    set[x] = findset(set[x]);
    low[x] += low[tm];
    return set[x];
}
void unionset(int x,int y){
    int fx = findset(x);
    int fy = findset(y);
    if( fx == fy)
        return ;
    set[fx] = fy;
    low[fx] += high[fy];
    high[fy] += high[fx];
}
int main(){
    int n;
    while(scanf(&amp;quot;%d&amp;quot;,&amp;amp;n) != EOF){
        for(int i = 1; i &amp;lt;= N; i++){
            set[i] = i;
                 high[i] = 1;
        }
        memset(low,0,sizeof(low));
        char op;
        int x,y;
        getchar();
        for(int i =1 ; i &amp;lt;= n; i++){
            scanf(&amp;quot;%c&amp;quot;,&amp;amp;op);
            if(op == &#39;C&#39;){
                scanf(&amp;quot;%d&amp;quot;,&amp;amp;x);
                findset(x);
                printf(&amp;quot;%d\n&amp;quot;,low[x]);
            }
            else{
                scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;x,&amp;amp;y);
                unionset(x,y);
            }
            getchar();
        }
    }
    return 0;
}




&lt;/pre&gt;
&lt;br /&gt;
&lt;br /&gt;

&lt;p&gt;
&lt;/p&gt;
&lt;p&gt;
    &lt;br /&gt;
    
&lt;/p&gt;
</description>
    </item>
    <item>
      <title>HOJ 2033 Ubiquitous Religions</title>
      <link>http://pokerg.github.io/ACM/HOJ-2033-Ubiquitous-Religions/</link>
      <pubDate>2013-04-09 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;
	&lt;span style=&#34;background-color:rgb(247,247,247); color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; font-size:14px; line-height:20px&#34;&gt;There are so many different religions in the world today that it is difficult to keep track of them all. You are interested in finding out how many different religions students in your university believe in.&lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
&lt;/p&gt;
&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;
	You know that there are n students in your university (0&amp;nbsp;&amp;lt;&amp;nbsp;&lt;span style=&#34;margin:0px; padding:0px&#34;&gt;n&lt;/span&gt;&amp;nbsp;≤&amp;nbsp;50000). It is infeasible for you to ask every student their religious beliefs. Furthermore, many students are not comfortable expressing their beliefs. One way to avoid these problems is to ask&amp;nbsp;&lt;span style=&#34;margin:0px; padding:0px&#34;&gt;m&lt;/span&gt;&amp;nbsp;(0&amp;nbsp;≤&amp;nbsp;&lt;span style=&#34;margin:0px; padding:0px&#34;&gt;m&lt;/span&gt;&amp;nbsp;≤&amp;nbsp;&amp;nbsp;&lt;span style=&#34;margin:0px; padding:0px&#34;&gt;n&lt;/span&gt;(&lt;span style=&#34;margin:0px; padding:0px&#34;&gt;n&lt;/span&gt;-1)/2) pairs of students and ask them whether they believe in the same religion (e.g. they may know if they both attend the same church). From this data, you may not know what each person believes in, but you can get an idea of the upper bound of how many different religions can be possibly represented on campus. You may assume that each student subscribes to at most one religion.
&lt;/p&gt;
&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;
	The input consists of a number of cases. Each case starts with a line specifying the integers&amp;nbsp;&lt;span style=&#34;margin:0px; padding:0px&#34;&gt;n&lt;/span&gt;and&amp;nbsp;&lt;span style=&#34;margin:0px; padding:0px&#34;&gt;m&lt;/span&gt;. The next&amp;nbsp;&lt;span style=&#34;margin:0px; padding:0px&#34;&gt;m&lt;/span&gt;&amp;nbsp;lines each consists of two integers i and j, specifying that students i and j believe in the same religion. The students are numbered 1 to&amp;nbsp;&lt;span style=&#34;margin:0px; padding:0px&#34;&gt;n&lt;/span&gt;. The end of input is specified by a line in which&amp;nbsp;&lt;span style=&#34;margin:0px; padding:0px&#34;&gt;n&lt;/span&gt;&amp;nbsp;=&amp;nbsp;&lt;span style=&#34;margin:0px; padding:0px&#34;&gt;m&lt;/span&gt;&amp;nbsp;= 0.
&lt;/p&gt;
&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;
	For each test case, print on a single line the case number (starting with 1) followed by the maximum number of different religions that the students in the university believe in.
&lt;/p&gt;
&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;
	&lt;span style=&#34;margin:0px; padding:0px; font-size:18px; line-height:28px&#34;&gt;Sample Input&lt;/span&gt;
&lt;/p&gt;
&lt;pre style=&#34;margin-top:0px; margin-bottom:0px; padding:5px; background-color:rgb(224,224,224); font-size:14px; line-height:16px; overflow:auto; font-family:Consolas,&#39;Lucida Console&#39;,&#39;Andale Mono&#39;,&#39;Bitstream Vera Sans Mono&#39;,&#39;Courier New&#39;,Courier; color:rgb(51,51,51)&#34;&gt;10 9
1 2
1 3
1 4
1 5
1 6
1 7
1 8
1 9
1 10
10 4
2 3
4 5
4 8
5 8
0 0
&lt;/pre&gt;
&lt;span style=&#34;margin:0px; padding:0px; font-size:18px; line-height:28px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;Sample Output&lt;/span&gt;&lt;span style=&#34;color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; font-size:16px; line-height:20px; background-color:rgb(247,247,247)&#34;&gt;&lt;/span&gt;
&lt;pre style=&#34;margin-top:0px; margin-bottom:0px; padding:5px; background-color:rgb(224,224,224); font-size:14px; line-height:16px; overflow:auto; font-family:Consolas,&#39;Lucida Console&#39;,&#39;Andale Mono&#39;,&#39;Bitstream Vera Sans Mono&#39;,&#39;Courier New&#39;,Courier; color:rgb(51,51,51)&#34;&gt;Case 1: 1
Case 2: 7
&lt;/pre&gt;
&lt;hr style=&#34;margin:0px; padding:0px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; font-size:16px; line-height:20px; background-color:rgb(247,247,247)&#34; /&gt;
&lt;span style=&#34;color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; font-size:16px; line-height:20px; background-color:rgb(247,247,247)&#34;&gt;Author:&amp;nbsp;&lt;/span&gt;&lt;span style=&#34;margin:0px; padding:0px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; font-size:16px; line-height:20px; background-color:rgb(247,247,247)&#34;&gt;Howard Cheng&lt;/span&gt;&lt;br /&gt;

&lt;p&gt;
	&lt;span style=&#34;margin:0px; padding:0px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; font-size:16px; line-height:20px; background-color:rgb(247,247,247)&#34;&gt;&lt;br /&gt;
	&lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
	&lt;span style=&#34;margin:0px; padding:0px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; line-height:20px; background-color:rgb(247,247,247)&#34;&gt;&lt;span style=&#34;font-size:24px&#34;&gt;题解：&lt;/span&gt;&lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
	&lt;span style=&#34;margin:0px; padding:0px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; line-height:20px; background-color:rgb(247,247,247)&#34;&gt;&lt;span style=&#34;font-size:24px&#34;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;/span&gt;&lt;span style=&#34;font-size:18px&#34;&gt;并查集，判断有多少个祖先，用一个数组记录访问状态即可。&lt;/span&gt;&lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
	&lt;span style=&#34;margin:0px; padding:0px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; line-height:20px; background-color:rgb(247,247,247)&#34;&gt;&lt;span style=&#34;font-size:18px&#34;&gt;&lt;br /&gt;
	&lt;/span&gt;&lt;/span&gt;
&lt;/p&gt;
&lt;pre name=&#34;code&#34; class=&#34;cpp&#34;&gt;#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cstdlib&amp;gt;
#include &amp;lt;cstring&amp;gt;
int set[50005];
bool vis[50005];
int findset(int x){
	if(x == set[x])
	   return x;
	set[x] = findset(set[x]);
	return set[x];
}
int main(){
	int n,m;
	int cases = 0;
	while(scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;m) &amp;amp;&amp;amp; n &amp;amp;&amp;amp; m){
		cases ++;
		for(int i = 1; i &amp;lt;= n; i++)
			set[i] = i;
	        int fx,fy;
	        for(int i = 1; i &amp;lt;= m; i++){
		        scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;fx,&amp;amp;fy);
		        fx = findset(fx);
		        fy = findset(fy);
		        if(fx &amp;lt; fy)
			     set[fy] = fx;
		        else
			     set[fx] = fy;
		}
	        memset(vis,false,sizeof(vis));
	        int res = 0;
	        for(int i = 1; i &amp;lt;= n; i++){
		         if(vis[findset(i)] == false){
                     res ++;
		             vis[findset(i)] = true;
			 }
		}
                printf(&amp;quot;Case %d: %d\n&amp;quot;,cases,res);
	}
        return 0;
}	
&lt;/pre&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;

&lt;p&gt;
&lt;/p&gt;
&lt;p&gt;
	&lt;span style=&#34;margin:0px; padding:0px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; line-height:20px; background-color:rgb(247,247,247)&#34;&gt;&lt;span style=&#34;font-size:24px&#34;&gt;&lt;br /&gt;
	&lt;/span&gt;&lt;/span&gt;
&lt;/p&gt;
</description>
    </item>
    <item>
      <title>HOJ 1031 Piggy-Bank</title>
      <link>http://pokerg.github.io/ACM/HOJ-1031-Piggy-Bank/</link>
      <pubDate>2013-04-09 12:00:00 +0800</pubDate>
      <description>&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;
	Before ACM can do anything, a&amp;nbsp;budget must be prepared and the necessary financial support obtained. The main income for this action comes from Irreversibly Bound Money (IBM). The idea behind is simple. Whenever some ACM member has any small money, he takes all the coins and throws them into a piggy-bank. You know that this process is irreversible, the coins cannot be removed without breaking the pig. After a sufficiently long time, there should be enough cash in the piggy-bank to pay everything that needs to be paid.
&lt;/p&gt;
&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;
	But there is a big problem with piggy-banks. It is not possible to determine how much money is inside. So we might break the pig into pieces only to find out that there is not enough money. Clearly, we want to avoid this unpleasant situation. The only possibility is to weigh the piggy-bank and try to guess how many coins are inside. Assume that we are able to determine the weight of the pig exactly and that we know the weights of all coins of a given currency. Then there is some minimum amount of money in the piggy-bank that we can guarantee. Your task is to find out this worst case and determine the minimum amount of cash inside the piggy-bank. We need your help. No more prematurely broken pigs!
&lt;/p&gt;
&lt;span style=&#34;margin:0px; padding:0px; font-size:18px; line-height:28px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;Input Specification&lt;/span&gt;&lt;span style=&#34;color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; font-size:16px; line-height:20px; background-color:rgb(247,247,247)&#34;&gt;&lt;/span&gt;
&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;
	The input consists of&amp;nbsp;&lt;var style=&#34;margin:0px; padding:0px&#34;&gt;T&lt;/var&gt;&amp;nbsp;test cases. The number of them (&lt;var style=&#34;margin:0px; padding:0px&#34;&gt;T&lt;/var&gt;) is given on the first line of the input file. Each test case begins with a line containing two integers&amp;nbsp;&lt;var style=&#34;margin:0px; padding:0px&#34;&gt;E&lt;/var&gt;&amp;nbsp;and&amp;nbsp;&lt;var style=&#34;margin:0px; padding:0px&#34;&gt;F&lt;/var&gt;. They indicate the weight of an empty pig and of the pig filled with coins. Both weights are given in grams. No pig will weigh more than 10 kg, that means&amp;nbsp;&lt;var style=&#34;margin:0px; padding:0px&#34;&gt;1 &amp;lt;= E &amp;lt;= F &amp;lt;= 10000&lt;/var&gt;. On the second line of each test case, there is an integer number&amp;nbsp;&lt;var style=&#34;margin:0px; padding:0px&#34;&gt;N&lt;/var&gt;&amp;nbsp;(&lt;var style=&#34;margin:0px; padding:0px&#34;&gt;1 &amp;lt;= N &amp;lt;= 500&lt;/var&gt;) that gives the number of various coins used in the given currency. Following this are exactly&amp;nbsp;&lt;var style=&#34;margin:0px; padding:0px&#34;&gt;N&lt;/var&gt;&amp;nbsp;lines, each specifying one coin type. These lines contain two integers each,&amp;nbsp;&lt;var style=&#34;margin:0px; padding:0px&#34;&gt;P&lt;/var&gt;and&amp;nbsp;&lt;var style=&#34;margin:0px; padding:0px&#34;&gt;W&lt;/var&gt;&amp;nbsp;(&lt;var style=&#34;margin:0px; padding:0px&#34;&gt;1 &amp;lt;= P &amp;lt;= 50000&lt;/var&gt;,&amp;nbsp;&lt;var style=&#34;margin:0px; padding:0px&#34;&gt;1 &amp;lt;= W &amp;lt;=10000&lt;/var&gt;).&amp;nbsp;&lt;var style=&#34;margin:0px; padding:0px&#34;&gt;P&lt;/var&gt;&amp;nbsp;is the value of the coin in monetary units,&amp;nbsp;&lt;var style=&#34;margin:0px; padding:0px&#34;&gt;W&lt;/var&gt;&amp;nbsp;is it&#39;s weight in grams.
&lt;/p&gt;
&lt;span style=&#34;margin:0px; padding:0px; font-size:18px; line-height:28px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;Output Specification&lt;/span&gt;&lt;span style=&#34;color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; font-size:16px; line-height:20px; background-color:rgb(247,247,247)&#34;&gt;&lt;/span&gt;
&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;
	Print exactly one line of output for each test case. The line must contain the&amp;nbsp;sentence &amp;quot;&lt;code style=&#34;margin:0px; padding:0px&#34;&gt;The minimum amount of money in the piggy-bank is&amp;nbsp;&lt;var style=&#34;margin:0px; padding:0px&#34;&gt;X&lt;/var&gt;.&lt;/code&gt;&amp;nbsp;where&amp;nbsp;&lt;var style=&#34;margin:0px; padding:0px&#34;&gt;X&lt;/var&gt;&amp;nbsp;is the minimum amount of money that can be achieved using coins with the given total weight. If the weight cannot be reached exactly, print a&amp;nbsp;line &amp;quot;&lt;code style=&#34;margin:0px; padding:0px&#34;&gt;This is impossible.&lt;/code&gt;.
&lt;/p&gt;
&lt;span style=&#34;margin:0px; padding:0px; font-size:18px; line-height:28px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;Sample Input:&lt;/span&gt;
&lt;pre style=&#34;margin-top:0px; margin-bottom:0px; padding:5px; background-color:rgb(224,224,224); font-size:14px; line-height:16px; overflow:auto; font-family:Consolas,&#39;Lucida Console&#39;,&#39;Andale Mono&#39;,&#39;Bitstream Vera Sans Mono&#39;,&#39;Courier New&#39;,Courier; color:rgb(51,51,51)&#34;&gt;3
10 110
2
1 1
30 50
10 110
2
1 1
50 30
1 6
2
10 3
20 4
&lt;/pre&gt;
&lt;span style=&#34;margin:0px; padding:0px; font-size:18px; line-height:28px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;Sample Output:&lt;/span&gt;
&lt;pre style=&#34;margin-top:0px; margin-bottom:0px; padding:5px; background-color:rgb(224,224,224); font-size:14px; line-height:16px; overflow:auto; font-family:Consolas,&#39;Lucida Console&#39;,&#39;Andale Mono&#39;,&#39;Bitstream Vera Sans Mono&#39;,&#39;Courier New&#39;,Courier; color:rgb(51,51,51)&#34;&gt;The minimum amount of money in the piggy-bank is 60.
The minimum amount of money in the piggy-bank is 100.
This is impossible.&lt;/pre&gt;
&lt;p&gt;
	&lt;span style=&#34;font-size:24px&#34;&gt;&lt;br /&gt;
	&lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
	&lt;span style=&#34;font-size:24px&#34;&gt;题解：&lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
	&lt;span style=&#34;font-size:24px&#34;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;/span&gt;&lt;span style=&#34;font-size:18px&#34;&gt;完全背包问题,可以看看《背包问题九讲》&lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
	&lt;span style=&#34;font-size:18px&#34;&gt;&lt;/span&gt;
&lt;/p&gt;
&lt;pre name=&#34;code&#34; class=&#34;cpp&#34;&gt;#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cstdlib&amp;gt;
#include &amp;lt;cstring&amp;gt;
const int N = 505;
const int inf = 1000000000;
int w[N],p[N];
int dp[10005];
int main(){
	int cases,e,f,n;
	scanf(&amp;quot;%d&amp;quot;,&amp;amp;cases);
	while(cases --){
		
		scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;e,&amp;amp;f);
		for(int i = 1; i &amp;lt;= f; i ++)
		   dp[i] = inf;
        dp[0] = 0;
		f -= e;
		scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
		for(int i = 1; i &amp;lt;= n; i++)
			scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;p[i],&amp;amp;w[i]);
		for(int i = 1; i &amp;lt;= n ; i++)
			for(int j = w[i]; j &amp;lt;= f; j++)
				if(dp[j - w[i]] + p[i] &amp;lt; dp[j]) dp[j] = dp[j - w[i]] + p[i];
		if(dp[f] == inf) 
		    printf(&amp;quot;This is impossible.\n&amp;quot;);
		else
		    printf(&amp;quot;The minimum amount of money in the piggy-bank is %d.\n&amp;quot;,dp[f]);	        
	}
    return 0;
}	
		
&lt;/pre&gt;
&lt;br /&gt;
&lt;br /&gt;

&lt;p&gt;
&lt;/p&gt;
&lt;p&gt;
	&lt;br /&gt;
	
&lt;/p&gt;
</description>
    </item>
    <item>
      <title>HOJ 2196 Job Scheduling by Open Bidding</title>
      <link>http://pokerg.github.io/ACM/HOJ-2196-Job-Scheduling-by-Open-Bidding/</link>
      <pubDate>2013-04-07 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;
    Your team is setting up a computing resource devoted to batch processing of compute-bound jobs. In addition, you have decided to use static scheduling for each period of time. Naturally, you wish to maximize the income for each set of jobs run, and you have been given the responsibility of finding an optimal mix of jobs for each set of candidate jobs. The jobs are submitted by an open bid process: clients will specify the amount of processor time they wish to reserve and the dollar amount that they wish to pay. If a job finishes early, the client will still pay the full amount, and if a job exceeds the requested time, it will be terminated and (of course) the client will still pay the full amount. For purposes of scheduling, your team assumes that each job will in fact use its entire scheduled time slot. In the interests of good customer relations, though, you are not to include a bid in the schedule if there is not sufficient time available to satisfy it — we’re not going to over-book like the airlines do, and then hope someone doesn’t use the full allotment!
&lt;/p&gt;
&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;
    &lt;span style=&#34;margin:0px; padding:0px; font-size:18px; line-height:28px&#34;&gt;Input&lt;/span&gt;
&lt;/p&gt;
&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;
    The input file begins with a line containing a single integer (no white space) specifying the number of problem sets in the file.
&lt;/p&gt;
&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;
    Each problem set consists of (n+2) lines (no white space except as specified):
&lt;/p&gt;
&lt;ul style=&#34;margin:0px; padding:15px 0px 15px 30px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; font-size:16px; line-height:20px; background-color:rgb(247,247,247)&#34;&gt;
    &lt;li style=&#34;margin:0px; padding:0px&#34;&gt;
        a single integer n (n &amp;lt;= 500) specifying the number of candidate jobs to be schedu
    &lt;/li&gt;
    &lt;li style=&#34;margin:0px; padding:0px&#34;&gt;
        n lines giving the bid as an integer specifying the number of seconds followed by a single space and then a dollar amount given in decimal form (always showing two digits to the right of the decimal point)
    &lt;/li&gt;
    &lt;li style=&#34;margin:0px; padding:0px&#34;&gt;
        a single integer t (t &amp;lt;= 2000) specifying the amount of time to be scheduled with these job
    &lt;/li&gt;
&lt;/ul&gt;
&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;
    &lt;span style=&#34;margin:0px; padding:0px; font-size:18px; line-height:28px&#34;&gt;Output&lt;/span&gt;
&lt;/p&gt;
&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;
    Each problem set will be numbered (beginning at one) and will generate a single line: Problem&amp;nbsp;:&amp;nbsp;seconds scheduled for $abc.de where&amp;nbsp;is replaced by the problem set number,&amp;nbsp;is replaced with the total time actually scheduled (possibly not the full input time), and $abc.de is replaced by the dollar amount, given always with the leading currency symbol and with two digits to the right of the decimal point. There will be no blank lines, and the final line will end with the new-line character.
&lt;/p&gt;
&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;
    &lt;span style=&#34;margin:0px; padding:0px; font-size:18px; line-height:28px&#34;&gt;Sample Input&lt;/span&gt;
&lt;/p&gt;
&lt;pre style=&#34;margin-top:0px; margin-bottom:0px; background-color:rgb(224,224,224); padding:5px; font-size:14px; line-height:16px; overflow:auto; font-family:Consolas,&#39;Lucida Console&#39;,&#39;Andale Mono&#39;,&#39;Bitstream Vera Sans Mono&#39;,&#39;Courier New&#39;,Courier; color:rgb(51,51,51)&#34;&gt;1
10
19 0.78
12 0.31
17 0.77
22 0.77
8 0.56
10 0.33
17 0.35
24 0.12
22 0.70
5 0.52
120&lt;/pre&gt;
&lt;span style=&#34;margin:0px; padding:0px; font-size:18px; line-height:28px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;Sample Output&lt;/span&gt;
&lt;pre style=&#34;margin-top:0px; margin-bottom:0px; background-color:rgb(224,224,224); padding:5px; font-size:14px; line-height:16px; overflow:auto; font-family:Consolas,&#39;Lucida Console&#39;,&#39;Andale Mono&#39;,&#39;Bitstream Vera Sans Mono&#39;,&#39;Courier New&#39;,Courier; color:rgb(51,51,51)&#34;&gt;Problem 1: 120 seconds scheduled for $4.78&lt;/pre&gt;
&lt;p&gt;
    &lt;strong&gt;&lt;span style=&#34;font-size:32px&#34;&gt;&amp;nbsp;题解：&amp;nbsp;&lt;/span&gt;&lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
    &lt;strong&gt;&lt;span style=&#34;font-size:32px&#34;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;span style=&#34;font-size:24px&#34;&gt;基本的01背包问题，直接给代码吧&lt;/span&gt;&lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
    &lt;strong&gt;&lt;/strong&gt;
&lt;/p&gt;
&lt;pre name=&#34;code&#34; class=&#34;html&#34;&gt;&lt;span style=&#34;font-size: 18px;&#34;&gt;#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cstdlib&amp;gt;
#include &amp;lt;cstring&amp;gt;
int c[505];
double w[505];
double f[2005];
double w_max(double a,double b){
    return a &amp;gt; b ? a : b;
}
int main(){
    int cases,n,r = 0;
    scanf(&amp;quot;%d&amp;quot;,&amp;amp;cases);
    while(cases&amp;ndash;){
        r++;
        memset(f,0,sizeof(f));
        scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
        for(int i = 0; i &amp;lt; n; i++)
            scanf(&amp;quot;%d %lf&amp;quot;,&amp;amp;c[i],&amp;amp;w[i]);
        int time;
        scanf(&amp;quot;%d&amp;quot;,&amp;amp;time);
        for(int i = 0; i &amp;lt; n; i++)
            for(int j = time; j &amp;gt;= c[i]; j&amp;ndash;)
                f[j] = w_max(f[j],f[j - c[i]] + w[i]);
        int actTime = 0;
        double maxSum = 0;
        for(int i = 1; i &amp;lt;= time; i ++)
            if(f[i] &amp;gt; maxSum)
                actTime = i, maxSum = f[i];
        printf(&amp;quot;Problem %d: %d seconds scheduled for $%.2lf\n&amp;quot;,r,actTime,maxSum);
    }
    return 0;
}&lt;/span&gt;&lt;span style=&#34; font-size: 24px;&#34;&gt;&lt;strong&gt;
&lt;/strong&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>HOJ 1019 Grandpa&#39;s Other Estate</title>
      <link>http://pokerg.github.io/ACM/HOJ-1019-Grandpa%27s-Other-Estate/</link>
      <pubDate>2013-04-02 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;From our previous contest, we know that Kamran the Believer inherited many of his grandpa&amp;rsquo;s belongings. Apparently, his grandpa had been a mathematician in his life with interests in puzzle solving, since he has made Kamran solve another programming problem!&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;
&lt;/p&gt;
&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;
    Grandpa had a big garden with many valuable walnut trees. He has written in his will that Kamran can inherit one piece of square shaped land of a given size in the garden, such that its sides be parallel to the x and y axes. Taking advantage of the fact that no other restrictions have been mentioned in the will, Kamran wants to choose the land in which the most number of trees lie. Kamran is too wealthy now and thus too lazy to spend time and solve another algorithmic problem. He has hired you to solve this problem for him.
&lt;/p&gt;
&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;
    You are given the location of all trees in the big garden and the size of the land to choose. You are to write a program to find out where to choose the land so that the most number of trees lie in it. You may consider trees as points in the plane and the land as a square. You are to find the position of the square such that it includes as many points as possible. Note that the points on the border of the square are considered to be inside it.
&lt;/p&gt;
&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;
    &lt;span style=&#34;margin:0px; padding:0px; font-size:18px; line-height:28px&#34;&gt;Input&lt;/span&gt;&lt;br style=&#34;margin:0px; padding:0px&#34; /&gt;
    The first line of the input file contains a single integer t (1&amp;lt;=t&amp;lt;=10), the number of test cases, followed by the input data for each test case. The first line of each test case contains an integer n (1&amp;lt;=n&amp;lt;=100), the number of trees, and an integer r (1&amp;lt;=r&amp;lt;=1000), the length of the land&#39;s side, followed by n lines, each containing two integers x and y (0&amp;lt;=x , y &amp;lt;= 100,000) representing the coordinates of a walnut tree. Note that all coordinates are pairwise distinct.
&lt;/p&gt;
&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;
    &lt;span style=&#34;margin:0px; padding:0px; font-size:18px; line-height:28px&#34;&gt;Output&lt;/span&gt;&lt;br style=&#34;margin:0px; padding:0px&#34; /&gt;
    There should be one line per test case containing the maximum number of trees that Kamran can own.
&lt;/p&gt;
&lt;p style=&#34;margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; line-height:20px; font-size:14px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;
    &lt;span style=&#34;margin:0px; padding:0px; font-size:18px; line-height:28px&#34;&gt;Sample Input&lt;/span&gt;
&lt;/p&gt;
&lt;pre style=&#34;margin-top:0px; margin-bottom:0px; padding:5px; background-color:rgb(224,224,224); font-size:14px; line-height:16px; overflow:auto; font-family:Consolas,&#39;Lucida Console&#39;,&#39;Andale Mono&#39;,&#39;Bitstream Vera Sans Mono&#39;,&#39;Courier New&#39;,Courier; color:rgb(51,51,51)&#34;&gt;1
3 1
1 2
2 1
4 3&lt;/pre&gt;
&lt;p&gt;
    &lt;span style=&#34;margin:0px; padding:0px; font-size:18px; line-height:28px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;Sample Output&lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
    &lt;span style=&#34;margin:0px; padding:0px; font-size:18px; line-height:28px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;&lt;/span&gt;
&lt;/p&gt;
&lt;pre style=&#34;margin-top:0px; margin-bottom:0px; background-color:rgb(224,224,224); padding:5px; font-size:14px; line-height:16px; overflow:auto; font-family:Consolas,&#39;Lucida Console&#39;,&#39;Andale Mono&#39;,&#39;Bitstream Vera Sans Mono&#39;,&#39;Courier New&#39;,Courier; color:rgb(51,51,51)&#34;&gt;2&lt;/pre&gt;
&lt;br /&gt;

&lt;p&gt;
&lt;/p&gt;
&lt;p&gt;
    &lt;span style=&#34;margin:0px; padding:0px; font-size:18px; line-height:28px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;&lt;strong&gt;题解：&lt;/strong&gt;&lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
    &lt;span style=&#34;margin:0px; padding:0px; font-size:18px; line-height:28px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;&lt;strong&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;只需将正方形从左到右，从上到下扫描一遍，更新res, 即可&lt;/strong&gt;&lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
    &lt;span style=&#34;margin:0px; padding:0px; font-size:18px; line-height:28px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;&lt;/span&gt;
&lt;/p&gt;
&lt;pre name=&#34;code&#34; class=&#34;cpp&#34;&gt;#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cstdlib&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;cmath&amp;gt;
using namespace std;
struct point
{
    int x,y;
};
point p[105];
bool judge(int x1,int x2,int y2,int y1,point a){
    if((a.x - x1) * (a.x - x2) &amp;lt;= 0 &amp;amp;&amp;amp; (a.y - y1) * (a.y - y2) &amp;lt;= 0)
        return true;
    return false;
}
int main(){
    int t,n,r;
    scanf(&amp;quot;%d&amp;quot;,&amp;amp;t);
    while(t--){
        scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;r);
        for(int i = 1; i &amp;lt;= n; i++)
            scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;p[i].x,&amp;amp;p[i].y);
        int res = 1;
        int temp;
        for(int i = 1; i &amp;lt;= n; i ++)
            for(int j = i + 1; j &amp;lt;= n; j ++){
                if (abs(p[i].x - p[j].x) &amp;gt; r || abs(p[i].y - p[j].y) &amp;gt; r)continue;
                int tx = min(p[i].x,p[j].x);
                int ty = max(p[i].y,p[j].y);
                temp = 0;
                for(int k = 1; k &amp;lt;= n; k++)
                    if(judge(tx,tx + r, ty , ty - r,p[k]))
                        temp ++;
                res = max(res,temp);
            }
        printf(&amp;quot;%d\n&amp;quot;,res);
    }
    return 0;
}&lt;/pre&gt;
&lt;br /&gt;
&lt;br /&gt;

&lt;p&gt;
&lt;/p&gt;
&lt;p&gt;
    &lt;span style=&#34;margin:0px; padding:0px; font-size:18px; line-height:28px; color:rgb(51,51,51); font-family:&#39;Helvetica Neue&#39;,Helvetica,Arial,sans-serif; background-color:rgb(247,247,247)&#34;&gt;&lt;br /&gt;
    &lt;/span&gt;
&lt;/p&gt;
</description>
    </item>
    <item>
      <title>转： HOJ 1016 Joseph&#39;s problem I</title>
      <link>http://pokerg.github.io/ACM/%E8%BD%AC%EF%BC%9A-HOJ-1016-Joseph%27s-problem-I/</link>
      <pubDate>2013-03-28 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;div style=&#34;&#34;&gt;
    &lt;div id=&#34;sina_keyword_ad_area2&#34; style=&#34;line-height:25px&#34;&gt;
        &lt;div style=&#34;line-height:25px&#34;&gt;
            先说说经典的Joseph问题吧，说有n个要被处决的人（编号0~(n-1))，从0开始报数，报到(m-1)的会被杀掉，剩下的人继续从0开始报数，如此下去最后剩的一个人会存活下来。说Joseph发现了这个规律而且把他透露了出来，现在假如你在这n个人里面，你会选择几号位置站下。
            &lt;p style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px 0px 10px; line-height:25px; padding-right:0px&#34;&gt;
                　　很显然你会选择能活下来的那个位置，所以问题就是如何得到这个位置。
            &lt;/p&gt;
            &lt;p style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px 0px 10px; line-height:25px; padding-right:0px&#34;&gt;
                　　首先想到的是模拟(至少我笨脑子是这么想的)，但无论是用链表还是用数组这个时间复杂度都是比较高的，至少交题的时候会TLE，这里介绍一种线性时间的解法，出自大师Knuth的哦。
            &lt;/p&gt;
            &lt;p style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px 0px 10px; line-height:25px; padding-right:0px&#34;&gt;
                　　考虑下第一次杀人的时候，编号为k = (m - 1) % n的同学挂了，那我们从k + 1重新从0开始编号
            &lt;/p&gt;
            &lt;p style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px 0px 10px; line-height:25px; padding-right:0px&#34;&gt;
                　　k + 1 ==&amp;gt; 0
            &lt;/p&gt;
            &lt;p style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px 0px 10px; line-height:25px; padding-right:0px&#34;&gt;
                　　k + 2 ==&amp;gt; 1
            &lt;/p&gt;
            &lt;p style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px 0px 10px; line-height:25px; padding-right:0px&#34;&gt;
                　　……
            &lt;/p&gt;
            &lt;p style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px 0px 10px; line-height:25px; padding-right:0px&#34;&gt;
                　　……
            &lt;/p&gt;
            &lt;p style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px 0px 10px; line-height:25px; padding-right:0px&#34;&gt;
                　　k - 2 ==&amp;gt; n - 2
            &lt;/p&gt;
            &lt;p style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px 0px 10px; line-height:25px; padding-right:0px&#34;&gt;
                　　k - 1 ==&amp;gt; n - 1
            &lt;/p&gt;
            &lt;p style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px 0px 10px; line-height:25px; padding-right:0px&#34;&gt;
                　　好了，剩余的n - 1个同学又组成了一个新的Joseph环，对新环来说，编号k = (m - 1) % (n - 1)的同学会挂，如此下去，这里面似乎有某种规律可寻。
            &lt;/p&gt;
            &lt;p style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px 0px 10px; line-height:25px; padding-right:0px&#34;&gt;
                　　考虑到不会死的同学一直不会被杀(废话)，我们设i个同学时的不会挂的同学的编号(即解)为x，那么当死掉一个同学剩余i - 1个同学的时候，x仍然不会被杀，但此时的x已经由编号变换变成了x’，即x’是i - 1的情况时的解！一直推下去直到i - (i - 1)即1的情况，那1的时候解明显是0嘛！(注意编号是从0开始的)，倒推回来，那问题不就解决了么！
            &lt;/p&gt;
            &lt;p style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px 0px 10px; line-height:25px; padding-right:0px&#34;&gt;
                　　好了，分析清楚了剩下的就只是数学推导了，这个我比较烦，直接给公式吧：
            &lt;/p&gt;
            &lt;p style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px 0px 10px; line-height:25px; padding-right:0px&#34;&gt;
                　　向下变换：x’ = (x - (k + 1)) % i;
            &lt;/p&gt;
            &lt;p style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px 0px 10px; line-height:25px; padding-right:0px&#34;&gt;
                　　向上变换：x = (x + k + 1) % i;
            &lt;/p&gt;
            &lt;p style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px 0px 10px; line-height:25px; padding-right:0px&#34;&gt;
                　　其中：　　k = (m - 1) % i;
            &lt;/p&gt;
            &lt;p style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px 0px 10px; line-height:25px; padding-right:0px&#34;&gt;
                　　带入可得：x = (x’ + m) % i;
            &lt;/p&gt;
            &lt;p style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px 0px 10px; line-height:25px; padding-right:0px&#34;&gt;
                　　OK，现在应该很好写代码了：
            &lt;/p&gt;
            &lt;p style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px 0px 10px; line-height:25px; padding-right:0px&#34;&gt;　　
                &lt;code style=&#34;line-height:25px&#34;&gt;&lt;span style=&#34;font-family:新宋体; line-height:25px&#34;&gt;int Joseph(int n,int m)&lt;br style=&#34;line-height:25px&#34; /&gt;
                　　{&lt;br style=&#34;line-height:25px&#34; /&gt;
                &amp;nbsp;&lt;wbr style=&#34;line-height:25px&#34;&gt;&amp;nbsp;&lt;wbr style=&#34;line-height:25px&#34;&gt;&amp;nbsp;&lt;wbr style=&#34;line-height:25px&#34;&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;　　int i,result;&lt;br style=&#34;line-height:25px&#34; /&gt;
                &amp;nbsp;&lt;wbr style=&#34;line-height:25px&#34;&gt;&amp;nbsp;&lt;wbr style=&#34;line-height:25px&#34;&gt;&lt;br style=&#34;line-height:25px&#34; /&gt;
                &amp;nbsp;&lt;wbr style=&#34;line-height:25px&#34;&gt;&amp;nbsp;&lt;wbr style=&#34;line-height:25px&#34;&gt;&amp;nbsp;&lt;wbr style=&#34;line-height:25px&#34;&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;　　for (i = 1,result = 0;i &amp;lt; n;i++)&lt;br style=&#34;line-height:25px&#34; /&gt;
                &amp;nbsp;&lt;wbr style=&#34;line-height:25px&#34;&gt;&amp;nbsp;&lt;wbr style=&#34;line-height:25px&#34;&gt;&amp;nbsp;&lt;wbr style=&#34;line-height:25px&#34;&gt;&amp;nbsp;&lt;wbr style=&#34;line-height:25px&#34;&gt;&amp;nbsp;&lt;wbr style=&#34;line-height:25px&#34;&gt;&amp;nbsp;&lt;wbr style=&#34;line-height:25px&#34;&gt;&amp;nbsp;&lt;wbr style=&#34;line-height:25px&#34;&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;　　result = (result + m) % i;&lt;br style=&#34;line-height:25px&#34; /&gt;
                &amp;nbsp;&lt;wbr style=&#34;line-height:25px&#34;&gt;&amp;nbsp;&lt;wbr style=&#34;line-height:25px&#34;&gt;&amp;nbsp;&lt;wbr style=&#34;line-height:25px&#34;&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;　　return result;&lt;br style=&#34;line-height:25px&#34; /&gt;
                　　}&lt;/wbr&gt;&lt;/wbr&gt;&lt;/wbr&gt;&lt;/wbr&gt;&lt;/wbr&gt;&lt;/wbr&gt;&lt;/wbr&gt;&lt;/wbr&gt;&lt;/wbr&gt;&lt;/wbr&gt;&lt;/wbr&gt;&lt;/wbr&gt;&lt;/wbr&gt;&lt;/wbr&gt;&lt;/wbr&gt;&lt;/wbr&gt;&lt;/wbr&gt;&lt;/wbr&gt;&lt;/span&gt;&lt;/code&gt;
            &lt;/p&gt;
            &lt;p style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px 0px 10px; line-height:25px; padding-right:0px&#34;&gt;
                　　现在再来看看HOJ上的两道Joseph问题，有了上面的基础，只要做个脑筋急转弯就行了。
            &lt;/p&gt;
            &lt;p style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px 0px 10px; line-height:25px; padding-right:0px&#34;&gt;
                　　先看第一道(1016)，说Joseph把杀人的秘密传出来之后，很多聪明的或者还不够聪明的程序员都能够选择合适的位置使自己存活下来，但 Joseph的表兄，一个恶毒的一直致力于将世界上所有愚蠢的程序员杀光光的人，又发明出一种新的玩法来杀人，如果你又很不幸的站在了这n个人里面，你会选择哪个位置站下。
            &lt;/p&gt;
            &lt;p style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px 0px 10px; line-height:25px; padding-right:0px&#34;&gt;
                　　Joseph表兄的新玩法的特点是m是不再是给定的一个确定的数值，而且是按照素数从小到大变动的，即取值依次为{2, 3, 5, 7, ……}。
            &lt;/p&gt;
            &lt;p style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px 0px 10px; line-height:25px; padding-right:0px&#34;&gt;
                　　当然你仍然选择不会挂的位置站下。
            &lt;/p&gt;
            &lt;p style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px 0px 10px; line-height:25px; padding-right:0px&#34;&gt;
                　　题目已经说得很清楚了，不难想到我们只要在递推的过程中更新m的值就行了，m属于素数的集合，所以我们只要开个数组保存有用的素数，然后使m在其中取值就行了。
            &lt;/p&gt;
            &lt;p style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px 0px 10px; line-height:25px; padding-right:0px&#34;&gt;
                　　还有一点值得注意的是由于第1次杀人的时候取的值是prime[0]，第2次是prime[1]，……第n次是prime[n-1]，所以往回推的时候第1次取的应该是prime[n-1]，第2次是prime[n-2]，……则第i次应该是prime[n-i]。
            &lt;/p&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;pre class=&#34;cpp&#34; name=&#34;code&#34;&gt;#include &amp;lt;iostream&amp;gt;&lt;/p&gt;

&lt;p&gt;const int SIZE = 3502;
int prime[SIZE];
int result[SIZE];
int isprime(int n)
{
    for (int i=3 ;i*i&amp;lt;=n;i+=2)
    {
        if (n%i==0)
            return 0;
    }
    return 1;
}
int main()
{
    int prime[SIZE];
    int result[SIZE];
    int i,j;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for(i = 3,j = 1,prime[0] = 2;j &amp;amp;lt; SIZE;i += 2)
    if(isprime(i))
        prime[j++] = i;
for(i = 1;i &amp;amp;lt; SIZE;i++)
    for(j = 1,result[i] = 0;j &amp;amp;lt;= i;j++)
        result[i] = (result[i] + prime[i-j]) % j;
while(scanf(&amp;amp;quot;%d&amp;amp;quot;,&amp;amp;amp;i) == 1 &amp;amp;amp;&amp;amp;amp; i)
{
    printf(&amp;amp;quot;%d\n&amp;amp;quot;,result[i] + 1);
}
return 0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
&lt;/pre&gt;
&lt;br /&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>HOJ 1015  Nearly prime numbers</title>
      <link>http://pokerg.github.io/ACM/HOJ-1015--Nearly-prime-numbers/</link>
      <pubDate>2013-03-27 12:00:00 +0800</pubDate>
      <description>&lt;p style=&#34;&#34;&gt;
	Nearly prime number is an integer positive number for which it is possible to find such primes&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px; padding-right:0px&#34;&gt;P&lt;sub style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px; padding-right:0px&#34;&gt;1&lt;/sub&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;and&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px; padding-right:0px&#34;&gt;P&lt;sub style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px; padding-right:0px&#34;&gt;2&lt;/sub&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;that given number is equal to&lt;span style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px; padding-right:0px&#34;&gt;P&lt;sub style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px; padding-right:0px&#34;&gt;1&lt;/sub&gt;*P&lt;sub style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px; padding-right:0px&#34;&gt;2&lt;/sub&gt;&lt;/span&gt;. There is given a sequence on&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px; padding-right:0px&#34;&gt;N&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;integer positive numbers, you are to write a program that prints Yes if given number is nearly prime and No otherwise.
&lt;/p&gt;
Input&lt;span style=&#34;&#34;&gt;&lt;/span&gt;
&lt;p style=&#34;&#34;&gt;
	Input consists of&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px; padding-right:0px&#34;&gt;N+&lt;/span&gt;1 numbers. First is positive integer&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px; padding-right:0px&#34;&gt;N (1&amp;lt;=N&amp;lt;=50000)&lt;/span&gt;. Next&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px; padding-right:0px&#34;&gt;N&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;numbers followed by&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px; padding-right:0px&#34;&gt;N&lt;/span&gt;. Each number is not greater than&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px; padding-right:0px&#34;&gt;10&lt;sup style=&#34;padding-bottom:0px; padding-top:0px; padding-left:0px; margin:0px; padding-right:0px&#34;&gt;9&lt;/sup&gt;&lt;/span&gt;. All numbers separated by whitespace(s).
&lt;/p&gt;
Output&lt;span style=&#34;&#34;&gt;&lt;/span&gt;
&lt;p style=&#34;&#34;&gt;
	Write a line in output for each number of given sequence. Write Yes if given number is nearly prime and No in other case.
&lt;/p&gt;
Sample Input&lt;span style=&#34;&#34;&gt;&lt;/span&gt;
&lt;pre style=&#34;&#34;&gt;1
6
&lt;/pre&gt;
Sample Output&lt;span style=&#34;&#34;&gt;&lt;/span&gt;
&lt;p style=&#34;&#34;&gt;
	Yes
&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;
&lt;/p&gt;
&lt;p&gt;
	&amp;nbsp;
&lt;/p&gt;
&lt;pre class=&#34;cpp&#34; name=&#34;code&#34;&gt;#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cstdlib&amp;gt;
bool isPrime(int n){
	if(n == 2)
	   return true;
    if(n % 2 == 0)
       return false;
	for(int i = 3; i * i &amp;lt;= n; i += 2)
		if(n % i == 0)
			return false;
	return true;
}
bool isNearlyPrime(int n){
    if(n % 2 == 0 &amp;amp;&amp;amp; isPrime(n / 2))
        return true;
    for(int i = 3; i * i &amp;lt;= n; i += 2)
        if(n % i == 0 &amp;amp;&amp;amp; isPrime(i))
            if(isPrime(n / i))
              return true;
    return false;
}
int main(){
	int n;
	int a[50005];
	while(scanf(&amp;quot;%d&amp;quot;,&amp;amp;n) != EOF){
		for(int i = 0; i &amp;lt; n; i++)
		  scanf(&amp;quot;%d&amp;quot;,&amp;amp;a[i]);
		for(int i = 0; i &amp;lt; n; i++){
			if(isNearlyPrime(a[i]))
				printf(&amp;quot;Yes\n&amp;quot;);
			else
				printf(&amp;quot;No\n&amp;quot;);
		}
	}
	return 0;
}&lt;/pre&gt;
&lt;p&gt;
	&lt;br /&gt;
	&amp;nbsp;
&lt;/p&gt;
</description>
    </item>
    <item>
      <title>HDOJ 4509  湫湫系列故事——减肥记II</title>
      <link>http://pokerg.github.io/ACM/HDOJ-4509--%E6%B9%AB%E6%B9%AB%E7%B3%BB%E5%88%97%E6%95%85%E4%BA%8B%E2%80%94%E2%80%94%E5%87%8F%E8%82%A5%E8%AE%B0II/</link>
      <pubDate>2013-03-23 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;div class=&#34;panel_title&#34; align=&#34;left&#34; style=&#34;font-size:18px; height:38px; font-family:Arial; font-weight:bold; color:rgb(124,169,237); padding-bottom:0px; padding-top:0px; padding-left:14px; padding-right:14px; background-color:transparent&#34;&gt;
    Problem Description
&lt;/div&gt;
&lt;div class=&#34;panel_content&#34; style=&#34;font-size:14px; height:auto; font-family:&#39;Times New Roman&#39;; padding-bottom:0px; text-align:left; padding-top:0px; padding-left:20px; margin:0px; padding-right:20px&#34;&gt;
    　　虽然制定了减肥食谱，但是湫湫显然克制不住吃货的本能，根本没有按照食谱行动！&lt;br /&gt;
    于是，结果显而易见…&lt;br /&gt;
    　　但是没有什么能难倒高智商美女湫湫的，她决定另寻对策——吃没关系，咱吃进去再运动运动消耗掉不就好了？&lt;br /&gt;
    　　湫湫在内心咆哮：“我真是天才啊~(≧▽≦)/~”&lt;br /&gt;
    &lt;br /&gt;
    　　可是，大家要知道，过年回家多忙啊——帮忙家里做大扫除，看电影，看小说，高中同学聚餐，初中同学聚餐，小学同学聚餐，吃东西，睡觉，吃东西，睡觉，吃东西，睡觉……所以锻炼得抽着时间来。&lt;br /&gt;
    &lt;br /&gt;
    　　但是，湫湫实在太忙了，所以没时间去算一天有多少时间可以用于锻炼，现在她把每日行程告诉你，拜托你帮忙算算吧~&lt;br /&gt;
    &lt;br /&gt;
    　　皮埃斯：一天是24小时，每小时60分钟
&lt;/div&gt;
&lt;div class=&#34;panel_bottom&#34; style=&#34;font-size:14px; height:auto; font-family:&#39;Times New Roman&#39;; margin:0px&#34;&gt;
    &amp;nbsp;
&lt;/div&gt;
&lt;br style=&#34;font-size:14px; font-family:&#39;Times New Roman&#39;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;panel_title&#34; align=&#34;left&#34; style=&#34;font-size:18px; height:38px; font-family:Arial; font-weight:bold; color:rgb(124,169,237); padding-bottom:0px; padding-top:0px; padding-left:14px; padding-right:14px; background-color:transparent&#34;&gt;
    Input
&lt;/div&gt;
&lt;div class=&#34;panel_content&#34; style=&#34;font-size:14px; height:auto; font-family:&#39;Times New Roman&#39;; padding-bottom:0px; text-align:left; padding-top:0px; padding-left:20px; margin:0px; padding-right:20px&#34;&gt;
    输入数据包括多组测试用例。&lt;br /&gt;
    每组测试数据首先是一个整数n，表示当天有n件事要做。&amp;nbsp;&lt;br /&gt;
    接下来n行，第i行是第i件事的开始时间和结束时间，时间格式为HH:MM。&lt;br /&gt;
    &lt;br /&gt;
    [Technical Specification]&lt;br /&gt;
    1. 1 &amp;lt;= n &amp;lt;= 500000&lt;br /&gt;
    2. 00 &amp;lt;= HH &amp;lt;= 23&lt;br /&gt;
    3. 00 &amp;lt;= MM &amp;lt;= 59&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/div&gt;
&lt;div class=&#34;panel_bottom&#34; style=&#34;font-size:14px; height:auto; font-family:&#39;Times New Roman&#39;; margin:0px&#34;&gt;
    &amp;nbsp;
&lt;/div&gt;
&lt;br style=&#34;font-size:14px; font-family:&#39;Times New Roman&#39;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;panel_title&#34; align=&#34;left&#34; style=&#34;font-size:18px; height:38px; font-family:Arial; font-weight:bold; color:rgb(124,169,237); padding-bottom:0px; padding-top:0px; padding-left:14px; padding-right:14px; background-color:transparent&#34;&gt;
    Output
&lt;/div&gt;
&lt;div class=&#34;panel_content&#34; style=&#34;font-size:14px; height:auto; font-family:&#39;Times New Roman&#39;; padding-bottom:0px; text-align:left; padding-top:0px; padding-left:20px; margin:0px; padding-right:20px&#34;&gt;
    请输出一个整数，即湫湫当天可以用于锻炼的时间（单位分钟）
&lt;/div&gt;
&lt;div class=&#34;panel_bottom&#34; style=&#34;font-size:14px; height:auto; font-family:&#39;Times New Roman&#39;; margin:0px&#34;&gt;
    &amp;nbsp;
&lt;/div&gt;
&lt;br style=&#34;font-size:14px; font-family:&#39;Times New Roman&#39;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;panel_title&#34; align=&#34;left&#34; style=&#34;font-size:18px; height:38px; font-family:Arial; font-weight:bold; color:rgb(124,169,237); padding-bottom:0px; padding-top:0px; padding-left:14px; padding-right:14px; background-color:transparent&#34;&gt;
    Sample Input
&lt;/div&gt;
&lt;div class=&#34;panel_content&#34; style=&#34;font-size:14px; height:auto; font-family:&#39;Times New Roman&#39;; padding-bottom:0px; text-align:left; padding-top:0px; padding-left:20px; margin:0px; padding-right:20px&#34;&gt;
    &lt;pre style=&#34;margin-bottom:0px; margin-top:0px&#34;&gt;&lt;div style=&#34;font-family:&#39;Courier New&#39;,Courier,monospace&#34;&gt;1
15:36 18:40
4
01:35 10:36
04:54 22:36
10:18 18:40
11:47 17:53&lt;/div&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;panel_bottom&#34; style=&#34;font-size:14px; height:auto; font-family:&#39;Times New Roman&#39;; margin:0px&#34;&gt;
    &amp;nbsp;
&lt;/div&gt;
&lt;br style=&#34;font-size:14px; font-family:&#39;Times New Roman&#39;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;panel_title&#34; align=&#34;left&#34; style=&#34;font-size:18px; height:38px; font-family:Arial; font-weight:bold; color:rgb(124,169,237); padding-bottom:0px; padding-top:0px; padding-left:14px; padding-right:14px; background-color:transparent&#34;&gt;
    Sample Output
&lt;/div&gt;
&lt;div class=&#34;panel_content&#34; style=&#34;font-size:14px; height:auto; font-family:&#39;Times New Roman&#39;; padding-bottom:0px; text-align:left; padding-top:0px; padding-left:20px; margin:0px; padding-right:20px&#34;&gt;
    &lt;pre style=&#34;margin-bottom:0px; margin-top:0px&#34;&gt;&lt;div style=&#34;font-family:&#39;Courier New&#39;,Courier,monospace&#34;&gt;1256
179&lt;/p&gt;

&lt;p&gt;&lt;div style=&#34;border-top:rgb(183,203,255) 1px dashed; font-family:&#39;Times New Roman&#39;; border-right:rgb(183,203,255) 1px dashed; border-bottom:rgb(183,203,255) 1px dashed; padding-bottom:6px; padding-top:6px; padding-left:6px; border-left:rgb(183,203,255) 1px dashed; padding-right:6px; background-color:rgb(244,251,255)&#34;&gt;&lt;div style=&#34;font-family:Arial; border-bottom:rgb(183,203,255) 1px dashed; font-weight:bold; color:rgb(124,169,237)&#34;&gt;&lt;em&gt;Hint&lt;/em&gt;&lt;/div&gt;
大量输入，建议用scanf读数据。
&lt;/div&gt;&lt;span style=&#34;font-size:1px&#34;&gt; &lt;/span&gt; &lt;/div&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;panel_bottom&#34; style=&#34;font-size:14px; height:auto; font-family:&#39;Times New Roman&#39;; margin:0px&#34;&gt;
    &amp;nbsp;
&lt;/div&gt;
&lt;br style=&#34;font-size:14px; font-family:&#39;Times New Roman&#39;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;panel_content&#34; style=&#34;font-size:14px; height:auto; font-family:&#39;Times New Roman&#39;; padding-bottom:0px; text-align:left; padding-top:0px; padding-left:20px; margin:0px; padding-right:20px&#34;&gt;
    &lt;span style=&#34;font-size:24px&#34;&gt;&lt;strong&gt;题解：&lt;/strong&gt;&lt;/span&gt;
&lt;/div&gt;
&lt;div class=&#34;panel_bottom&#34; style=&#34;font-size:14px; height:auto; font-family:&#39;Times New Roman&#39;; margin:0px&#34;&gt;
    &amp;nbsp;
&lt;/div&gt;
&lt;p&gt;
    &lt;span style=&#34;font-family:KaiTi_GB2312; font-size:24px&#34;&gt;&lt;strong&gt;&amp;nbsp; &amp;nbsp; 由于时间是以分钟为单位，我们可以把时间看做 24 * 60 个 点 初值为 0&lt;/strong&gt;&lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
    &lt;span style=&#34;font-family:KaiTi_GB2312; font-size:24px&#34;&gt;&lt;strong&gt;&amp;nbsp; &amp;nbsp; 若某个点被占用， 记为 1&lt;/strong&gt;&lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
    &lt;span style=&#34;font-family:KaiTi_GB2312; font-size:24px&#34;&gt;&lt;strong&gt;&amp;nbsp; &amp;nbsp;最后统计 为 0 点 的 个数 即为可用时间&lt;/strong&gt;&lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
    &lt;span style=&#34;font-family:KaiTi_GB2312; font-size:24px&#34;&gt;&lt;strong&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;/strong&gt;&lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
    &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;
&lt;p&gt;
    &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;
&lt;/p&gt;&lt;/p&gt;
</description>
    </item>
  </channel>
</rss>